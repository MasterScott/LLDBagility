diff --git a/Config.kmk b/Config.kmk
index f185afbd..f62e4264 100644
--- a/Config.kmk
+++ b/Config.kmk
@@ -958,7 +958,7 @@ endif
 # Continue to support Vista w/o any service pack, at least for now.
 VBOX_WITH_VISTA_NO_SP = 1
 # Enable image verification on darwin @bugref{9232}.
-VBOX_WITH_DARWIN_R0_DARWIN_IMAGE_VERIFICATION = 1
+#VBOX_WITH_DARWIN_R0_DARWIN_IMAGE_VERIFICATION = 0
 ## @}
 
 
@@ -1710,9 +1710,9 @@ ifdef VBOX_WITH_RAW_MODE
 endif
 
 # Don't flood CDEFS, old MASMs doesn't like too many defines.
-ifdef VBOX_WITH_DEBUGGER
+#ifdef VBOX_WITH_DEBUGGER
  CDEFS += VBOX_WITH_DEBUGGER
-endif
+#endif
 ifdef VBOX_WITH_HARDENING
  CDEFS += VBOX_WITH_HARDENING
 endif
diff --git a/configure b/configure
index feeaae25..bd812daa 100755
--- a/configure
+++ b/configure
@@ -152,7 +152,8 @@ INCVPX=""
 LIBVPX="-lvpx"
 PKGCONFIG="`which_wrapper pkg-config`"
 PYTHONDIR="/usr /usr/local"
-QT5DIR="/usr/lib/qt5 /usr/share/qt5 /usr/lib64/qt5 /usr /usr/local"
+#QT5DIR="/usr/lib/qt5 /usr/share/qt5 /usr/lib64/qt5 /usr /usr/local"
+QT5DIR="/usr/lib/qt5 /usr/share/qt5 /usr/lib64/qt5 /usr /usr/local /opt/local/libexec/qt5"
 QT5DIR_PKGCONFIG=1
 QT5MAJ=5
 QT5MIN=6
@@ -1504,7 +1505,8 @@ EOF
     # Now try the user provided directory and some of the standard directories.
     QT_TRIES="$QT5DIR /System/Library /Library"
     for t in $QT_TRIES; do
-      if [ -f "$t/Frameworks/QtCore.framework/QtCore" ]; then
+      #if [ -f "$t/Frameworks/QtCore.framework/QtCore" ]; then
+      if [ -f "$t/lib/QtCore.framework/QtCore" ]; then
         PATH_SDK_QT5="$t"
         break
       fi
@@ -1512,8 +1514,10 @@ EOF
     # Add the necessary params for building the test application
     if [ -n "$PATH_SDK_QT5" ]; then
       foundqt5=1
-      INCQT5=-I$PATH_SDK_QT5/Frameworks/QtCore.framework/Headers
-      LIBQT5=-F$PATH_SDK_QT5/Frameworks
+      #INCQT5=-I$PATH_SDK_QT5/Frameworks/QtCore.framework/Headers
+      #LIBQT5=-F$PATH_SDK_QT5/Frameworks
+      INCQT5=-I$PATH_SDK_QT5/lib/QtCore.framework/Headers
+      LIBQT5=-F$PATH_SDK_QT5/lib
       FLGQT5="-framework QtCore"
     else
       log_failure "Qt5 framework not found (can be disabled using --disable-qt)"
@@ -1594,9 +1598,12 @@ EOF
         if [ "$OS" = "darwin" ]; then
           # Successful build & run the test application so add the necessary
           # params to AutoConfig.kmk:
-          cnf_append "PATH_SDK_QT5_INC" "$PATH_SDK_QT5/Frameworks"
-          cnf_append "PATH_SDK_QT5_LIB" "$PATH_SDK_QT5/Frameworks"
-          cnf_append "PATH_SDK_QT5" "$PATH_SDK_QT5/Frameworks"
+          #cnf_append "PATH_SDK_QT5_INC" "$PATH_SDK_QT5/Frameworks"
+          #cnf_append "PATH_SDK_QT5_LIB" "$PATH_SDK_QT5/Frameworks"
+          #cnf_append "PATH_SDK_QT5" "$PATH_SDK_QT5/Frameworks"
+          cnf_append "PATH_SDK_QT5_INC" "$PATH_SDK_QT5/inc"
+          cnf_append "PATH_SDK_QT5_LIB" "$PATH_SDK_QT5/lib"
+          cnf_append "PATH_SDK_QT5" "$PATH_SDK_QT5"
           # Check for the moc tool in the Qt directory found & some standard
           # directories.
           for q in $PATH_SDK_QT5 /usr /Developer/Tools/Qt; do
@@ -2196,6 +2203,14 @@ check_darwinversion()
   test_header "Darwin version"
   darwin_ver=`uname -r`
   case "$darwin_ver" in
+    18\.*)
+      check_xcode_sdk_path "$WITH_XCODE_DIR"
+      [ $? -eq 1 ] || fail
+      darwin_ver="10.14" # Mojave
+      sdk=$WITH_XCODE_DIR/Developer/SDKs/MacOSX10.6.sdk
+      cnf_append "VBOX_WITH_MACOSX_COMPILERS_FROM_DEVEL" "1"
+      cnf_append "VBOX_PATH_MACOSX_DEVEL_ROOT" "$WITH_XCODE_DIR/Developer"
+      ;;
     17\.*)
       check_xcode_sdk_path "$WITH_XCODE_DIR"
       [ $? -eq 1 ] || fail
diff --git a/include/VBox/vmm/em.h b/include/VBox/vmm/em.h
index e15ed5ea..86552ced 100644
--- a/include/VBox/vmm/em.h
+++ b/include/VBox/vmm/em.h
@@ -331,6 +331,10 @@ VMMR3DECL(DECLNORETURN(void))   EMR3FatalError(PVMCPU pVCpu, int rc);
 VMMR3_INT_DECL(int)             EMR3ExecuteVM(PVM pVM, PVMCPU pVCpu);
 VMMR3_INT_DECL(int)             EMR3CheckRawForcedActions(PVM pVM, PVMCPU pVCpu);
 VMMR3_INT_DECL(VBOXSTRICTRC)    EMR3HmSingleInstruction(PVM pVM, PVMCPU pVCpu, uint32_t fFlags);
+/*MYCODE*/
+VMMR3_INT_DECL(void)            EMR3ResetU(PUVM pUVM);
+VMMR3_INT_DECL(int)             EMR3ProcessForcedAction(PVM pVM, PVMCPU pVCpu, int rc);
+/*ENDMYCODE*/
 
 /** @} */
 #endif /* IN_RING3 */
diff --git a/include/VBox/vmm/gmm.h b/include/VBox/vmm/gmm.h
index dc358d84..3250459c 100644
--- a/include/VBox/vmm/gmm.h
+++ b/include/VBox/vmm/gmm.h
@@ -550,6 +550,16 @@ typedef GMMMEMSTATSREQ *PGMMMEMSTATSREQ;
 GMMR0DECL(int)  GMMR0QueryHypervisorMemoryStatsReq(PGMMMEMSTATSREQ pReq);
 GMMR0DECL(int)  GMMR0QueryMemoryStatsReq(PGVM pGVM, VMCPUID idCpu, PGMMMEMSTATSREQ pReq);
 
+/*MYCODE*/
+typedef struct ALLOCPAGEREQ
+{
+    SUPVMMR0REQHDR  Hdr;
+    uint64_t        newPageSize;
+    uint64_t        newPageHCPHys;
+    uint8_t*        newPageR3Ptr;
+} ALLOCPAGEREQ;
+/*ENDMYCODE*/
+
 /**
  * Request buffer for GMMR0MapUnmapChunkReq / VMMR0_DO_GMM_MAP_UNMAP_CHUNK.
  * @see GMMR0MapUnmapChunk
diff --git a/include/VBox/vmm/hm.h b/include/VBox/vmm/hm.h
index d004843c..d9bbe945 100644
--- a/include/VBox/vmm/hm.h
+++ b/include/VBox/vmm/hm.h
@@ -152,6 +152,9 @@ VMM_INT_DECL(TRPMEVENT)         HMSvmEventToTrpmEventType(PCSVMEVENT pSvmEvent,
  * @{ */
 VMM_INT_DECL(int)               HMFlushTlb(PVMCPU pVCpu);
 VMM_INT_DECL(int)               HMFlushTlbOnAllVCpus(PVMCC pVM);
+/*MYCODE*/
+VMM_INT_DECL(int)               HMFlushTLBOnAllVCpus2(PVMCPUCC pVCpu);
+/*ENDMYCODE*/
 VMM_INT_DECL(int)               HMInvalidatePageOnAllVCpus(PVMCC pVM, RTGCPTR GCVirt);
 VMM_INT_DECL(int)               HMInvalidatePhysPage(PVMCC pVM, RTGCPHYS GCPhys);
 VMM_INT_DECL(bool)              HMAreNestedPagingAndFullGuestExecEnabled(PVM pVM);
@@ -203,6 +206,9 @@ VMM_INT_DECL(int)               HMHCMaybeMovTprSvmHypercall(PVMCC pVM, PVMCPUCC
  * @{
  */
 VMMR0_INT_DECL(int)             HMR0Init(void);
+/*MYCODE*/
+VMMR0_INT_DECL(int)             HMR0FlushEPT(PVM pVM, PVMCPU pVCpu);
+/*ENDMYCODE*/
 VMMR0_INT_DECL(int)             HMR0Term(void);
 VMMR0_INT_DECL(int)             HMR0InitVM(PVMCC pVM);
 VMMR0_INT_DECL(int)             HMR0TermVM(PVMCC pVM);
diff --git a/include/VBox/vmm/mm.h b/include/VBox/vmm/mm.h
index 08ed77f8..a8d2c2e3 100644
--- a/include/VBox/vmm/mm.h
+++ b/include/VBox/vmm/mm.h
@@ -215,6 +215,9 @@ VMMDECL(bool)       MMHyperIsInsideArea(PVM pVM, RTGCPTR GCPtr);
 #if 0
 VMMDECL(RTHCPHYS)   MMPage2Phys(PVM pVM, void *pvPage);
 VMMDECL(void *)     MMPagePhys2Page(PVM pVM, RTHCPHYS HCPhysPage);
+/*MYCODE*/
+VMMDECL(void *)     MMPagePhys2PageU(PUVM pUVM, RTHCPHYS HCPhysPage);
+/*ENDCODE*/
 VMMDECL(int)        MMPagePhys2PageEx(PVM pVM, RTHCPHYS HCPhysPage, void **ppvPage);
 VMMDECL(int)        MMPagePhys2PageTry(PVM pVM, RTHCPHYS HCPhysPage, void **ppvPage);
 #endif
@@ -281,6 +284,9 @@ VMMR3DECL(int)      MMR3HyperReadGCVirt(PVM pVM, void *pvDst, RTGCPTR GCPtr, siz
  * @todo retire this group, elimintating or moving MMR3PhysGetRamSize to PGMPhys.
  * @{ */
 VMMR3DECL(uint64_t) MMR3PhysGetRamSize(PVM pVM);
+/*MYCODE*/
+VMMR3DECL(uint64_t) MMR3PhysGetRamSizeU(PUVM pUVM);
+/*ENDMYCODE*/
 VMMR3DECL(uint32_t) MMR3PhysGetRamSizeBelow4GB(PVM pVM);
 VMMR3DECL(uint64_t) MMR3PhysGetRamSizeAbove4GB(PVM pVM);
 VMMR3DECL(uint32_t) MMR3PhysGet4GBRamHoleSize(PVM pVM);
diff --git a/include/VBox/vmm/pgm.h b/include/VBox/vmm/pgm.h
index 3be1a767..0f9a0bf8 100644
--- a/include/VBox/vmm/pgm.h
+++ b/include/VBox/vmm/pgm.h
@@ -342,6 +342,21 @@ VMMDECL(int)            PGMShwMakePageNotPresent(PVMCPUCC pVCpu, RTGCPTR GCPtr,
 /** The page is an MMIO2. */
 #define PGM_MK_PG_IS_MMIO2           RT_BIT(1)
 /** @}*/
+/*MYCODE*/
+VMMDECL(int)        PGMShwGetHCPage(PVMCPUCC pVCpu, uint64_t GCPhys, uint64_t *HCPhys);
+VMMDECL(int)        PGMShwSetHCPage(PVMCPUCC pVCpu, uint64_t GCPhys, uint64_t HCPhys);
+VMMDECL(int)        PGMShwSaveRights(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwRestoreRights(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwPresent(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoPresent(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwWrite(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoWrite(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwExecute(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoExecute(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwInvalidate(PVMCPUCC pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwSetBreakable(PVMCPUCC pVCpu, uint64_t GCPhys, bool Breakable);
+VMMDECL(bool)       PGMShwIsBreakable(PVMCPUCC pVCpu, uint64_t GCPhys);
+/*ENDMYCODE*/
 VMMDECL(int)        PGMGstGetPage(PVMCPUCC pVCpu, RTGCPTR GCPtr, uint64_t *pfFlags, PRTGCPHYS pGCPhys);
 VMMDECL(bool)       PGMGstIsPagePresent(PVMCPUCC pVCpu, RTGCPTR GCPtr);
 VMMDECL(int)        PGMGstSetPage(PVMCPUCC pVCpu, RTGCPTR GCPtr, size_t cb, uint64_t fFlags);
@@ -550,6 +565,9 @@ VMMDECL(VBOXSTRICTRC) PGMPhysReadGCPtr(PVMCPUCC pVCpu, void *pvDst, RTGCPTR GCPt
 VMMDECL(VBOXSTRICTRC) PGMPhysWriteGCPtr(PVMCPUCC pVCpu, RTGCPTR GCPtrDst, const void *pvSrc, size_t cb, PGMACCESSORIGIN enmOrigin);
 
 VMMDECL(int)        PGMPhysSimpleReadGCPhys(PVMCC pVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+/*MYCODE*/
+VMMDECL(int)        PGMPhysSimpleReadGCPhys2(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+/*MYCODE*/
 VMMDECL(int)        PGMPhysSimpleWriteGCPhys(PVMCC pVM, RTGCPHYS GCPhysDst, const void *pvSrc, size_t cb);
 VMMDECL(int)        PGMPhysSimpleReadGCPtr(PVMCPUCC pVCpu, void *pvDst, RTGCPTR GCPtrSrc, size_t cb);
 VMMDECL(int)        PGMPhysSimpleWriteGCPtr(PVMCPUCC pVCpu, RTGCPTR GCPtrDst, const void *pvSrc, size_t cb);
@@ -689,6 +707,9 @@ VMMR0DECL(int)       PGMR0Trap0eHandlerNestedPaging(PGVM pGVM, PGVMCPU pGVCpu, P
                                                     PCPUMCTXCORE pRegFrame, RTGCPHYS pvFault);
 VMMR0DECL(VBOXSTRICTRC) PGMR0Trap0eHandlerNPMisconfig(PGVM pGVM, PGVMCPU pGVCpu, PGMMODE enmShwPagingMode,
                                                       PCPUMCTXCORE pRegFrame, RTGCPHYS GCPhysFault, uint32_t uErr);
+/*MYCODE*/
+VMMR0DECL(VBOXSTRICTRC) PGMR0PhysSimpleReadGCPhys(PVM pVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+/*ENDMYCODE*/
 VMMR0_INT_DECL(int)  PGMR0PoolGrow(PGVM pGVM);
 
 # ifdef VBOX_WITH_2X_4GB_ADDR_SPACE
@@ -720,6 +741,9 @@ VMMR3_INT_DECL(void)    PGMR3ResetNoMorePhysWritesFlag(PVM pVM);
 VMMR3_INT_DECL(void)    PGMR3MemSetup(PVM pVM, bool fReset);
 VMMR3DECL(int)      PGMR3Term(PVM pVM);
 VMMR3DECL(int)      PGMR3LockCall(PVM pVM);
+/*MYCODE*/
+VMMR3DECL(int)      PGMR3ChangeMode2(PUVM pUVM, PVMCPU pVCpu, PGMMODE enmGuestMode);
+/*ENDMYYCODE*/
 
 VMMR3DECL(int)      PGMR3PhysRegisterRam(PVM pVM, RTGCPHYS GCPhys, RTGCPHYS cb, const char *pszDesc);
 VMMR3DECL(int)      PGMR3PhysChangeMemBalloon(PVM pVM, bool fInflate, unsigned cPages, RTGCPHYS *paPhysPage);
@@ -816,6 +840,10 @@ VMMR3DECL(int)      PGMR3PhysBulkGCPhys2CCPtrReadOnlyExternal(PVM pVM, uint32_t
 VMMR3DECL(int)      PGMR3PhysChunkMap(PVM pVM, uint32_t idChunk);
 VMMR3DECL(void)     PGMR3PhysChunkInvalidateTLB(PVM pVM);
 VMMR3DECL(int)      PGMR3PhysAllocateHandyPages(PVM pVM);
+/*MYCODE*/
+VMMR3DECL(int)      PGMR3PhysAllocateLargeHandyPage2(PVM pVM);
+VMMR3_INT_DECL(int) PGMR3DbgScanPhysicalU(PUVM pUVM, RTGCPHYS GCPhys, RTGCPHYS cbRange, RTGCPHYS GCPhysAlign, const uint8_t *pabNeedle, size_t cbNeedle, PRTGCPHYS pGCPhysHit);
+/*ENDMYCODE*/
 VMMR3DECL(int)      PGMR3PhysAllocateLargeHandyPage(PVM pVM, RTGCPHYS GCPhys);
 
 VMMR3DECL(int)      PGMR3CheckIntegrity(PVM pVM);
diff --git a/include/VBox/vmm/vm.h b/include/VBox/vmm/vm.h
index d56e2d5c..cf7bbe1f 100644
--- a/include/VBox/vmm/vm.h
+++ b/include/VBox/vmm/vm.h
@@ -54,6 +54,61 @@
  * @{
  */
 
+/*MYCODE*/
+typedef struct HardwarePage_t{
+    int            ReferenceCount; //Number of breakpoint using this page
+    uint64_t    PageSize;        //Size of the page
+    uint64_t    HCPhys;            //Host-Context physical address of the page
+    uint8_t*    R3Ptr;            //Ring-3 virtual address of the page
+}HardwarePage_t;
+
+typedef struct GCPhysArea_t{
+    uint64_t    Start;
+    uint64_t    End;
+}GCPhysArea_t;
+
+typedef struct PfnEntrie_t{
+    uint8_t n;
+    struct{
+        bool u1Present;
+        bool u1Write;
+        bool u1Execute;
+        bool u1Breakable;
+    }u;
+}PfnEntrie_t;
+
+typedef struct BreakpointEntrie_t{
+            //Is the breakpoint activated or free
+            bool        breakpointActivated;
+            //Tag the breakpoint to know if the breakpoint changed...
+            uint64_t    breakpointTag;
+            //Kind of breakpoint PAGEHBP, HARDHBP, SOFTHBP
+            uint8_t        breakpointType;
+            //Guest virtual address of the breakpoint or start of the breakpoint
+            uint64_t    breakpointGCPtr;
+            //Guest physical address of the breakpoint or start of the breakpoint
+            uint64_t    breakpointGCPhys;
+            //Lengt of the breakpoint (PAGEHBP only)
+            uint64_t    breakpointLength;
+            //EXECUTE_BP, READ_BP, WRITE_BP
+            uint8_t        breakpointAccessType;
+            //Size of the page where the breakpoint is
+            uint64_t    breakpointPageSize;
+            //Original host physical page
+            uint64_t    breakpointOrigHCPhys;
+            //Original opcode byte
+            uint8_t        breakpointOriginalByte;
+            //Pointer to HardwarePage
+            HardwarePage_t* breakpointHardwarePage;
+            uint64_t        breakpointGCPhysAreaCount;
+            GCPhysArea_t*    breakpointGCPhysAreaTable;
+            //Condition
+            uint64_t    breakpointCr3;
+}BreakpointEntrie_t;
+
+#define MAX_BREAKPOINT_ID 255
+/*ENDMYCODE*/
+
 /**
  * The state of a Virtual CPU.
  *
@@ -144,6 +199,34 @@ typedef struct VMCPU
         uint8_t             padding[18496];     /* multiple of 64 */
     } iem;
 
+    /*MYCODE*/
+    union
+    {
+        struct{
+            volatile uint8_t    u8StateBitmap;
+            volatile bool        bSingleStepRequired;
+            volatile bool        bPauseRequired;
+            volatile bool        bDisableInterrupt;
+            volatile bool        bRebootRequired;
+            volatile bool        bSuspendRequired;
+            volatile bool        bRestoreRequired;
+            volatile bool        bPageFaultOverflowGuard;
+
+            volatile bool        bHardHyperBreakPointHitted;
+            volatile bool        bPageHyperBreakPointHitted;
+            volatile bool        bSoftHyperBreakPointHitted;
+            volatile bool        bMsrHyperBreakPointHitted;
+            volatile bool        bCrHyperBreakPointHitted;
+            volatile bool        bInstallDrBreakpointRequired;
+            //Fake Debug registers to keep "legit-guest" values
+            uint64_t            aGuestDr[8];
+            volatile uint64_t   u64TickCount;
+            void*               pCpuShm;
+        }s;
+        uint8_t             padding[4096];      /* multiple of 4096 */
+    } mystate;
+    /*ENDMYCODE*/
+
     /** @name Static per-cpu data.
      * (Putting this after IEM, hoping that it's less frequently used than it.)
      * @{ */
@@ -1263,6 +1346,28 @@ typedef struct VM
         uint8_t     padding[1600];      /* multiple of 64 */
     } vmm;
 
+    /*MYCODE*/
+    union{
+        BreakpointEntrie_t  l[MAX_BREAKPOINT_ID+1];
+        uint8_t             padding[4096*32];      /* Must be page aligned ! */
+    }bp;
+
+    union{
+        struct{
+            void                *pFdpShm;
+            uint32_t            u32HardwarePageTableCount;
+            HardwarePage_t      aHardwarePageTable[64];
+            volatile uint8_t    u8StateBitmap;
+            char                PageSpinLockName[256];
+            RTSPINLOCK          PageSpinlock;
+            PfnEntrie_t         *pPfnTableR3;
+            PfnEntrie_t         *pPfnTableR0;
+            RTSPINLOCK          CpuLock;
+        }s;
+        uint8_t     padding[4096];      /* Must be page aligned ! */
+    }mystate;
+    /*ENDMYCODE*/
+
     /** PGM part. */
     union
     {
diff --git a/include/VBox/vmm/vm.mac b/include/VBox/vmm/vm.mac
index 072b3a99..25bd83c4 100644
--- a/include/VBox/vmm/vm.mac
+++ b/include/VBox/vmm/vm.mac
@@ -50,6 +50,7 @@ struc VMCPU
 
     alignb 64
     .iem                    resb 18496
+    .mystate                resb 4096
 
     alignb 64
     .pVMR3                  RTR3PTR_RES 1
@@ -120,6 +121,8 @@ struc VM
     alignb 64
     .cpum                   resb 1536
     .vmm                    resb 1600
+    .bp                     resb (4096*32)
+    .mystate                resb 4096
     .pgm                    resb 21120
     .hm                     resb 5504
     .trpm                   resb 5248
diff --git a/include/VBox/vmm/vmapi.h b/include/VBox/vmm/vmapi.h
index 2e9da4f8..29f67e7c 100644
--- a/include/VBox/vmm/vmapi.h
+++ b/include/VBox/vmm/vmapi.h
@@ -442,6 +442,32 @@ VMMR3_INT_DECL(void)        VMR3NotifyGlobalFFU(PUVM pUVM, uint32_t fFlags);
 VMMR3_INT_DECL(void)        VMR3NotifyCpuFFU(PUVMCPU pUVMCpu, uint32_t fFlags);
 VMMR3DECL(int)              VMR3NotifyCpuDeviceReady(PVM pVM, VMCPUID idCpu);
 VMMR3_INT_DECL(int)         VMR3WaitHalted(PVM pVM, PVMCPU pVCpu, bool fIgnoreInterrupts);
+/*MYCODE*/
+VMMDECL(uint8_t)            VMR3GetFDPState(PUVM pUVM);
+VMMR3_INT_DECL(int)         VMR3AddExecHardBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint64_t GCPtr, uint8_t BreakpointId);
+VMMR3_INT_DECL(int)         VMR3AddSoftBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointCr3);
+VMMR3_INT_DECL(int)         VMR3AddPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointId, uint8_t BreakpointAccessType, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointLength);
+VMMR3_INT_DECL(int)         VMR3AddMsrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress);
+VMMR3_INT_DECL(int)         VMR3AddCrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress);
+VMMR3_INT_DECL(void)        VMR3ClearBreakpoint(uint8_t BreakpointId);
+VMMR3_INT_DECL(bool)        VMR3IsBreakpoint(uint64_t CurrentRIP);
+VMMDECL(int)                VMR3PhysSimpleReadGCPhysU(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+VMMDECL(int)                VMR3PhysSimpleWriteGCPhysU(PUVM pUVM, const void *pvBuf, RTGCPHYS GCPhys, size_t cbWrite);
+VMMR3_INT_DECL(int)         VMR3AddExecPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint64_t GCPtr, uint64_t Length);
+VMMR3_INT_DECL(bool)        VMR3RemoveBreakpoint(PUVM pUVM, int BreakpointId);
+VMMDECL(int)                VMR3SingleStep(PUVM pUVM, PVMCPU pVCpu);
+VMMDECL(int)                VMR3Break(PUVM pUVM);
+VMMDECL(int)                VMR3Continue(PUVM pUVM);
+VMMDECL(bool)               VMR3GetFDPRunning(PUVM pUVM);
+VMMDECL(void)               VMR3SetFDPRunning(PUVM pUVM, bool newFDPRunning);
+VMMR3DECL(uint32_t)         VMR3GetCPUCount(PUVM pUVM);
+VMMDECL(bool)               VMR3HandleSingleStep(PVM pVM, PVMCPU pVCpu);
+VMMDECL(bool)               VMR3EnterPause(PVM pVM, PVMCPU pVCpu);
+VMMDECL(void)               VMR3SetFDPShm(PUVM pUVM, void *pFdpShm);
+VMMDECL(uint64_t)           VMR3Test(PVMCPU pVCpu);
+VMMDECL(int)                VMR3InjectInterrupt(PVM pVM, PVMCPU pVCpu, uint32_t enmXcpt, uint32_t uErr, uint64_t Cr2);
+VMMDECL(int)                VMR3ClearInterrupt(PUVM pUVM, PVMCPU pVCpu);
+/*ENDMYCODE*/
 VMMR3_INT_DECL(int)         VMR3WaitU(PUVMCPU pUVMCpu);
 VMMR3DECL(int)              VMR3WaitForDeviceReady(PVM pVM, VMCPUID idCpu);
 VMMR3_INT_DECL(int)         VMR3AsyncPdmNotificationWaitU(PUVMCPU pUVCpu);
diff --git a/include/VBox/vmm/vmm.h b/include/VBox/vmm/vmm.h
index 7273fe36..0bd3e48e 100644
--- a/include/VBox/vmm/vmm.h
+++ b/include/VBox/vmm/vmm.h
@@ -248,6 +248,11 @@ VMM_INT_DECL(uint32_t)      VMMGetSvnRev(void);
 VMM_INT_DECL(bool)          VMMIsInRing3Call(PVMCPUCC pVCpu);
 VMM_INT_DECL(void)          VMMTrashVolatileXMMRegs(void);
 
+/*MYCODE*/
+VMM_INT_DECL(bool)          VMMMatchBreakpointId(PVM pVM, int BreakpointId, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess);
+VMM_INT_DECL(int)           VMMGetBreakpointId(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess);
+VMM_INT_DECL(int)           VMMGetBreakpointIdFromPage(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType);
+/*ENDMYCODE*/
 
 /** @defgroup grp_vmm_api_r0    The VMM Host Context Ring 0 API
  * @{
@@ -426,6 +431,10 @@ typedef enum VMMR0OPERATION
     /** Official call we use for testing Ring-0 APIs. */
     VMMR0_DO_TESTS = 704,
 
+    /*MYCODE*/
+    VMMR0_DO_ALLOC_HCPHYS,
+    /*ENDMYCODE*/
+
     /** The usual 32-bit type blow up. */
     VMMR0_DO_32BIT_HACK = 0x7fffffff
 } VMMR0OPERATION;
diff --git a/src/VBox/Debugger/DBGCTcp.cpp b/src/VBox/Debugger/DBGCTcp.cpp
index 7a5c2ea0..a138fa8f 100644
--- a/src/VBox/Debugger/DBGCTcp.cpp
+++ b/src/VBox/Debugger/DBGCTcp.cpp
@@ -30,6 +30,12 @@
 
 #include <iprt/string.h>
 
+/*MYCODE*/
+#include <pthread.h>
+#include <unistd.h>
+#include <VBox/vmm/vm.h>
+/*MYCODE*/
+
 
 /*********************************************************************************************************************************
 *   Structures and Typedefs                                                                                                      *
@@ -58,7 +64,940 @@ typedef DBGCTCP *PDBGCTCP;
 *********************************************************************************************************************************/
 static DECLCALLBACK(int)  dbgcTcpConnection(RTSOCKET Sock, void *pvUser);
 
+/*MYCODE*/
+#include <stdio.h>
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+#include <FDP/FDP.c>
+
+#include <VBox/vmm/pgm.h>
+#include <VBox/vmm/mm.h>
+#include <VBox/vmm/cpum.h>
+
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+#define DEBUG_LEVEL 0
+#define DEBUG_FLOW 0
+
+#if DEBUG_LEVEL > 0
+#define Log1(fmt,...) printf(fmt, ##__VA_ARGS__)
+#else
+#define Log1(fmt,...)
+#endif
+
+#if DEBUG_LEVEL > 2
+#define Log3(fmt,...) printf(fmt, ##__VA_ARGS__)
+#else
+#define Log3(fmt,...)
+#endif
+
+#ifdef DEBUG_FLOW > 0
+#define LogFloww() printf("%s\n", __FUNCTION__);
+#else
+#define LogFloww()
+#endif
+
+typedef struct _MEMORY_SSM_T{
+    uint8_t        *pMemory;
+    uint64_t    cbMemory;
+    uint64_t    CurrentOffset;
+    uint64_t    MaxOffset;
+}MEMORY_SSM_T;
+
+typedef struct FDPVBOX_USERHANDLE_T{
+    PUVM            pUVM;
+    MEMORY_SSM_T*    pMemorySSM;
+    FDP_SHM*        pFDPServer;
+    uint64_t        aVisibleGuestDebugRegisterSave[7];
+    char            TempBuffer[1*1024*1024];
+}FDPVBOX_USERHANDLE_T;
+
+bool FDPVBOX_Resume(void *pUserHandle)
+{
+    LogFlow(("RESUME\n"));
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    VMR3Continue(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_Pause(void *pUserHandle)
+{
+    Log1("PAUSE !\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    VMR3Break(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_singleStep(void *pUserHandle, uint32_t CpuId)
+{
+    LogFlow(("SINGLE_STEP\n"));
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    int rc = VMR3SingleStep(myVBOXHandle->pUVM, pVCpu);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_getMemorySize(void *pUserHandle, uint64_t* MemorySize)
+{
+    Log1("GET_PHYSICALMEMORYSIZE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *MemorySize = MMR3PhysGetRamSizeU(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_readPhysicalMemory(void *pUserHandle, uint8_t *pDstBuffer, uint64_t PhysicalAddress, uint32_t ReadSize)
+{
+    Log1("READ_PHYSICAL %p %d ... ", PhysicalAddress, ReadSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    int rc = VMR3PhysSimpleReadGCPhysU(myVBOXHandle->pUVM, pDstBuffer, PhysicalAddress, ReadSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+
+bool FDPVBOX_writePhysicalMemory(void *pUserHandle, uint8_t *pSrcBuffer, uint64_t PhysicalAddress, uint32_t WriteSize)
+{
+    Log1("WRITE_PHYSICAL %p %d...", PhysicalAddress, WriteSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+
+    //Check Read access
+    if(FDPVBOX_readPhysicalMemory(pUserHandle, (uint8_t*)myVBOXHandle->TempBuffer, PhysicalAddress, WriteSize) == false){
+        return false;
+    }
+    //Effective Write
+    int rc =  VMR3PhysSimpleWriteGCPhysU(myVBOXHandle->pUVM, pSrcBuffer, PhysicalAddress, WriteSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+
+bool FDPVBOX_writeVirtualMemory(void *pUserHandle, uint32_t CpuId, uint8_t *pSrcBuffer, uint64_t VirtualAddress, uint32_t WriteSize)
+{
+    Log1("writeVirtualMemory %p %d ...", VirtualAddress, WriteSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    int rc = PGMPhysSimpleWriteGCPtr(pVCpu, VirtualAddress, pSrcBuffer, WriteSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_writeMsr(void *pUserHandle, uint32_t CpuId, uint64_t MSRId, uint64_t MSRValue)
+{
+    Log1("WRITE_MSR %p %p\n", MSRId, MSRValue);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    CPUMSetGuestMsr(pVCpu, MSRId, MSRValue);
+    //if(RT_SUCCESS(rc)){
+    //    return true;
+    //}
+    return false;
+}
+
+bool FDPVBOX_getState(void *pUserHandle, uint8_t *currentState)
+{
+    Log3("GET_STATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *currentState = VMR3GetFDPState(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_getCpuState(void *pUserHandle, uint32_t CpuId, uint8_t *pCurrentState)
+{
+    Log1("GET_CPU_STATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    *pCurrentState = pVCpu->mystate.s.u8StateBitmap;
+    return true;
+}
+
+
+bool FDPVBOX_getCpuCount(void *pUserHandle, uint32_t *pCpuCount)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *pCpuCount = VMR3GetCPUCount(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_readMsr(void *pUserHandle, uint32_t CpuId, uint64_t MsrId, uint64_t *pMsrValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    CPUMQueryGuestMsr(pVCpu, MsrId, pMsrValue);
+    Log1("READ_MSR %p => %p\n", MsrId, *pMsrValue);
+    return true;
+}
+
+bool FDPVBOX_readRegister(void *pUserHandle, uint32_t CpuId, FDP_Register RegisterId, uint64_t *pRegisterValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    PCPUMCTXCORE pRegFrame = (PCPUMCTXCORE)CPUMGetGuestCtxCore(pVCpu);
+
+    switch(RegisterId){
+        case FDP_CR0_REGISTER: *pRegisterValue = CPUMGetGuestCR0(pVCpu); break;
+        case FDP_CR2_REGISTER: *pRegisterValue = CPUMGetGuestCR2(pVCpu); break;
+        case FDP_CR3_REGISTER: *pRegisterValue = CPUMGetGuestCR3(pVCpu); break;
+        case FDP_CR4_REGISTER: *pRegisterValue = CPUMGetGuestCR4(pVCpu); break;
+        case FDP_CR8_REGISTER: *pRegisterValue = CPUMGetGuestCR8(pVCpu); break;
+        case FDP_RAX_REGISTER: *pRegisterValue = pCtxCore->rax; break;
+        case FDP_RBX_REGISTER: *pRegisterValue = pCtxCore->rbx; break;
+        case FDP_RCX_REGISTER: *pRegisterValue = pCtxCore->rcx; break;
+        case FDP_RDX_REGISTER: *pRegisterValue = pCtxCore->rdx; break;
+        case FDP_R8_REGISTER:  *pRegisterValue = pCtxCore->r8; break;
+        case FDP_R9_REGISTER:  *pRegisterValue = pCtxCore->r9; break;
+        case FDP_R10_REGISTER: *pRegisterValue = pCtxCore->r10; break;
+        case FDP_R11_REGISTER: *pRegisterValue = pCtxCore->r11; break;
+        case FDP_R12_REGISTER: *pRegisterValue = pCtxCore->r12; break;
+        case FDP_R13_REGISTER: *pRegisterValue = pCtxCore->r13; break;
+        case FDP_R14_REGISTER: *pRegisterValue = pCtxCore->r14; break;
+        case FDP_R15_REGISTER: *pRegisterValue = pCtxCore->r15; break;
+        case FDP_RSP_REGISTER: *pRegisterValue = pCtxCore->rsp; break;
+        case FDP_RBP_REGISTER: *pRegisterValue = pCtxCore->rbp; break;
+        case FDP_RSI_REGISTER: *pRegisterValue = pCtxCore->rsi; break;
+        case FDP_RDI_REGISTER: *pRegisterValue = pCtxCore->rdi; break;
+        case FDP_RIP_REGISTER: *pRegisterValue = pCtxCore->rip; break;
+
+        //Visible for Guest Debug Register
+        case FDP_VDR0_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[0]; break;
+        case FDP_VDR1_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[1]; break;
+        case FDP_VDR2_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[2]; break;
+        case FDP_VDR3_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[3]; break;
+        case FDP_VDR6_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[6]; break;
+        case FDP_VDR7_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[7]; break;
+
+        //Invisible for Guest Debug Register
+        case FDP_DR0_REGISTER: *pRegisterValue = CPUMGetGuestDR0(pVCpu); break;
+        case FDP_DR1_REGISTER: *pRegisterValue = CPUMGetGuestDR1(pVCpu); break;
+        case FDP_DR2_REGISTER: *pRegisterValue = CPUMGetGuestDR2(pVCpu); break;
+        case FDP_DR3_REGISTER: *pRegisterValue = CPUMGetGuestDR3(pVCpu); break;
+        case FDP_DR6_REGISTER: *pRegisterValue = CPUMGetGuestDR6(pVCpu); break;
+        case FDP_DR7_REGISTER: *pRegisterValue = CPUMGetGuestDR7(pVCpu); break;
+
+        case FDP_CS_REGISTER: *pRegisterValue = CPUMGetGuestCS(pVCpu); break;
+        case FDP_DS_REGISTER: *pRegisterValue = CPUMGetGuestDS(pVCpu); break;
+        case FDP_ES_REGISTER: *pRegisterValue = CPUMGetGuestES(pVCpu); break;
+        case FDP_FS_REGISTER: *pRegisterValue = CPUMGetGuestFS(pVCpu); break;
+        case FDP_GS_REGISTER: *pRegisterValue = CPUMGetGuestGS(pVCpu); break;
+        case FDP_SS_REGISTER: *pRegisterValue = CPUMGetGuestSS(pVCpu); break;
+        case FDP_RFLAGS_REGISTER: *pRegisterValue = CPUMGetGuestEFlags(pVCpu); break;
+        case FDP_GDTRB_REGISTER:
+            {
+                VBOXGDTR gdtr = {0, 0};
+                CPUMGetGuestGDTR(pVCpu,&gdtr);
+                *pRegisterValue = gdtr.pGdt;
+                break;
+            }
+        case FDP_GDTRL_REGISTER:
+            {
+                VBOXGDTR gdtr = {0, 0};
+                CPUMGetGuestGDTR(pVCpu,&gdtr);
+                *pRegisterValue = gdtr.cbGdt;
+                break;
+            }
+        case FDP_IDTRB_REGISTER:
+            {
+                uint16_t cbIDT;
+                RTGCPTR    GCPtrIDT = (RTGCPTR)CPUMGetGuestIDTR(pVCpu, &cbIDT);
+                *pRegisterValue = GCPtrIDT;
+                break;
+            }
+        case FDP_IDTRL_REGISTER:
+            {
+                uint16_t cbIDT;
+                RTGCPTR    GCPtrIDT = (RTGCPTR)CPUMGetGuestIDTR(pVCpu, &cbIDT);
+                *pRegisterValue = cbIDT;
+                break;
+            }
+        case FDP_LDTR_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                *pRegisterValue = CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                break;
+            }
+        case FDP_LDTRB_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                *pRegisterValue = Ldtrb;
+                break;
+            }
+        case FDP_LDTRL_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                *pRegisterValue = Ldtrl;
+                break;
+            }
+        case FDP_TR_REGISTER:
+            {
+                *pRegisterValue = CPUMGetGuestTR(pVCpu, NULL);
+                break;
+            }
+        default:
+            {
+                *pRegisterValue = 0xBADBADBADBADBADB;
+                return false;
+            }
+    }
+    return true;
+}
+
+bool FDPVBOX_writeRegister(void *pUserHandle, uint32_t CpuId, FDP_Register RegisterId, uint64_t RegisterValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    PCPUMCTXCORE pRegFrame = (PCPUMCTXCORE)CPUMGetGuestCtxCore(pVCpu);
+
+    FDP_CPU_CTX* pFdpCpuCtx = (FDP_CPU_CTX *)pVCpu->mystate.s.pCpuShm;
+
+    switch(RegisterId){
+        case FDP_RAX_REGISTER: pRegFrame->rax = RegisterValue; pFdpCpuCtx->rax = RegisterValue; break;
+        case FDP_RBX_REGISTER: pRegFrame->rbx = RegisterValue; pFdpCpuCtx->rbx = RegisterValue; break;
+        case FDP_RCX_REGISTER: pRegFrame->rcx = RegisterValue; pFdpCpuCtx->rcx = RegisterValue; break;
+        case FDP_RDX_REGISTER: pRegFrame->rdx = RegisterValue; pFdpCpuCtx->rdx = RegisterValue; break;
+        case FDP_R8_REGISTER:  pRegFrame->r8 = RegisterValue; pFdpCpuCtx->r8 = RegisterValue; break;
+        case FDP_R9_REGISTER:  pRegFrame->r9 = RegisterValue; pFdpCpuCtx->r9 = RegisterValue; break;
+        case FDP_R10_REGISTER: pRegFrame->r10 = RegisterValue; pFdpCpuCtx->r10 = RegisterValue; break;
+        case FDP_R11_REGISTER: pRegFrame->r11 = RegisterValue; pFdpCpuCtx->r11 = RegisterValue; break;
+        case FDP_R12_REGISTER: pRegFrame->r12 = RegisterValue; pFdpCpuCtx->r12 = RegisterValue; break;
+        case FDP_R13_REGISTER: pRegFrame->r13 = RegisterValue; pFdpCpuCtx->r13 = RegisterValue; break;
+        case FDP_R14_REGISTER: pRegFrame->r14 = RegisterValue; pFdpCpuCtx->r14 = RegisterValue; break;
+        case FDP_R15_REGISTER: pRegFrame->r15 = RegisterValue; pFdpCpuCtx->r15 = RegisterValue; break;
+        case FDP_RSP_REGISTER: pRegFrame->rsp = RegisterValue; pFdpCpuCtx->rsp = RegisterValue; break;
+        case FDP_RBP_REGISTER: pRegFrame->rbp = RegisterValue; pFdpCpuCtx->rbp = RegisterValue; break;
+        case FDP_RSI_REGISTER: pRegFrame->rsi = RegisterValue; pFdpCpuCtx->rsi = RegisterValue; break;
+        case FDP_RDI_REGISTER: pRegFrame->rdi = RegisterValue; pFdpCpuCtx->rdi = RegisterValue; break;
+        case FDP_RIP_REGISTER: pRegFrame->rip = RegisterValue; pFdpCpuCtx->rip = RegisterValue; break;
+
+        //Invisible for Guest Debug Register
+        case FDP_DR0_REGISTER: CPUMSetGuestDR0(pVCpu, RegisterValue); break;
+        case FDP_DR1_REGISTER: CPUMSetGuestDR1(pVCpu, RegisterValue); break;
+        case FDP_DR2_REGISTER: CPUMSetGuestDR2(pVCpu, RegisterValue); break;
+        case FDP_DR3_REGISTER: CPUMSetGuestDR3(pVCpu, RegisterValue); break;
+        case FDP_DR6_REGISTER: CPUMSetGuestDR6(pVCpu, RegisterValue); break;
+        case FDP_DR7_REGISTER: CPUMSetGuestDR7(pVCpu, RegisterValue); break;
+
+        //Visible for Guest Debug Register
+        case FDP_VDR0_REGISTER: pVCpu->mystate.s.aGuestDr[0] = RegisterValue; break;
+        case FDP_VDR1_REGISTER: pVCpu->mystate.s.aGuestDr[1] = RegisterValue; break;
+        case FDP_VDR2_REGISTER: pVCpu->mystate.s.aGuestDr[2] = RegisterValue; break;
+        case FDP_VDR3_REGISTER: pVCpu->mystate.s.aGuestDr[3] = RegisterValue; break;
+        case FDP_VDR6_REGISTER: pVCpu->mystate.s.aGuestDr[6] = RegisterValue; break;
+        case FDP_VDR7_REGISTER: pVCpu->mystate.s.aGuestDr[7] = RegisterValue; break;
+
+        case FDP_CS_REGISTER: CPUMSetGuestCS(pVCpu, RegisterValue); break;
+        case FDP_DS_REGISTER: CPUMSetGuestDS(pVCpu, RegisterValue); break;
+        case FDP_ES_REGISTER: CPUMSetGuestES(pVCpu, RegisterValue); break;
+        case FDP_FS_REGISTER: CPUMSetGuestFS(pVCpu, RegisterValue); break;
+        case FDP_GS_REGISTER: CPUMSetGuestGS(pVCpu, RegisterValue); break;
+        case FDP_SS_REGISTER: CPUMSetGuestSS(pVCpu, RegisterValue); break;
+        case FDP_CR0_REGISTER: CPUMSetGuestCR0(pVCpu, RegisterValue); pFdpCpuCtx->cr0 = RegisterValue; break;
+        case FDP_CR2_REGISTER: CPUMSetGuestCR2(pVCpu, RegisterValue); pFdpCpuCtx->cr3 = RegisterValue; break;
+        case FDP_CR3_REGISTER:
+        {
+            CPUMSetGuestCR3(pVCpu, RegisterValue);
+            PGMFlushTLB(pVCpu, RegisterValue, 0);
+            pFdpCpuCtx->cr3 = RegisterValue;
+            break;
+        }
+        case FDP_CR4_REGISTER: CPUMSetGuestCR4(pVCpu, RegisterValue); pFdpCpuCtx->cr4 = RegisterValue; break;
+        //case FDP_CR8_REGISTER: CPUMSetGuestCR8(pVCpu, RegisterValue); break;
+        case FDP_RFLAGS_REGISTER: CPUMSetGuestEFlags(pVCpu, RegisterValue); break;
+        default: break;
+    }
+    return true;
+}
+
+bool FDPVBOX_virtualToPhysical(void *pUserHandle, uint32_t CpuId, uint64_t VirtualAddress, uint64_t *PhysicalAddress)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    //int rc = PGMPhysGCPtr2GCPhys(pVCpu, VirtualAddress, PhysicalAddress);
+    int rc = PGMGstGetPage(pVCpu, VirtualAddress, NULL, PhysicalAddress);
+    if(RT_FAILURE(rc)){
+        return false;
+    }
+    return true;
+}
+
+bool FDPVBOX_unsetBreakpoint(void *pUserHandle, uint8_t BreakpointId)
+{
+    Log1("UNSET_BP [%d] ! \n", BreakpointId);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    int rc = VMR3RemoveBreakpoint(myVBOXHandle->pUVM, BreakpointId);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_getFxState64(void *pUserHandle, uint32_t CpuId, uint8_t *pDstBuffer, uint32_t *pDstSize)
+{
+    Log1("GET_FXSTATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    PX86FXSTATE pFpuCtx = &pCtx->CTX_SUFF(pXState)->x87;
+    memcpy(pDstBuffer, pFpuCtx, sizeof(X86FXSTATE));
+    *pDstSize = sizeof(X86FXSTATE);
+    return true;
+}
+
+bool FDPVBOX_setFxState64(void *pUserHandle, uint32_t CpuId, uint8_t *pSrcBuffer, uint32_t uSrcSize)
+{
+    Log1("SET_FXSTATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    PX86FXSTATE pFpuCtx = &pCtx->CTX_SUFF(pXState)->x87;
+    memcpy(pFpuCtx, pSrcBuffer, sizeof(X86FXSTATE));
+    return true;
+}
+
+bool FDPVBOX_readVirtualMemory(void *pUserHandle, uint32_t CpuId, uint64_t VirtualAddress, uint32_t ReadSize, uint8_t *pDstBuffer)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    int rc = 0;
+    rc = PGMPhysSimpleReadGCPtr(pVCpu, pDstBuffer, VirtualAddress, ReadSize);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+int FDPVBOX_setBreakpoint(
+    void *pUserHandle,
+    uint32_t CpuId,
+    FDP_BreakpointType BreakpointType,
+    uint8_t BreakpointId,
+    FDP_Access BreakpointAccessType,
+    FDP_AddressType BreakpointAddressType,
+    uint64_t BreakpointAddress,
+    uint64_t BreakpointLength,
+    uint64_t BreakpointCr3)
+{
+    Log1("SET_BREAKPOINT %p\n", BreakpointAddress);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return -1;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    BreakpointId = -1;
+    switch(BreakpointType){
+        case FDP_SOFTHBP:
+        {
+            BreakpointId = VMR3AddSoftBreakpoint(myVBOXHandle->pUVM, pVCpu, BreakpointAddressType, BreakpointAddress, BreakpointCr3);
+            Log1("FDP_SOFTHBP[%d] %c %p %p\n", BreakpointId, BreakpointAddressType == 0x1 ? 'v' : 'p', BreakpointAddress, BreakpointCr3);
+            break;
+        }
+        case FDP_PAGEHBP:
+        {
+            BreakpointId = VMR3AddPageBreakpoint(myVBOXHandle->pUVM, pVCpu, -1, BreakpointAccessType, BreakpointAddressType, BreakpointAddress, BreakpointLength);
+            Log1("FDP_PAGEHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        case FDP_MSRHBP:
+        {
+            BreakpointId = VMR3AddMsrBreakpoint(myVBOXHandle->pUVM, BreakpointAccessType, BreakpointAddress);
+            Log1("FDP_MSRHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        case FDP_CRHBP:
+        {
+            BreakpointId = VMR3AddCrBreakpoint(myVBOXHandle->pUVM, BreakpointAccessType, BreakpointAddress);
+            Log1("FDP_CRHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        default:
+        {
+            Log1("Unknown BreakpointType!\n");
+            break;
+        }
+    }
+
+    return BreakpointId;
+}
+
+
+bool FDPVBOX_InjectInterrupt(void *pUserHandle, uint32_t CpuId, uint32_t InterruptionCode, uint32_t ErrorCode, uint64_t Cr2){
+    Log1("InjectInterrupt\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+    VMR3InjectInterrupt(NULL, pVCpu, InterruptionCode, ErrorCode, Cr2);
+    return true;
+}
+
+bool FDPVBOX_Reboot(void *pUserHandle)
+{
+    Log1("REBOOT\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+    FDPVBOX_Pause(pUserHandle);
+    for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+        FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+    }
+    CPUMSetGuestDR7(pVCpu, 0);
+
+    //Ask the EMT the Triple fault
+    pVCpu->mystate.s.bRebootRequired = true;
+
+    FDPVBOX_Resume(pUserHandle);
+
+    //TODO: Wait for the startup
+    usleep(100 * 1000);
+
+    //Signal that the VM as changed, and what a change...
+    myVBOXHandle->pFDPServer->pSharedFDPSHM->stateChanged = true;
+
+    return true;
+}
+
+
+
+#include <VBox/vmm/ssm.h>
+#include <iprt/file.h>
+
+
+
+static DECLCALLBACK(int) nullProgressCallback(PUVM pUVM, unsigned uPercent, void *pvUser)
+{
+    NOREF(pUVM);
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryWrite(void *pvUser, uint64_t offStream, const void *pvBuf, size_t cbToWrite)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    memcpy(pMemorySSM->pMemory+offStream, pvBuf, cbToWrite);
+    pMemorySSM->CurrentOffset = offStream;
+    if(offStream+cbToWrite > pMemorySSM->MaxOffset){
+        pMemorySSM->MaxOffset = offStream+cbToWrite;
+    }
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryRead(void *pvUser, uint64_t offStream, void *pvBuf, size_t cbToRead, size_t *pcbRead)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    memcpy(pvBuf, pMemorySSM->pMemory+offStream, cbToRead);
+    *pcbRead = cbToRead;
+    pMemorySSM->CurrentOffset = offStream + cbToRead;
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemorySeek(void *pvUser, int64_t offSeek, unsigned uMethod, uint64_t *poffActual)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    if(uMethod == RTFILE_SEEK_BEGIN){
+        pMemorySSM->CurrentOffset = offSeek;
+    }
+    if(uMethod == RTFILE_SEEK_END){
+        pMemorySSM->CurrentOffset = pMemorySSM->cbMemory-offSeek;
+    }
+    if(uMethod == RTFILE_SEEK_CURRENT){
+        pMemorySSM->CurrentOffset += offSeek;
+    }
+    *poffActual = pMemorySSM->CurrentOffset;
+    if(*poffActual > pMemorySSM->MaxOffset){
+        pMemorySSM->MaxOffset = *poffActual;
+    }
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(uint64_t) pfnMemoryTell(void *pvUser)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    return pMemorySSM->CurrentOffset;
+}
+
+static DECLCALLBACK(int) pfnMemorySize(void *pvUser, uint64_t *pcb)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    *pcb = pMemorySSM->MaxOffset;
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryIsOk(void *pvUser){
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryClose(void *pvUser, bool fCancelled)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    pMemorySSM->CurrentOffset = 0;
+    pMemorySSM->MaxOffset = 0;
+    return VINF_SUCCESS;
+}
+
+static SSMSTRMOPS const g_ftmR3MemoryOps =
+{
+    SSMSTRMOPS_VERSION,
+    pfnMemoryWrite,
+    pfnMemoryRead,
+    pfnMemorySeek,
+    pfnMemoryTell,
+    pfnMemorySize,
+    pfnMemoryIsOk,
+    pfnMemoryClose,
+    SSMSTRMOPS_VERSION
+};
+
+
+// VMMR3_INT_DECL(int) VMR3SaveFT(PUVM pUVM, PCSSMSTRMOPS pStreamOps, void *pvStreamOpsUser, bool *pfSuspended, bool fSkipStateChanges)
+// {
+//     LogFlow(("VMR3SaveFT: pUVM=%p pStreamOps=%p pvSteamOpsUser=%p pfSuspended=%p\n",
+//              pUVM, pStreamOps, pvStreamOpsUser, pfSuspended));
+
+//     /*
+//      * Validate input.
+//      */
+//     AssertPtr(pfSuspended);
+//     *pfSuspended = false;
+//     UVM_ASSERT_VALID_EXT_RETURN(pUVM, VERR_INVALID_VM_HANDLE);
+//     PVM pVM = pUVM->pVM;
+//     VM_ASSERT_VALID_EXT_RETURN(pVM, VERR_INVALID_VM_HANDLE);
+//     AssertReturn(pStreamOps, VERR_INVALID_PARAMETER);
+
+//     /*
+//      * Join paths with VMR3Teleport.
+//      */
+//     /// TODO
+//     // int rc = vmR3SaveTeleport(pVM, 250 /*cMsMaxDowntime*/,
+//     //                           NULL, pStreamOps, pvStreamOpsUser,
+//     //                           SSMAFTER_CONTINUE, NULL, NULL, pfSuspended,
+//     //                           fSkipStateChanges);
+//     LogFlow(("VMR3SaveFT: returns %Rrc (*pfSuspended=%RTbool)\n", rc, *pfSuspended));
+//     return rc;
+// }
+
+bool FDPVBOX_Save(void *pUserHandle)
+{
+    Log1("SAVE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
 
+    //Avoid Interrupt during save, we don't want Interrupt in our save state
+    pVCpu->mystate.s.bDisableInterrupt = true;
+
+    //Ask all CPU to suspend
+    printf("Save.FDPVBOX_Pause\n");
+    FDPVBOX_Pause(pUserHandle);
+
+    printf("Save.UsetBreakpoint\n");
+    for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+        FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+    }
+    //Disable Hardware breakpoint
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR0_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR1_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR2_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR3_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR6_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR7_REGISTER, 0);
+
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR0_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[0]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR1_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[1]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR2_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[2]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR3_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[3]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR6_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[6]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR7_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[7]);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bSuspendRequired = true;
+    }
+
+    //Resume all CPU for suspend
+    printf("Save.FDPVBOX_Resume\n");
+    FDPVBOX_Resume(pUserHandle);
+
+    //Suspend all CPU
+    printf("Save.VMR3Suspend\n");
+    VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu2 = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu2->mystate.s.bSuspendRequired = false;
+    }
+
+    //Alloc SaveState memory
+    if(myVBOXHandle->pMemorySSM->pMemory == NULL){
+        myVBOXHandle->pMemorySSM->cbMemory = MMR3PhysGetRamSizeU(pUVM);
+        myVBOXHandle->pMemorySSM->pMemory = (uint8_t*)malloc(myVBOXHandle->pMemorySSM->cbMemory);
+    }
+
+    //Set offset
+    myVBOXHandle->pMemorySSM->CurrentOffset = 0;
+    myVBOXHandle->pMemorySSM->MaxOffset = 0;
+
+    //Save state
+    printf("Save.VMR3SaveFT\n");
+    bool bSuspended = false;
+    // FDPTODO
+    // VMR3SaveFT(pUVM, &g_ftmR3MemoryOps, (void*)myVBOXHandle->pMemorySSM, &bSuspended, true);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bRestoreRequired = true;
+    }
+
+    printf("Save.VMR3Resume\n");
+    VMR3Resume(pUVM, VMRESUMEREASON_STATE_RESTORED);
+
+    printf("Save.FDPVBOX_Pause\n");
+    FDPVBOX_Pause(pUserHandle);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bRestoreRequired = false;
+    }
+
+    pVCpu->mystate.s.bDisableInterrupt = false;
+
+    return true;
+}
+
+bool FDPVBOX_Restore(void *pUserHandle)
+{
+    Log1("RESTORE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+    int rc;
+    if(myVBOXHandle->pMemorySSM->pMemory != NULL){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+        //Avoid Interrupt during save, we don't want Interrupt in our save state
+        pVCpu->mystate.s.bDisableInterrupt = true;
+
+        printf("Restore.Pause\n");
+        FDPVBOX_Pause(pUserHandle);
+
+        printf("Restore.UsetBreakpoint\n");
+        for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+            FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+        }
+        //Disable Hardware breakpoint
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR0_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR1_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR2_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR3_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR6_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR7_REGISTER, 0);
+
+        printf("Restore.FDPVBOX_Resume\n");
+        //Force console client to reconnect
+        FDPVBOX_Resume(pUserHandle);
+
+        printf("Restore.VMR3Reset\n");
+        VMR3Reset(pUVM);
+
+        usleep(500 * 1000);
+
+        printf("Restore.VMR3Suspend\n");
+        rc = VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+
+
+        //rc = VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+        //printf("%d\n", rc);
+
+        printf("Restore.VMR3LoadFromStream\n");
+        VMR3LoadFromStream(pUVM, &g_ftmR3MemoryOps, (void*)myVBOXHandle->pMemorySSM, nullProgressCallback, NULL);
+
+        printf("Restore.VMR3Resume\n");
+        pVCpu->mystate.s.bRestoreRequired = true;
+        VMR3Resume(pUVM, VMRESUMEREASON_STATE_RESTORED);
+
+        printf("Restore.FDPVBOX_Pause\n");
+        FDPVBOX_Pause(pUserHandle);
+        pVCpu->mystate.s.bRestoreRequired = false;
+
+        //Restore visible for Guest Debug Register
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR0_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[0]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR1_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[1]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR2_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[2]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR3_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[3]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR6_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[6]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR7_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[7]);
+
+        pVCpu->mystate.s.bDisableInterrupt = false;
+
+        //printf("%d\n", VMR3ClearInterrupt(pUVM, NULL));
+
+        printf("Restore.Done!\n");
+        return true;
+    }
+
+    return false;
+}
+
+void *CreateCPUSHM(PUVM pUVM)
+{
+    int hMapFile;
+    void* pBuf;
+
+    char aCpuShmName[512] = {0};
+    strcpy(aCpuShmName,"CPU_");
+    strcat(aCpuShmName, VMR3GetName(pUVM));
+
+    pBuf = CreateSHM(aCpuShmName, sizeof(FDP_CPU_CTX));
+    if (pBuf == NULL) {
+        return NULL;
+    }
+    //Clear SHM
+    memset((void*)pBuf, 0, sizeof(FDP_CPU_CTX));
+
+    printf("0x%p\n", sizeof(FDP_CPU_CTX));
+
+    return pBuf;
+}
+
+void* FDPServerThread(LPVOID lpParam)
+{
+    PUVM pUVM = (PUVM)lpParam;
+    MEMORY_SSM_T MemorySSM;
+    MemorySSM.pMemory = NULL;
+    MemorySSM.CurrentOffset = 0;
+
+    FDP_SHM* pFDPServer = FDP_CreateSHM((char*)VMR3GetName(pUVM));
+    if(pFDPServer == NULL){
+        printf("FDP SHM creation failed !\n");
+        return NULL;
+    }
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+    //PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    void* pCpuShm = CreateCPUSHM(pUVM);
+    pVCpu->mystate.s.pCpuShm = pCpuShm;
+    if(pCpuShm == NULL){
+        printf("Failed to CreateCpuShm\n");
+        return NULL;
+    }
+
+    printf("FDP_CreateSHM OK\n");
+    FDPVBOX_USERHANDLE_T *pUserHandle = (FDPVBOX_USERHANDLE_T*)malloc(sizeof(FDPVBOX_USERHANDLE_T));
+    pUserHandle->pUVM = pUVM;
+    pUserHandle->pMemorySSM = &MemorySSM;
+    pUserHandle->pFDPServer = pFDPServer;
+
+    //Configure FDP Server Interface
+    FDP_SERVER_INTERFACE_T FDPServerInterface;
+    FDPServerInterface.pUserHandle = pUserHandle;
+
+    FDPServerInterface.pfnGetState = &FDPVBOX_getState;
+    FDPServerInterface.pfnReadRegister = &FDPVBOX_readRegister;
+    FDPServerInterface.pfnWriteRegister =  &FDPVBOX_writeRegister;
+    FDPServerInterface.pfnWritePhysicalMemory = &FDPVBOX_writePhysicalMemory;
+    FDPServerInterface.pfnWriteVirtualMemory = &FDPVBOX_writeVirtualMemory;
+    FDPServerInterface.pfnGetMemorySize = &FDPVBOX_getMemorySize;
+    FDPServerInterface.pfnResume =  &FDPVBOX_Resume;
+    FDPServerInterface.pfnSingleStep =  &FDPVBOX_singleStep;
+    FDPServerInterface.pfnPause =  &FDPVBOX_Pause;
+    FDPServerInterface.pfnReadMsr =  &FDPVBOX_readMsr;
+    FDPServerInterface.pfnWriteMsr =  &FDPVBOX_writeMsr;
+    FDPServerInterface.pfnGetCpuCount =  &FDPVBOX_getCpuCount;
+    FDPServerInterface.pfnGetCpuState = &FDPVBOX_getCpuState;
+    FDPServerInterface.pfnVirtualToPhysical = &FDPVBOX_virtualToPhysical;
+    FDPServerInterface.pfnUnsetBreakpoint = &FDPVBOX_unsetBreakpoint;
+    FDPServerInterface.pfnGetFxState64 = &FDPVBOX_getFxState64;
+    FDPServerInterface.pfnSetFxState64 = &FDPVBOX_setFxState64;
+    FDPServerInterface.pfnReadVirtualMemory = &FDPVBOX_readVirtualMemory;
+    FDPServerInterface.pfnReadPhysicalMemory = &FDPVBOX_readPhysicalMemory;
+    FDPServerInterface.pfnSetBreakpoint = &FDPVBOX_setBreakpoint;
+    FDPServerInterface.pfnReadPhysicalMemory = &FDPVBOX_readPhysicalMemory;
+    FDPServerInterface.pfnSave = &FDPVBOX_Save;
+    FDPServerInterface.pfnRestore = &FDPVBOX_Restore;
+    FDPServerInterface.pfnReboot = &FDPVBOX_Reboot;
+    FDPServerInterface.pfnInjectInterrupt = &FDPVBOX_InjectInterrupt;
+
+    if (FDP_SetFDPServer(pFDPServer, &FDPServerInterface) == false){
+        printf("Failed to FDP_SerFDPServer\n");
+        return NULL;
+    }
+
+    printf("FDP_SetFDPServer OK\n");
+
+    VMR3SetFDPShm(pUVM, pFDPServer);
+
+    printf("VMR3SetFDPShm OK\n");
+
+    if (FDP_ServerLoop(pFDPServer) == false){
+        printf("Failed to FDP_ServerLoop\n");
+        return NULL;
+    }
+
+    if(pUserHandle != NULL){
+        free(pUserHandle);
+    }
+
+    return NULL;
+}
+/*ENDMYCODE*/
 
 /**
  * Checks if there is input.
@@ -215,6 +1154,10 @@ static DECLCALLBACK(int) dbgcTcpConnection(RTSOCKET Sock, void *pvUser)
  */
 DBGDECL(int)    DBGCTcpCreate(PUVM pUVM, void **ppvData)
 {
+    /*MYCODE*/
+    pthread_t t;
+    pthread_create(&t, NULL, FDPServerThread, pUVM);
+    /*ENDMYCODE*/
     /*
      * Check what the configuration says.
      */
diff --git a/src/VBox/Debugger/Makefile.kmk b/src/VBox/Debugger/Makefile.kmk
index af27bc38..5ec70cea 100644
--- a/src/VBox/Debugger/Makefile.kmk
+++ b/src/VBox/Debugger/Makefile.kmk
@@ -33,7 +33,7 @@ endif # VBOX_WITH_DEBUGGER
 # Debugger library - linked into VBoxVMM.
 #
 Debugger_TEMPLATE  = VBOXR3
-Debugger_DEFS      = IN_VMM_R3 IN_DBG_R3 IN_DIS
+Debugger_DEFS      = IN_VMM_R3 IN_DBG_R3 IN_DIS USING_VMM_COMMON_DEFS
 ifneq ($(KBUILD_TYPE),release)
  Debugger_DEFS    += VBOX_WITH_DEBUGGER_TCP_BY_DEFAULT
 endif
diff --git a/src/VBox/Devices/Audio/DevHDACommon.cpp b/src/VBox/Devices/Audio/DevHDACommon.cpp
index 51030908..b7ce77d8 100644
--- a/src/VBox/Devices/Audio/DevHDACommon.cpp
+++ b/src/VBox/Devices/Audio/DevHDACommon.cpp
@@ -185,9 +185,9 @@ bool hdaR3WalClkSet(PHDASTATE pThis, PHDASTATER3 pThisCC, uint64_t u64WalClk, bo
 
     const uint64_t u64WalClkNew = hdaWalClkGetCurrent(pThis);
 
-    Log3Func(("Cur: %RU64, New: %RU64 (force %RTbool) -> %RU64 %s\n",
+    /*Log3Func(("Cur: %RU64, New: %RU64 (force %RTbool) -> %RU64 %s\n",
               u64WalClkCur, u64WalClk, fForce,
-              u64WalClkNew, u64WalClkNew == u64WalClk ? "[OK]" : "[DELAYED]"));
+              u64WalClkNew, u64WalClkNew == u64WalClk ? "[OK]" : "[DELAYED]"));*/
 
     return (u64WalClkNew == u64WalClk);
 }
diff --git a/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp b/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
index 64a6cdb5..ad7a007c 100644
--- a/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
+++ b/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
@@ -1032,10 +1032,10 @@ static int lsilogicR3ProcessMessageRequest(PPDMDEVINS pDevIns, PLSILOGICSCSI pTh
     bool fForceReplyPostFifo = false;
 
 # ifdef LOG_ENABLED
-    if (pMessageHdr->u8Function < RT_ELEMENTS(g_apszMPTFunctionNames))
+/*    if (pMessageHdr->u8Function < RT_ELEMENTS(g_apszMPTFunctionNames))
         Log(("Message request function: %s\n", g_apszMPTFunctionNames[pMessageHdr->u8Function]));
     else
-        Log(("Message request function: <unknown>\n"));
+        Log(("Message request function: <unknown>\n"));*/
 # endif
 
     memset(pReply, 0, sizeof(MptReplyUnion));
diff --git a/src/VBox/Runtime/common/string/memcpy.asm b/src/VBox/Runtime/common/string/memcpy.asm
index a53fa159..60953254 100644
--- a/src/VBox/Runtime/common/string/memcpy.asm
+++ b/src/VBox/Runtime/common/string/memcpy.asm
@@ -33,7 +33,6 @@ BEGINCODE
 ; @param    pvSrc   gcc: rsi  msc: rdx  x86:[esp+8]   wcall: edx
 ; @param    cb      gcc: rdx  msc: r8   x86:[esp+0ch] wcall: ebx
 %ifdef IN_RING0_DRV_ON_DARWIN
-global NAME(memcpy):private_extern
 NAME(memcpy):
 %else
 RT_NOCRT_BEGINPROC memcpy
diff --git a/src/VBox/VMM/VMMAll/HMAll.cpp b/src/VBox/VMM/VMMAll/HMAll.cpp
index 5ad8c343..a2d8a9ba 100644
--- a/src/VBox/VMM/VMMAll/HMAll.cpp
+++ b/src/VBox/VMM/VMMAll/HMAll.cpp
@@ -512,6 +512,26 @@ static void hmPokeCpuForTlbFlush(PVMCPU pVCpu, bool fAccountFlushStat)
         STAM_COUNTER_INC(&pVCpu->hm.s.StatFlushPageManual);
 }
 
+/*MYCODE*/
+//Ensure that all CPU are paused !
+# include <VBox/vmm/uvm.h>
+VMM_INT_DECL(int) HMFlushTLBOnAllVCpus2(PVMCPUCC pVCpu)
+{
+#ifndef IN_RING0
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+
+    // FDPTODO
+    PGVM pGVM = (PGVM)pVM;
+    for (VMCPUID idCpu = 0; idCpu < pVM->pUVM->cCpus; idCpu++){
+        PVMCPU pVCpu = pVM->pUVM->aCpus[idCpu].pVCpu;
+        HMFlushTlb(pVCpu);
+        VMCPU_FF_SET(pVCpu, VMCPU_FF_TLB_FLUSH);
+        hmPokeCpuForTlbFlush(pVCpu, true /* fAccountFlushStat */);
+    }
+#endif
+    return VINF_SUCCESS;
+}
+/*ENDMYCODE*/
 
 /**
  * Invalidates a guest page on all VCPUs.
diff --git a/src/VBox/VMM/VMMAll/PGMAll.cpp b/src/VBox/VMM/VMMAll/PGMAll.cpp
index 6a06bb55..79973ab6 100644
--- a/src/VBox/VMM/VMMAll/PGMAll.cpp
+++ b/src/VBox/VMM/VMMAll/PGMAll.cpp
@@ -1795,6 +1795,270 @@ static int pgmShwGetEPTPDPtr(PVMCPUCC pVCpu, RTGCPTR64 GCPtr, PEPTPDPT *ppPdpt,
     return VINF_SUCCESS;
 }
 
+/*MYCODE*/
+VMMDECL(int) PGMShwGetHCPage(PVMCPUCC pVCpu, uint64_t GCPhys, uint64_t *HCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1)
+    { //2M
+        uint64_t test = *((uint64_t*)&Pde->b);
+        *HCPhys = (test & 0xFFFFFFFFFFE00000);
+    }else
+    { //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc))
+        {
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = (EPTPTE*)&pPT->a[iPt];
+
+            uint64_t test = *((uint64_t*)&Pte->n);
+            *HCPhys = (test & 0xFFFFFFFFFFFFF000);
+        }
+    }
+    pgmUnlock(pVM);
+    return rc;
+}
+
+void logRelPDE(EPTPDE *Pde)
+{
+    LogRel(("Pde->b.u1Present %p\n", Pde->b.u1Present));
+    LogRel(("Pde->b.u1Write %p\n", Pde->b.u1Write));
+    LogRel(("Pde->b.u1Execute %p\n", Pde->b.u1Execute));
+    LogRel(("Pde->b.u3EMT %p\n", Pde->b.u3EMT));
+    LogRel(("Pde->b.u1IgnorePAT %p\n", Pde->b.u1IgnorePAT));
+    LogRel(("Pde->b.u1Size %p\n", Pde->b.u1Size));
+    LogRel(("Pde->b.u4Available %p\n", Pde->b.u4Available));
+    LogRel(("Pde->b.u9Reserved %p\n", Pde->b.u9Reserved));
+    LogRel(("Pde->b.u31PhysAddr %p\n", Pde->b.u31PhysAddr));
+    LogRel(("Pde->b.u12Available %p\n", Pde->b.u12Available));
+}
+
+void logRelPTE(EPTPTE *Pte)
+{
+    LogRel(("------------------------------------\n"));
+    LogRel(("Pte->n.u1Present %p\n", Pte->n.u1Present));
+    LogRel(("Pte->n.u1Write %p\n", Pte->n.u1Write));
+    LogRel(("Pte->n.u1Execute %p\n", Pte->n.u1Execute));
+    LogRel(("------------------------------------\n"));
+}
+
+VMMDECL(int) PGMShwSetHCPage(PVMCPUCC pVCpu, uint64_t GCPhys, uint64_t HCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        Pde->au64[0] = (Pde->au64[0] & 0x1FFFFF) | (HCPhys & 0xFFFFFFFFFFE00000);
+    }else{ //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = (EPTPTE*)&pPT->a[iPt];
+
+            Pte->au64[0] = (Pte->au64[0] & 0xFFF) | (HCPhys & 0xFFFFFFFFFFFFF000);
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+VMMDECL(int) PGMShwChangeFlags(PVMCPUCC pVCpu, uint64_t GCPhys, uint8_t orPresent, uint8_t andPresent, uint8_t orWrite, uint8_t andWrite, uint8_t orExecute, uint8_t andExecute)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        Pde->b.u1Present = (Pde->b.u1Present | orPresent) & andPresent;
+        Pde->b.u1Write = (Pde->b.u1Write | orWrite) & andWrite;
+        Pde->b.u1Execute = (Pde->b.u1Execute | orExecute) & andExecute;
+    }else{ //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = (EPTPTE*)&pPT->a[iPt];
+
+            Pte->n.u1Present = (Pte->n.u1Present | orPresent) & andPresent;
+            Pte->n.u1Write = (Pte->n.u1Write | orWrite) & andWrite;
+            Pte->n.u1Execute = (Pte->n.u1Execute | orExecute) & andExecute;
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+#define MEMORY_SIZE 0x80000000
+
+VMMDECL(int) PGMShwSaveRights(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int returnFlags = 0;
+    PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    int rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        //TODO !!!!
+    }else{    //4K
+        PSHWPT pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *pPte = (EPTPTE*)&pPT->a[iPt];
+
+            uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+            PfnEntrie_t* pTmpPfnEntrie;
+#ifdef IN_RING0
+            pTmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+            pTmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+            pTmpPfnEntrie[PfnIndex].u.u1Present = pPte->n.u1Present;
+            pTmpPfnEntrie[PfnIndex].u.u1Write  = pPte->n.u1Write;
+            pTmpPfnEntrie[PfnIndex].u.u1Execute  = pPte->n.u1Execute;
+
+            //logRelPTE(Pte);
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+VMMDECL(int) PGMShwRestoreRights(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    if(GCPhys < MEMORY_SIZE)
+    {
+        PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        PGMShwChangeFlags(pVCpu, GCPhys,
+            tmpPfnEntrie[PfnIndex].u.u1Present,tmpPfnEntrie[PfnIndex].u.u1Present,
+            tmpPfnEntrie[PfnIndex].u.u1Write, tmpPfnEntrie[PfnIndex].u.u1Write,
+            tmpPfnEntrie[PfnIndex].u.u1Execute, tmpPfnEntrie[PfnIndex].u.u1Execute);
+    }
+
+    return VINF_SUCCESS;
+}
+
+VMMDECL(int) PGMShwSetBreakable(PVMCPUCC pVCpu, uint64_t GCPhys, bool Breakable)
+{
+    if(GCPhys < MEMORY_SIZE){
+        PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        tmpPfnEntrie[PfnIndex].u.u1Breakable = Breakable;
+        //LogRel(("PGMShwSetBreakable %p PfnTable[%d].u1Breakable %s\n", GCPhys, PfnIndex, Breakable ? "true" : "false"));
+    }
+    return VINF_SUCCESS;
+}
+
+
+VMMDECL(bool) PGMShwIsBreakable(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    PVMCC pVM = pVCpu->CTX_SUFF(pVM);
+    if(GCPhys < MEMORY_SIZE){
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        //LogRel(("PGMShwIsBreakable %p PfnTable[%d].u1Breakable %s\n", GCPhys, PfnIndex, tmpPfnEntrie[PfnIndex].u.u1Breakable ? "true" : "false"));
+        return tmpPfnEntrie[PfnIndex].u.u1Breakable;
+    }
+    return false;
+}
+
+VMMDECL(int) PGMShwNoPresent(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 0, 0, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwPresent(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 1, 1, 0, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwNoWrite(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 0, 0, 1);
+}
+
+VMMDECL(int) PGMShwWrite(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 1, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwNoExecute(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 1, 0, 0);
+}
+
+VMMDECL(int) PGMShwExecute(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 1, 1, 1);
+}
+
+VMMDECL(int) PGMShwInvalidate(PVMCPUCC pVCpu, uint64_t GCPhys)
+{
+#ifndef IN_RING0
+    HMFlushTLBOnAllVCpus2(pVCpu);
+#endif
+    return VINF_SUCCESS;
+}
+/*ENDMYCODE*/
+
 
 #ifdef IN_RING0
 /**
diff --git a/src/VBox/VMM/VMMAll/VMMAll.cpp b/src/VBox/VMM/VMMAll/VMMAll.cpp
index e827e84f..bfa17505 100644
--- a/src/VBox/VMM/VMMAll/VMMAll.cpp
+++ b/src/VBox/VMM/VMMAll/VMMAll.cpp
@@ -368,3 +368,48 @@ uint32_t vmmGetBuildType(void)
     return uRet;
 }
 
+/*MYCODE*/
+VMM_INT_DECL(bool) VMMMatchBreakpointId(PVM pVM, int BreakpointId, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess)
+{
+    if(BreakpointId >= 0
+    || BreakpointId < MAX_BREAKPOINT_ID){
+        BreakpointEntrie_t *TempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(TempBreakpointEntrie->breakpointActivated
+        && TempBreakpointEntrie->breakpointType == BreakpointType
+        && (TempBreakpointEntrie->breakpointAccessType & BreakpointAccess)){
+            for(int j=0; j<TempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                if(GCPhys >= TempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start
+                && GCPhys < TempBreakpointEntrie->breakpointGCPhysAreaTable[j].End){
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+VMM_INT_DECL(int) VMMGetBreakpointId(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess)
+{
+    for(int i=0; i<MAX_BREAKPOINT_ID; i++){
+        if(VMMMatchBreakpointId(pVM, i, GCPhys, BreakpointType, BreakpointAccess))
+            return i;
+    }
+    return -1;
+}
+
+VMM_INT_DECL(int) VMMGetBreakpointIdFromPage(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType)
+{
+    GCPhys = GCPhys & ~(_4K-1);
+    for(int i=0; i<MAX_BREAKPOINT_ID; i++){
+        if(pVM->bp.l[i].breakpointActivated
+        && pVM->bp.l[i].breakpointType == BreakpointType){
+            for(int j=0; j<pVM->bp.l[i].breakpointGCPhysAreaCount; j++){
+                if((GCPhys & ~(_4K-1)) == (pVM->bp.l[i].breakpointGCPhysAreaTable[j].Start & ~(_4K-1))){
+                    return i;
+                }
+            }
+        }
+    }
+    return -1;
+}
+/*ENDMYCODE*/
\ No newline at end of file
diff --git a/src/VBox/VMM/VMMR0/GVMMR0.cpp b/src/VBox/VMM/VMMR0/GVMMR0.cpp
index 2de316d5..0b13893f 100644
--- a/src/VBox/VMM/VMMR0/GVMMR0.cpp
+++ b/src/VBox/VMM/VMMR0/GVMMR0.cpp
@@ -909,6 +909,23 @@ GVMMR0DECL(int) GVMMR0CreateVM(PSUPDRVSESSION pSession, uint32_t cCpus, PGVM *pp
                         IOMR0InitPerVMData(pGVM);
                         if (RT_SUCCESS(rc) && RT_SUCCESS(rc2))
                         {
+                            /*MYCODE*/
+                            RTR0MEMOBJ PfnTableMemObj;
+                            rc = RTR0MemObjAllocPage(&PfnTableMemObj, sizeof(PfnEntrie_t)*512*1024, false /* fExecutable */);
+                            if (RT_SUCCESS(rc)){
+                                pGVM->mystate.s.pPfnTableR0 = (PfnEntrie_t*)RTR0MemObjAddress(PfnTableMemObj);
+                                RTR0MEMOBJ PfnTableMapObj;
+                                rc = RTR0MemObjMapUser(&PfnTableMapObj, PfnTableMemObj, (RTR3PTR)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE, NIL_RTR0PROCESS);
+                                if (RT_SUCCESS(rc)) {
+                                    pGVM->mystate.s.pPfnTableR3 = (PfnEntrie_t*)RTR0MemObjAddressR3(PfnTableMapObj);
+                                }else{
+                                    return -1;
+                                }
+                            }else{
+                                return -1;
+                            }
+                            /*ENDMYCODE*/
+
                             /*
                              * Allocate page array.
                              * This currently have to be made available to ring-3, but this is should change eventually.
diff --git a/src/VBox/VMM/VMMR0/HMVMXR0.cpp b/src/VBox/VMM/VMMR0/HMVMXR0.cpp
index 7120e3b7..3d3243d2 100644
--- a/src/VBox/VMM/VMMR0/HMVMXR0.cpp
+++ b/src/VBox/VMM/VMMR0/HMVMXR0.cpp
@@ -41,6 +41,43 @@
 #include "HMVMXR0.h"
 #include "dtrace/VBoxVMM.h"
 
+/*MYCODE*/
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+#include <iprt/spinlock.h>
+
+//TODO: Move this in VMMALL as there is a copy in VMMR3
+void UpdateFdpCpuCtx(PVMCPU pVCpu)
+{
+    return; //TODO
+
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    FDP_CPU_CTX* pFdpCpuCtx = (FDP_CPU_CTX *)pVCpu->mystate.s.pCpuShm;
+
+    pFdpCpuCtx->rip = pCtxCore->rip;
+    pFdpCpuCtx->rax = pCtxCore->rax;
+    pFdpCpuCtx->rcx = pCtxCore->rcx;
+    pFdpCpuCtx->rdx = pCtxCore->rdx;
+    pFdpCpuCtx->rbx = pCtxCore->rbx;
+    pFdpCpuCtx->rsp = pCtxCore->rsp;
+    pFdpCpuCtx->rbp = pCtxCore->rbp;
+    pFdpCpuCtx->rsi = pCtxCore->rsi;
+    pFdpCpuCtx->rdi = pCtxCore->rdi;
+    pFdpCpuCtx->r8 = pCtxCore->r8;
+    pFdpCpuCtx->r9 = pCtxCore->r9;
+    pFdpCpuCtx->r10 = pCtxCore->r10;
+    pFdpCpuCtx->r11 = pCtxCore->r11;
+    pFdpCpuCtx->r12 = pCtxCore->r12;
+    pFdpCpuCtx->r13 = pCtxCore->r13;
+    pFdpCpuCtx->r14 = pCtxCore->r14;
+    pFdpCpuCtx->r15 = pCtxCore->r15;
+    pFdpCpuCtx->cr0 = CPUMGetGuestCR0(pVCpu);
+    pFdpCpuCtx->cr2 = CPUMGetGuestCR2(pVCpu);
+    pFdpCpuCtx->cr3 = CPUMGetGuestCR3(pVCpu);
+    pFdpCpuCtx->cr4 = CPUMGetGuestCR4(pVCpu);
+}
+/*ENDMYCODE*/
+
 #ifdef DEBUG_ramshankar
 # define HMVMX_ALWAYS_SAVE_GUEST_RFLAGS
 # define HMVMX_ALWAYS_SAVE_RO_GUEST_STATE
@@ -54,6 +91,10 @@
 # define HMVMX_ALWAYS_SWAP_EFER
 #endif
 
+/*MYCODE*/
+#define HMVMX_ALWAYS_TRAP_ALL_XCPTS
+/*ENDMYCODE*/
+
 
 /*********************************************************************************************************************************
 *   Defined Constants And Macros                                                                                                 *
@@ -1969,6 +2010,11 @@ static void hmR0VmxStructsFree(PVMCC pVM)
  */
 static int hmR0VmxStructsAlloc(PVMCC pVM)
 {
+    /*MYCODE*/
+    pVM->mystate.s.PageSpinlock = NIL_RTSPINLOCK;
+    RTSpinlockCreate(&pVM->mystate.s.PageSpinlock, RTSPINLOCK_FLAGS_INTERRUPT_SAFE, pVM->mystate.s.PageSpinLockName);
+    /*ENDMYCODE*/
+
     /*
      * Sanity check the VMCS size reported by the CPU as we assume 4KB allocations.
      * The VMCS size cannot be more than 4096 bytes.
@@ -5940,8 +5986,10 @@ static int hmR0VmxExportSharedDebugState(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTrans
     if (pVmcsInfo->u32EntryCtls & VMX_ENTRY_CTLS_LOAD_DEBUG)
     {
         /* Validate. Intel spec. 17.2 "Debug Registers", recompiler paranoia checks. */
-        Assert((pVCpu->cpum.GstCtx.dr[7] & (X86_DR7_MBZ_MASK | X86_DR7_RAZ_MASK)) == 0);
-        Assert((pVCpu->cpum.GstCtx.dr[7] & X86_DR7_RA1_MASK) == X86_DR7_RA1_MASK);
+        /*MYCODE*/
+        // Assert((pVCpu->cpum.GstCtx.dr[7] & (X86_DR7_MBZ_MASK | X86_DR7_RAZ_MASK)) == 0);
+        // Assert((pVCpu->cpum.GstCtx.dr[7] & X86_DR7_RA1_MASK) == X86_DR7_RA1_MASK);
+        /*ENDMYCODE*/
     }
 #endif
 
@@ -6023,11 +6071,25 @@ static int hmR0VmxExportSharedDebugState(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTrans
         pVCpu->hm.s.fUsingHyperDR7 = false;
     }
 
+    /*MYCODE*/
+    //Always intercept MovDRx
+    fInterceptMovDRx = true;
+    /*ENDMYCODE*/
+
     if (fInterceptMovDRx)
         uProcCtls |= VMX_PROC_CTLS_MOV_DR_EXIT;
     else
         uProcCtls &= ~VMX_PROC_CTLS_MOV_DR_EXIT;
 
+    /*MYCODE*/
+    //Always Intercept MovDrx
+    uProcCtls |= VMX_PROC_CTLS_MOV_DR_EXIT;
+    uProcCtls |= VMX_PROC_CTLS_CR3_LOAD_EXIT;
+    uProcCtls |= VMX_PROC_CTLS_CR3_STORE_EXIT;
+    uProcCtls |= VMX_PROC_CTLS_CR8_LOAD_EXIT;
+    uProcCtls |= VMX_PROC_CTLS_CR8_STORE_EXIT;
+    /*ENDCODE*/
+
     /*
      * Update the processor-based VM-execution controls with the MOV-DRx intercepts and the
      * monitor-trap flag and update our cache.
@@ -11106,6 +11168,10 @@ static void hmR0VmxPostRunGuest(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient, int
             rc = hmR0VmxImportGuestState(pVCpu, pVmcsInfo, fImportMask);
             AssertRC(rc);
 
+            /*MYCODE*/
+            UpdateFdpCpuCtx(pVCpu);
+            /*ENDMYCODE*/
+
             /*
              * Sync the TPR shadow with our APIC state.
              */
@@ -12450,6 +12516,12 @@ static VBOXSTRICTRC hmR0VmxRunGuestCodeDebug(PVMCPUCC pVCpu, uint32_t *pcLoops)
         STAM_PROFILE_ADV_START(&pVCpu->hm.s.StatEntry, x);
         bool fStepping = pVCpu->hm.s.fSingleInstruction;
 
+        /*MYCODE*/
+        if (pVCpu->mystate.s.bPauseRequired){
+            break;
+        }
+        /*ENDMYCODE*/
+
         /* Set up VM-execution controls the next two can respond to. */
         hmR0VmxPreRunGuestDebugStateApply(pVCpu, &VmxTransient, &DbgState);
 
@@ -13935,6 +14007,59 @@ static VBOXSTRICTRC hmR0VmxExitXcptBP(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransien
     int rc = hmR0VmxImportGuestState(pVCpu, pVmxTransient->pVmcsInfo, HMVMX_CPUMCTX_EXTRN_ALL);
     AssertRCReturn(rc, rc);
 
+    /*MYCODE*/
+    {
+
+        PCPUMCTX pMixedCtx = &pVCpu->cpum.GstCtx;
+        hmR0VmxReadExitIntInfoVmcs(pVmxTransient);
+        hmR0VmxReadExitIntErrorCodeVmcs(pVmxTransient);
+        hmR0VmxReadExitInstrLenVmcs(pVmxTransient);
+        PVM pVM = pVCpu->CTX_SUFF(pVM);
+        uint64_t GCPhys;
+        PGMPhysGCPtr2GCPhys(pVCpu, pMixedCtx->rip, &GCPhys);
+        int SoftBreakpointId = VMMGetBreakpointId(pVM, GCPhys, FDP_SOFTHBP, FDP_EXECUTE_BP);
+        if(SoftBreakpointId >= 0){
+            if(pVM->bp.l[SoftBreakpointId].breakpointCr3 == 0
+            || pVM->bp.l[SoftBreakpointId].breakpointCr3 == CPUMGetGuestCR3(pVCpu)){
+                pVCpu->mystate.s.bSoftHyperBreakPointHitted = true;
+                return VINF_EM_HALT;
+            }else{
+                //This breakpoint is filtered
+                //Full rights on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys);
+                //Invalidate the GPA
+                //VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+                hmR0VmxFlushEpt(pVCpu, pVmxTransient->pVmcsInfo, pVM->hm.s.vmx.enmTlbFlushEpt);
+
+                //Enable MTF
+                pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls |= VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+                VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+                //Single Step
+                uint32_t     cLoops = 0;
+                hmR0VmxRunGuestCodeNormal(pVCpu, &cLoops);
+                hmR0VmxReadExitQualVmcs(pVmxTransient);
+                //hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+                hmR0VmxImportGuestState(pVCpu, pVmxTransient->pVmcsInfo, CPUMCTX_EXTRN_SREG_MASK | CPUMCTX_EXTRN_DR7);
+                //hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+
+                //Disable MTF
+                pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls &= ~VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+                return VINF_SUCCESS;
+            }
+        }
+    }
+    /*ENDMYCODE*/
+
     if (!pVmxTransient->fIsNestedGuest)
         rc = DBGFRZTrap03Handler(pVCpu->CTX_SUFF(pVM), pVCpu, CPUMCTX2CORE(&pVCpu->cpum.GstCtx));
     else
@@ -13989,6 +14114,29 @@ static VBOXSTRICTRC hmR0VmxExitXcptDB(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransien
                         | (pVmxTransient->uExitQual & (  X86_DR6_B0 | X86_DR6_B1 | X86_DR6_B2 | X86_DR6_B3
                                                        | X86_DR6_BD | X86_DR6_BS));
 
+    /*MYCODE*/
+    {
+        PCPUMCTX pMixedCtx = &pVCpu->cpum.GstCtx;
+        //If it is a breakpoint we handle it
+        if((uDR6 & (X86_DR6_B0 | X86_DR6_B1 | X86_DR6_B2 | X86_DR6_B3))){
+            //Update DR6 !
+            VMMRZCallRing3Disable(pVCpu);
+            HM_DISABLE_PREEMPT();
+
+            pMixedCtx->dr[6] &= ~X86_DR6_B_MASK;
+            pMixedCtx->dr[6] |= uDR6;
+            if (CPUMIsGuestDebugStateActive(pVCpu))
+                ASMSetDR6(pMixedCtx->dr[6]);
+
+            HM_RESTORE_PREEMPT();
+            VMMRZCallRing3Enable(pVCpu);
+
+            pVCpu->mystate.s.bHardHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
     int rc;
     PCPUMCTX pCtx = &pVCpu->cpum.GstCtx;
     if (!pVmxTransient->fIsNestedGuest)
@@ -15117,6 +15265,19 @@ HMVMX_EXIT_DECL hmR0VmxExitRdmsr(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
     }
 #endif
 
+    /*MYCODE*/
+    for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP
+        && pTempBreakpointEntrie->breakpointAccessType == FDP_READ_BP
+        && (pTempBreakpointEntrie->breakpointGCPtr == idMsr || pTempBreakpointEntrie->breakpointGCPtr == 0)){
+            pVCpu->mystate.s.bMsrHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
     VBOXSTRICTRC rcStrict = IEMExecDecodedRdmsr(pVCpu, pVmxTransient->cbExitInstr);
     STAM_COUNTER_INC(&pVCpu->hm.s.StatExitRdmsr);
     if (rcStrict == VINF_SUCCESS)
@@ -15166,6 +15327,19 @@ HMVMX_EXIT_DECL hmR0VmxExitWrmsr(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
 
     Log4Func(("ecx=%#RX32 edx:eax=%#RX32:%#RX32\n", idMsr, pVCpu->cpum.GstCtx.edx, pVCpu->cpum.GstCtx.eax));
 
+    /*MYCODE*/
+    for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP
+        && pTempBreakpointEntrie->breakpointAccessType == FDP_WRITE_BP
+        && (pTempBreakpointEntrie->breakpointGCPtr == idMsr || pTempBreakpointEntrie->breakpointGCPtr == 0)){
+            pVCpu->mystate.s.bMsrHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
     VBOXSTRICTRC rcStrict = IEMExecDecodedWrmsr(pVCpu, pVmxTransient->cbExitInstr);
     STAM_COUNTER_INC(&pVCpu->hm.s.StatExitWrmsr);
 
@@ -15335,6 +15509,9 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
     PVMCC pVM = pVCpu->CTX_SUFF(pVM);
     uint64_t const uExitQual   = pVmxTransient->uExitQual;
     uint32_t const uAccessType = VMX_EXIT_QUAL_CRX_ACCESS(uExitQual);
+    /*MYCODE*/
+    bool bBreakpointHitted = false;
+    /*ENDMYCODE*/
     switch (uAccessType)
     {
         /*
@@ -15369,6 +15546,20 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
             AssertMsg(   rcStrict == VINF_SUCCESS
                       || rcStrict == VINF_PGM_SYNC_CR3, ("%Rrc\n", VBOXSTRICTRC_VAL(rcStrict)));
 
+            /*MYCODE*/
+            //Looking for a matching breakpoint
+            for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+                BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+                if(pTempBreakpointEntrie->breakpointActivated == true
+                && pTempBreakpointEntrie->breakpointType == FDP_CRHBP
+                && pTempBreakpointEntrie->breakpointAccessType == FDP_WRITE_BP
+                && (pTempBreakpointEntrie->breakpointGCPtr == VMX_EXIT_QUAL_CRX_REGISTER(uExitQual))){
+                    bBreakpointHitted = true;
+                    break;
+                }
+            }
+            /*ENDMYCODE*/
+
             /*
              * This is a kludge for handling switches back to real mode when we try to use
              * V86 mode to run real mode code directly.  Problem is that V86 mode cannot
@@ -15463,6 +15654,12 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
     Assert(rcStrict != VINF_IEM_RAISED_XCPT);
 
     STAM_PROFILE_ADV_STOP(&pVCpu->hm.s.StatExitMovCRx, y2);
+    /*MYCODE*/
+    if(bBreakpointHitted == true){
+        pVCpu->mystate.s.bCrHyperBreakPointHitted = true;
+        return VINF_EM_HALT;
+    }
+    /*ENDMYCODE*/
     NOREF(pVM);
     return rcStrict;
 }
@@ -15857,6 +16054,100 @@ HMVMX_EXIT_DECL hmR0VmxExitApicAccess(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransien
  */
 HMVMX_EXIT_DECL hmR0VmxExitMovDRx(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransient)
 {
+    /*MYCODE*/
+    {
+        int rc2 = 0;
+        PCPUMCTX pMixedCtx = &pVCpu->cpum.GstCtx;
+        hmR0VmxReadExitQualVmcs(pVmxTransient);
+        //rc2 |= hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+        rc2 |= hmR0VmxImportGuestState(pVCpu, pVmxTransient->pVmcsInfo, CPUMCTX_EXTRN_SREG_MASK | CPUMCTX_EXTRN_DR7);
+        //rc2 |= hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+        AssertRCReturn(rc2, rc2);
+
+        bool DRxWrite = false;
+        //if (VMX_EXIT_QUALIFICATION_DRX_DIRECTION(pVmxTransient->uExitQual) == VMX_EXIT_QUALIFICATION_DRX_DIRECTION_WRITE){
+        if (VMX_EXIT_QUAL_DRX_DIRECTION(pVmxTransient->uExitQual) == VMX_EXIT_QUAL_DRX_DIRECTION_WRITE){
+            DRxWrite = true;
+        }
+
+        PVM pVM2 = pVCpu->CTX_SUFF(pVM);
+
+        //Save the fakeDR to compare after the instruction
+        uint64_t aOldVisibleDr[8];
+        aOldVisibleDr[0] = pVCpu->mystate.s.aGuestDr[0];
+        aOldVisibleDr[1] = pVCpu->mystate.s.aGuestDr[1];
+        aOldVisibleDr[2] = pVCpu->mystate.s.aGuestDr[2];
+        aOldVisibleDr[3] = pVCpu->mystate.s.aGuestDr[3];
+        aOldVisibleDr[7] = pVCpu->mystate.s.aGuestDr[7];
+
+        //TODO: not needed, we need to save the value when FDP_WriteRegister()
+        //Save Invisble Debug Register values used by HardHyperBreakpoint
+        uint64_t uInvisibleDr0 = ASMGetDR0();
+        uint64_t uInvisibleDr1 = ASMGetDR1();
+        uint64_t uInvisibleDr2 = ASMGetDR2();
+        uint64_t uInvisibleDr3 = ASMGetDR3();
+        uint64_t uInvisibleDr6 = ASMGetDR6();
+        uint64_t uInvisibleDr7 = CPUMGetGuestDR7(pVCpu);
+
+        //Load fake DR Values
+        CPUMSetHyperDR0(pVCpu, pVCpu->mystate.s.aGuestDr[0]);
+        CPUMSetHyperDR1(pVCpu, pVCpu->mystate.s.aGuestDr[1]);
+        CPUMSetHyperDR2(pVCpu, pVCpu->mystate.s.aGuestDr[2]);
+        CPUMSetHyperDR3(pVCpu, pVCpu->mystate.s.aGuestDr[3]);
+        CPUMSetHyperDR6(pVCpu, pVCpu->mystate.s.aGuestDr[6]);
+        VMXWriteVmcs32(VMX_VMCS_GUEST_DR7, (uint32_t)pVCpu->mystate.s.aGuestDr[7]);
+
+        //Disable #MovDRx
+        pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls &= ~VMX_PROC_CTLS_MOV_DR_EXIT;
+        //Enable MTF
+        pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls |= VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+        rc2 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+        //Single Step
+        //hmR0VmxRunGuestCodeNormal(pVM2, pVCpu, pMixedCtx);
+        uint32_t     cLoops = 0;
+        hmR0VmxRunGuestCodeNormal(pVCpu, &cLoops);
+        hmR0VmxReadExitQualVmcs(pVmxTransient);
+        //rc2 |= hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+        //rc2 |= hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+        rc2 |= hmR0VmxImportGuestState(pVCpu, pVmxTransient->pVmcsInfo, CPUMCTX_EXTRN_SREG_MASK | CPUMCTX_EXTRN_DR7);
+        //Disable MTF
+        pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls &= ~VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+        //Enable #MovDrx
+        pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls |= VMX_PROC_CTLS_MOV_DR_EXIT;
+        rc2 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+        //Save new Visible Debug Register values (Usefull only on write)
+        pVCpu->mystate.s.aGuestDr[0] = ASMGetDR0();
+        pVCpu->mystate.s.aGuestDr[1] = ASMGetDR1();
+        pVCpu->mystate.s.aGuestDr[2] = ASMGetDR2();
+        pVCpu->mystate.s.aGuestDr[3] = ASMGetDR3();
+        pVCpu->mystate.s.aGuestDr[6] = ASMGetDR6();
+        pVCpu->mystate.s.aGuestDr[7] = pMixedCtx->dr[7];
+
+        //Restore Invisible Debug Register values
+        CPUMSetHyperDR0(pVCpu, uInvisibleDr0);
+        CPUMSetHyperDR1(pVCpu, uInvisibleDr1);
+        CPUMSetHyperDR2(pVCpu, uInvisibleDr2);
+        CPUMSetHyperDR3(pVCpu, uInvisibleDr3);
+        CPUMSetHyperDR6(pVCpu, uInvisibleDr6);
+        CPUMSetGuestDR7(pVCpu, (uint32_t)uInvisibleDr7);
+        VMXWriteVmcs32(VMX_VMCS_GUEST_DR7, (uint32_t)uInvisibleDr7);
+
+        //If a Visible Debug Register changed go to ring-3 install/remove a breakpoint
+        if (aOldVisibleDr[0] != pVCpu->mystate.s.aGuestDr[0]
+        ||  aOldVisibleDr[1] != pVCpu->mystate.s.aGuestDr[1]
+        ||  aOldVisibleDr[2] != pVCpu->mystate.s.aGuestDr[2]
+        ||  aOldVisibleDr[3] != pVCpu->mystate.s.aGuestDr[3]
+        ||  aOldVisibleDr[7] != pVCpu->mystate.s.aGuestDr[7]){
+            pVCpu->mystate.s.bInstallDrBreakpointRequired = true;
+            return VINF_EM_HALT;
+        }
+        //Go !
+        return VINF_SUCCESS;
+    }
+    /*ENDMYCODE*/
+
     HMVMX_VALIDATE_EXIT_HANDLER_PARAMS(pVCpu, pVmxTransient);
     PVMXVMCSINFO pVmcsInfo = pVmxTransient->pVmcsInfo;
 
@@ -16115,6 +16406,183 @@ HMVMX_EXIT_DECL hmR0VmxExitEptViolation(PVMCPUCC pVCpu, PVMXTRANSIENT pVmxTransi
     rcStrict = PGMR0Trap0eHandlerNestedPaging(pVM, pVCpu, PGMMODE_EPT, uErrorCode, CPUMCTX2CORE(pCtx), GCPhys);
     TRPMResetTrap(pVCpu);
 
+    /*MYCODE*/
+    if(PGMShwIsBreakable(pVCpu, GCPhys) == true){
+        //PHMGLOBALCPUINFO pCpu = hmR0GetCurrentCpu();
+        PCHMPHYSCPU pCpu = hmR0GetCurrentCpu();
+        STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestDE);
+        if(VMMGetBreakpointIdFromPage(pVM, GCPhys, FDP_PAGEHBP) >= 0){ //FDP_PAGEHBP
+            /*HMCPU_CF_SET(pVCpu,  HM_CHANGED_GUEST_RIP
+                               | HM_CHANGED_GUEST_RSP
+                               | HM_CHANGED_GUEST_RFLAGS);*/
+            ASMAtomicUoOrU64(&pVCpu->hm.s.fCtxChanged, HM_CHANGED_GUEST_RIP | HM_CHANGED_GUEST_RSP | HM_CHANGED_GUEST_RFLAGS);
+
+
+            int tmpAccess = 0x00;
+            if(pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_READ)
+                tmpAccess |= (int)FDP_READ_BP;
+            if(pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_WRITE)
+                tmpAccess |= (int)FDP_WRITE_BP;
+            if(pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_INSTR_FETCH)
+                tmpAccess |= (int)FDP_EXECUTE_BP;
+
+
+            STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestDE);
+            //If it is one of our breakpoints, go to VMMR3 !
+            int PageBreakpointId = VMMGetBreakpointId(pVM, GCPhys, FDP_PAGEHBP, tmpAccess);
+            if(PageBreakpointId >= (int)(4*pVM->cCpus)){
+                //This is a host page breakpoint !
+                pVCpu->mystate.s.bPageHyperBreakPointHitted = true;
+
+                //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+                PGMShwRestoreRights(pVCpu, GCPhys);
+                //VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+                hmR0VmxFlushEpt(pVCpu, pVmxTransient->pVmcsInfo, pVM->hm.s.vmx.enmTlbFlushEpt);
+                //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+                return VINF_EM_HALT;
+            }
+
+            if(PageBreakpointId >= 0
+            && PageBreakpointId < (int)(4*pVM->cCpus)){
+                STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestGP);
+                //This is a Guest Hardware Breakpoint !
+                //Update the guest dr6
+                pCtx->dr[6] = pVCpu->mystate.s.aGuestDr[6];
+                for(int i=0; i<4; i++){
+                    if(VMMMatchBreakpointId(pVM, i, GCPhys, FDP_PAGEHBP, tmpAccess)){
+                        pCtx->dr[6] = pCtx->dr[6] | ((uint64_t)(0x1 << (i)));
+                    }
+                }
+                ASMSetDR6(pCtx->dr[6]);
+
+                //Inject a INT1 into the guest
+                hmR0VmxSetPendingXcptDB(pVCpu);
+                return VINF_SUCCESS;
+            }
+
+            //If it not the breakpoint then continue !
+            //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+            PGMShwPresent(pVCpu, GCPhys);
+            PGMShwWrite(pVCpu, GCPhys);
+            PGMShwExecute(pVCpu, GCPhys);
+            //Flush TLB
+//#ifdef IN_RING0
+            PHMPHYSCPU pHostCpu     = hmR0GetCurrentCpu();
+            hmR0VmxFlushTaggedTlb(pHostCpu, pVCpu, pVmxTransient->pVmcsInfo);
+//#endif
+
+            //Active MTF
+            pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls |= VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+            int rc3 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+            //Single Step
+            //hmR0VmxRunGuestCodeNormal(pVM, pVCpu, pMixedCtx);
+            uint32_t     cLoops = 0;
+            hmR0VmxRunGuestCodeNormal(pVCpu, &cLoops);
+
+            //Disable MTF
+            pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls &= ~VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+            rc3 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+            //TODO: restoreOldFlags
+            PGMShwRestoreRights(pVCpu, GCPhys);
+            //Flush TLB
+            //VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+            hmR0VmxFlushEpt(pVCpu, pVmxTransient->pVmcsInfo, pVM->hm.s.vmx.enmTlbFlushEpt);
+            //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+            return VINF_SUCCESS;
+        }
+        int SoftBreakpointId = VMMGetBreakpointIdFromPage(pVM, GCPhys, FDP_SOFTHBP);
+        if(SoftBreakpointId > 0){
+            //FDP_SOFTHBP
+            ASMAtomicUoOrU64(&pVCpu->hm.s.fCtxChanged, HM_CHANGED_GUEST_RIP
+                               | HM_CHANGED_GUEST_RSP
+                               | HM_CHANGED_GUEST_RFLAGS);
+
+            //Avoid stack overflow when Fault inside fault !
+            if(pVCpu->mystate.s.bPageFaultOverflowGuard){
+                STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestGP);
+                return VINF_SUCCESS;
+            }
+
+            //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+            pVCpu->mystate.s.bPageFaultOverflowGuard = true;
+            bool bWriteAccess = ((pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_WRITE) != 0);
+            rc = VINF_SUCCESS;
+
+            //Execute Access
+            if(pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_INSTR_FETCH)
+            {
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+            }else {
+                //Read or Write Access
+                //if((pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_READ)
+                //  || (pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_WRITE))
+                //{
+                //Read, Write on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys); //Read !
+                PGMShwWrite(pVCpu, GCPhys); //Write !
+                PGMShwNoExecute(pVCpu, GCPhys);
+                //}
+            }
+
+            //Trash case, TODO: What is this ? Why ? Maybe "mov [rax], rcx" and rax inside the page
+            if(
+                ((pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_READ) && (pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_DATA_WRITE) && (pVmxTransient->uExitQual & VMX_EXIT_QUAL_EPT_INSTR_FETCH))
+            )
+            { //Special case
+                //Full rights on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys);
+                //Invalidate the GPA
+                //VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+                hmR0VmxFlushEpt(pVCpu, pVmxTransient->pVmcsInfo, pVM->hm.s.vmx.enmTlbFlushEpt);
+
+                //Active MTF
+                pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls |= VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+                VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+                //Single Step
+                //rc = VBOXSTRICTRC_VAL(hmR0VmxRunGuestCodeNormal(pVM, pVCpu, pMixedCtx));
+                uint32_t     cLoops = 0;
+                rc = VBOXSTRICTRC_VAL(hmR0VmxRunGuestCodeNormal(pVCpu, &cLoops));
+
+                //Disable MTF
+                pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls &= ~VMX_PROC_CTLS_MONITOR_TRAP_FLAG;
+                VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.VmcsInfo.u32ProcCtls);
+
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+            }else{
+                if(bWriteAccess == true){
+                    //TODO: OrignalPage, SingleStep, Copy OrignalPage to ModPage, Reinstall the HLT
+                }
+            }
+
+            //Invalidate the page
+            //VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+            hmR0VmxFlushEpt(pVCpu, pVmxTransient->pVmcsInfo, pVM->hm.s.vmx.enmTlbFlushEpt);
+
+            pVCpu->mystate.s.bPageFaultOverflowGuard = false;
+            //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+            return rc;
+        }
+    }
+    /*ENDMYCODE*/
+
     /* Same case as PGMR0Trap0eHandlerNPMisconfig(). See comment above, @bugref{6043}. */
     if (   rcStrict == VINF_SUCCESS
         || rcStrict == VERR_PAGE_TABLE_NOT_PRESENT
diff --git a/src/VBox/VMM/VMMR0/VMMR0.cpp b/src/VBox/VMM/VMMR0/VMMR0.cpp
index 5c7925d9..e67371d9 100644
--- a/src/VBox/VMM/VMMR0/VMMR0.cpp
+++ b/src/VBox/VMM/VMMR0/VMMR0.cpp
@@ -62,6 +62,13 @@
 #include <iprt/timer.h>
 #include <iprt/time.h>
 
+/*MYCODE*/
+#include <iprt/memobj.h>
+#include <iprt/mem.h>
+#include <VBox/vmm/mm.h>
+#include <VBox/vmm/pgm.h>
+/*ENDMYCODE*/
+
 #include "dtrace/VBoxVMM.h"
 
 
@@ -2239,6 +2246,48 @@ static int vmmR0EntryExWorker(PGVM pGVM, VMCPUID idCpu, VMMR0OPERATION enmOperat
             /** @todo make new test */
             return VINF_SUCCESS;
 
+        /*MYCODE*/
+        case VMMR0_DO_ALLOC_HCPHYS:
+        {
+            ALLOCPAGEREQ* pReq = (ALLOCPAGEREQ*)pReqHdr;
+            if(pReq == NULL){
+                LogRel(("[WDEBUG] pReqHdr is NULL\n"));
+                return -2;
+            }
+            int rc = 0;
+            RTR0MEMOBJ hMemObjMod;
+            //Allocates a new physical page
+            //rc = RTR0MemObjAllocPhysEx(&hMemObjMod, pReq->newPageSize, NIL_RTHCPHYS, pReq->newPageSize);
+            //rc = RTR0MemObjAllocPhysEx(&hMemObjMod, 4096, NIL_RTHCPHYS, 4096);
+            rc = RTR0MemObjAllocLow(&hMemObjMod, pReq->newPageSize, false);
+            if(RT_SUCCESS(rc)){
+                //Maps the new page in ring-0 address space
+                RTR0MEMOBJ hMapObjMod;
+                rc = RTR0MemObjMapKernel(&hMapObjMod, hMemObjMod, (void *)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE);
+                //Maps the new page in ring-3 address space
+                int rc2 = RTR0MemObjMapUser(&hMapObjMod, hMemObjMod, (RTR3PTR)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE, NIL_RTR0PROCESS);
+                LogRel(("[WEBUG] Mappin %d %d\n", rc, rc2));
+                if(RT_SUCCESS(rc) && RT_SUCCESS(rc2)){
+                    //Gets the ring-0 address of the new page
+                    //pVM->args.allochcphysreq.R0Ptr = (uint8_t*)RTR0MemObjAddress(hMapObjMod);
+                    //Gets the ring-3 address of the new page
+                    pReq->newPageR3Ptr = (uint8_t*)RTR0MemObjAddressR3(hMapObjMod);
+                    //Gets the physical address of the new page
+                    pReq->newPageHCPHys = RTR0MemObjGetPagePhysAddr(hMapObjMod, 0);
+                    return 0;
+                }else{
+                    LogRel(("[WDEBUG] Map failed ! \n"));
+                    return -3;
+                }
+            }else{
+                LogRel(("[WDEBUG] Alloc failed !\n"));
+                return rc;
+            }
+            return -4;
+        }
+        return VERR_NOT_SUPPORTED;
+        /*ENMYCODE*/
+
         default:
             /*
              * We're returning VERR_NOT_SUPPORT here so we've got something else
diff --git a/src/VBox/VMM/VMMR3/CPUM.cpp b/src/VBox/VMM/VMMR3/CPUM.cpp
index f2bc2102..b86885b9 100644
--- a/src/VBox/VMM/VMMR3/CPUM.cpp
+++ b/src/VBox/VMM/VMMR3/CPUM.cpp
@@ -2360,6 +2360,10 @@ VMMR3DECL(int) CPUMR3Term(PVM pVM)
  */
 VMMR3DECL(void) CPUMR3ResetCpu(PVM pVM, PVMCPU pVCpu)
 {
+    /*MYCODE*/
+    pVCpu->mystate.s.bRestoreRequired = false;
+    pVCpu->mystate.s.bPauseRequired = false;
+    /*ENDMYCODE*/
     /** @todo anything different for VCPU > 0? */
     PCPUMCTX pCtx = &pVCpu->cpum.s.Guest;
 
diff --git a/src/VBox/VMM/VMMR3/EM.cpp b/src/VBox/VMM/VMMR3/EM.cpp
index d2a3fac0..b5696ce6 100644
--- a/src/VBox/VMM/VMMR3/EM.cpp
+++ b/src/VBox/VMM/VMMR3/EM.cpp
@@ -68,6 +68,9 @@
 #include <iprt/stream.h>
 #include <iprt/thread.h>
 
+/*MYCODE*/
+#include <FDP/include/FDP.h>
+/*ENDMYCODE*/
 
 /*********************************************************************************************************************************
 *   Internal Functions                                                                                                           *
@@ -120,6 +123,11 @@ VMMR3_INT_DECL(int) EMR3Init(PVM pVM)
         pVM->em.s.fGuruOnTripleFault = true;
     }
 
+    /*MYCODE*/
+    //Dont Guru on Triple Fault... This is annoying !
+    pVM->em.s.fGuruOnTripleFault = false;
+    /*ENDMYCODE*/
+
     LogRel(("EMR3Init: fIemExecutesAll=%RTbool fGuruOnTripleFault=%RTbool\n", pVM->em.s.fIemExecutesAll, pVM->em.s.fGuruOnTripleFault));
 
     /** @cfgm{/EM/ExitOptimizationEnabled, bool, true}
@@ -834,7 +842,9 @@ static VBOXSTRICTRC emR3Debug(PVM pVM, PVMCPU pVCpu, VBOXSTRICTRC rc)
              * Simple events: stepped, breakpoint, stop/assertion.
              */
             case VINF_EM_DBG_STEPPED:
-                rc = DBGFR3Event(pVM, DBGFEVENT_STEPPED);
+                /*MYCODE*/
+                //rc = DBGFR3Event(pVM, DBGFEVENT_STEPPED);
+                /*ENDMYCODE*/
                 break;
 
             case VINF_EM_DBG_BREAKPOINT:
@@ -2316,6 +2326,28 @@ VMMR3_INT_DECL(int) EMR3ExecuteVM(PVM pVM, PVMCPU pVCpu)
             else if (fFFDone)
                 fFFDone = false;
 
+            /*MYCODE*/
+            if(pVCpu->mystate.s.bPauseRequired){
+                //Set the active CPU as STATE_PAUSED
+                pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+                //LogRel(("[WDEBUG] CPU[%d] Entering PAUSE in EM!\n", pVCpu->idCpu));
+                VMR3EnterPause(pVM, pVCpu);
+                //LogRel(("[WDEBUG] CPU[%d] Leaving PAUSE in EM!\n", pVCpu->idCpu));
+                rc = VINF_SUCCESS;
+            }
+            pVCpu->mystate.s.u8StateBitmap &= ~FDP_STATE_PAUSED;
+            pVCpu->mystate.s.u64TickCount++;
+            if(pVCpu->mystate.s.bRebootRequired){
+                rc = VINF_EM_TRIPLE_FAULT;
+                pVM->em.s.fGuruOnTripleFault = false;
+                pVCpu->mystate.s.bRebootRequired = false;
+            }
+            if(pVCpu->mystate.s.bSuspendRequired){
+                rc = VINF_EM_SUSPEND;
+                pVCpu->mystate.s.bSuspendRequired = false;
+            }
+            /*MYCODE*/
+
             /*
              * Now what to do?
              */
@@ -2868,3 +2900,17 @@ VMMR3_INT_DECL(int) EMR3ExecuteVM(PVM pVM, PVMCPU pVCpu)
     /* not reached */
 }
 
+/*MYCODE*/
+VMMR3_INT_DECL(int) EMR3ProcessForcedAction(PVM pVM, PVMCPU pVCpu, int rc)
+{
+    rc = emR3ForcedActions(pVM, pVCpu, rc);
+    VBOXVMM_EM_FF_ALL_RET(pVCpu, rc);
+
+    EMSTATE enmState = emR3Reschedule(pVM, pVCpu);
+    //LogRel(("EMR3ExecuteVM: VINF_EM_RESCHEDULE: %d -> %d (%s)\n", 0, enmState, "emR3GetStateName(enmState)"));
+    if (pVCpu->em.s.enmState != enmState && enmState == EMSTATE_IEM_THEN_REM)
+        pVCpu->em.s.cIemThenRemInstructions = 0;
+    pVCpu->em.s.enmState = enmState;
+    return rc;
+}
+/*ENDMYCODE*/
diff --git a/src/VBox/VMM/VMMR3/EMHM.cpp b/src/VBox/VMM/VMMR3/EMHM.cpp
index 378b40f8..bd3f6636 100644
--- a/src/VBox/VMM/VMMR3/EMHM.cpp
+++ b/src/VBox/VMM/VMMR3/EMHM.cpp
@@ -464,6 +464,10 @@ int emR3HmExecute(PVM pVM, PVMCPU pVCpu, bool *pfFFDone)
                 break;
             }
         }
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired)
+            break;
+        /*ENDMYCODE*/
     }
 
     /*
diff --git a/src/VBox/VMM/VMMR3/MM.cpp b/src/VBox/VMM/VMMR3/MM.cpp
index 2696ce61..5372209d 100644
--- a/src/VBox/VMM/VMMR3/MM.cpp
+++ b/src/VBox/VMM/VMMR3/MM.cpp
@@ -847,3 +847,7 @@ VMMR3DECL(uint32_t) MMR3PhysGet4GBRamHoleSize(PVM pVM)
     return pVM->mm.s.cbRamHole;
 }
 
+VMMR3DECL(uint64_t) MMR3PhysGetRamSizeU(PUVM pUVM)
+{
+    return pUVM->pVM->mm.s.cbRamBase;
+}
\ No newline at end of file
diff --git a/src/VBox/VMM/VMMR3/PGMDbg.cpp b/src/VBox/VMM/VMMR3/PGMDbg.cpp
index 520017d2..bf93a1e5 100644
--- a/src/VBox/VMM/VMMR3/PGMDbg.cpp
+++ b/src/VBox/VMM/VMMR3/PGMDbg.cpp
@@ -779,6 +779,10 @@ VMMR3_INT_DECL(int) PGMR3DbgScanPhysical(PVM pVM, RTGCPHYS GCPhys, RTGCPHYS cbRa
     return VERR_DBGF_MEM_NOT_FOUND;
 }
 
+VMMR3_INT_DECL(int) PGMR3DbgScanPhysicalU(PUVM pUVM, RTGCPHYS GCPhys, RTGCPHYS cbRange, RTGCPHYS GCPhysAlign, const uint8_t *pabNeedle, size_t cbNeedle, PRTGCPHYS pGCPhysHit)
+{
+    return PGMR3DbgScanPhysical(pUVM->pVM, GCPhys, cbRange, GCPhysAlign, pabNeedle, cbNeedle, pGCPhysHit);
+}
 
 /**
  * Scans (guest) virtual memory for a byte string.
diff --git a/src/VBox/VMM/VMMR3/TRPM.cpp b/src/VBox/VMM/VMMR3/TRPM.cpp
index 10c49f03..ffa93b57 100644
--- a/src/VBox/VMM/VMMR3/TRPM.cpp
+++ b/src/VBox/VMM/VMMR3/TRPM.cpp
@@ -360,6 +360,15 @@ static DECLCALLBACK(int) trpmR3Load(PVM pVM, PSSMHANDLE pSSM, uint32_t uVersion,
  */
 VMMR3DECL(int) TRPMR3InjectEvent(PVM pVM, PVMCPU pVCpu, TRPMEVENT enmEvent, bool *pfInjected)
 {
+    /*MYCODE*/
+    //Avoid interrupt during restore or pause
+    if(pVCpu->mystate.s.bRestoreRequired
+    || pVCpu->mystate.s.bPauseRequired
+    || pVCpu->mystate.s.bDisableInterrupt){
+        return VINF_EM_RESCHEDULE_HM;
+    }
+    /*ENDMYCODE*/
+
     PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
     Assert(!VMCPU_FF_IS_SET(pVCpu, VMCPU_FF_INHIBIT_INTERRUPTS));
     Assert(pfInjected);
diff --git a/src/VBox/VMM/VMMR3/VM.cpp b/src/VBox/VMM/VMMR3/VM.cpp
index 2ef84439..ef6ff53f 100644
--- a/src/VBox/VMM/VMMR3/VM.cpp
+++ b/src/VBox/VMM/VMMR3/VM.cpp
@@ -86,6 +86,12 @@
 #include <iprt/thread.h>
 #include <iprt/uuid.h>
 
+/*MYCODE*/
+#include <iprt/spinlock.h>
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+/*ENDMYCODE*/
+
 
 /*********************************************************************************************************************************
 *   Internal Functions                                                                                                           *
@@ -615,6 +621,18 @@ static int vmR3CreateU(PUVM pUVM, uint32_t cCpus, PFNCFGMCONSTRUCTOR pfnCFGMCons
             rc = vmR3ReadBaseConfig(pVM, pUVM, cCpus);
             if (RT_SUCCESS(rc))
             {
+                /*MYCODE*/
+                //This spinlock is created in Ring-0!
+                strcpy(pVM->mystate.s.PageSpinLockName, "PAGELOCK_");
+                strcat(pVM->mystate.s.PageSpinLockName, VMR3GetName(pUVM));
+
+                //Create CpuSpinLock
+                char CpuSpinLockName[256];
+                strcpy(CpuSpinLockName, "CPULOCK_");
+                strcat(CpuSpinLockName, VMR3GetName(pUVM));
+                pVM->mystate.s.CpuLock = NIL_RTSPINLOCK;
+                RTSpinlockCreate(&pVM->mystate.s.CpuLock, RTSPINLOCK_FLAGS_INTERRUPT_UNSAFE, CpuSpinLockName);
+                /*ENDMYCODE*/
                 /*
                  * Init the ring-3 components and ring-3 per cpu data, finishing it off
                  * by a relocation round (intermediate context finalization will do this).
@@ -1286,6 +1304,12 @@ static DECLCALLBACK(VBOXSTRICTRC) vmR3Resume(PVM pVM, PVMCPU pVCpu, void *pvUser
     VMRESUMEREASON enmReason = (VMRESUMEREASON)(uintptr_t)pvUser;
     LogFlow(("vmR3Resume: pVM=%p pVCpu=%p/#%u enmReason=%d\n", pVM, pVCpu, pVCpu->idCpu, enmReason));
 
+    /*MYCODE*/
+    if(pVCpu->mystate.s.bRestoreRequired == true){
+        pVCpu->mystate.s.bPauseRequired = true;
+    }
+    /*ENDMYCODE*/
+
     /*
      * The first thread thru here tries to change the state.  We shouldn't be
      * called again if this fails.
@@ -1967,6 +1991,27 @@ VMMR3DECL(int) VMR3LoadFromStream(PUVM pUVM, PCSSMSTRMOPS pStreamOps, void *pvSt
  */
 static DECLCALLBACK(VBOXSTRICTRC) vmR3PowerOff(PVM pVM, PVMCPU pVCpu, void *pvUser)
 {
+    /*MYCODE*/
+    //PVMCPU pVCpu = &pUVM->pVM->aCpus[0];
+    PUVM pUVM = pVM->pUVM;
+    //Do this only if the vCpu is Paused
+    if(pVCpu->mystate.s.bPauseRequired == true){
+        //Avoid freeze
+        //VMR3Break(pUVM);
+        //Clear All Breakpoint
+        for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+            VMR3RemoveBreakpoint(pUVM, BreakpointId);
+        }
+        CPUMSetGuestDR7(pVCpu, 0x400);
+        //Continue
+        //VMR3Continue(pUVM);*/
+        pVCpu->mystate.s.bPauseRequired = false;
+
+        //Stop FDP Debugger
+        FDP_SHM *pFdpShm = (FDP_SHM *)pUVM->pVM->mystate.s.pFdpShm;
+        pFdpShm->pFdpServer->bIsRunning = false;
+    }
+    /*ENDMYCODE*/
     LogFlow(("vmR3PowerOff: pVM=%p pVCpu=%p/#%u\n", pVM, pVCpu, pVCpu->idCpu));
     Assert(!pvUser); NOREF(pvUser);
 
diff --git a/src/VBox/VMM/VMMR3/VMEmt.cpp b/src/VBox/VMM/VMMR3/VMEmt.cpp
index 69f785b3..767f4bff 100644
--- a/src/VBox/VMM/VMMR3/VMEmt.cpp
+++ b/src/VBox/VMM/VMMR3/VMEmt.cpp
@@ -39,6 +39,18 @@
 #include <iprt/thread.h>
 #include <iprt/time.h>
 
+/*MYCODE*/
+#include <stdlib.h>
+
+#include <VBox/vmm/gmm.h>
+#include <VBox/vmm/iem.h>
+#include <VBox/vmm/pgm.h>
+
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+#include <iprt/spinlock.h>
+/*ENDMYCODE*/
+
 
 /*********************************************************************************************************************************
 *   Internal Functions                                                                                                           *
@@ -375,12 +387,23 @@ static DECLCALLBACK(int) vmR3HaltOldDoHalt(PUVMCPU pUVCpu, const uint32_t fMask,
         if (    VM_FF_IS_ANY_SET(pVM, VM_FF_EXTERNAL_HALTED_MASK)
             ||  VMCPU_FF_IS_ANY_SET(pVCpu, fMask))
             break;
+
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         uint64_t u64NanoTS;
         TMTimerPollGIP(pVM, pVCpu, &u64NanoTS);
         if (    VM_FF_IS_ANY_SET(pVM, VM_FF_EXTERNAL_HALTED_MASK)
             ||  VMCPU_FF_IS_ANY_SET(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Wait for a while. Someone will wake us up or interrupt the call if
          * anything needs our attention.
@@ -724,6 +747,11 @@ static DECLCALLBACK(int) vmR3HaltGlobal1Halt(PUVMCPU pUVCpu, const uint32_t fMas
             ||  VMCPU_FF_IS_ANY_SET(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Estimate time left to the next event.
          */
@@ -734,6 +762,11 @@ static DECLCALLBACK(int) vmR3HaltGlobal1Halt(PUVMCPU pUVCpu, const uint32_t fMas
             ||  VMCPU_FF_IS_ANY_SET(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Block if we're not spinning and the interval isn't all that small.
          */
@@ -1081,11 +1114,929 @@ VMMR3_INT_DECL(void) VMR3NotifyGlobalFFU(PUVM pUVM, uint32_t fFlags)
 VMMR3_INT_DECL(void) VMR3NotifyCpuFFU(PUVMCPU pUVCpu, uint32_t fFlags)
 {
     PUVM pUVM = pUVCpu->pUVM;
-
     LogFlow(("VMR3NotifyCpuFFU:\n"));
     g_aHaltMethods[pUVM->vm.s.iHaltMethod].pfnNotifyCpuFF(pUVCpu, fFlags);
 }
 
+/*MYCODE*/
+//TODO: include with DBGTcp.cpp
+#define DEBUG_LEVEL 1
+
+#if DEBUG_LEVEL > 0
+#define LogRelDebug(x) LogRel(x)
+#else
+#define LogRelDebug(x)
+#endif
+
+//TODO: Move this in VMMALL as there is a copy in VMMR0
+//TODO: Add Cs, Ds, Es, Fs, Gs, SS, ...
+void VMR3UpdateFdpCpuCtx(PVMCPU pVCpu)
+{
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    FDP_CPU_CTX* pFdpCpuCtx = (FDP_CPU_CTX *)pVCpu->mystate.s.pCpuShm;
+
+    pFdpCpuCtx->rip = pCtxCore->rip;
+    pFdpCpuCtx->rax = pCtxCore->rax;
+    pFdpCpuCtx->rcx = pCtxCore->rcx;
+    pFdpCpuCtx->rdx = pCtxCore->rdx;
+    pFdpCpuCtx->rbx = pCtxCore->rbx;
+    pFdpCpuCtx->rsp = pCtxCore->rsp;
+    pFdpCpuCtx->rbp = pCtxCore->rbp;
+    pFdpCpuCtx->rsi = pCtxCore->rsi;
+    pFdpCpuCtx->rdi = pCtxCore->rdi;
+    pFdpCpuCtx->r8 = pCtxCore->r8;
+    pFdpCpuCtx->r9 = pCtxCore->r9;
+    pFdpCpuCtx->r10 = pCtxCore->r10;
+    pFdpCpuCtx->r11 = pCtxCore->r11;
+    pFdpCpuCtx->r12 = pCtxCore->r12;
+    pFdpCpuCtx->r13 = pCtxCore->r13;
+    pFdpCpuCtx->r14 = pCtxCore->r14;
+    pFdpCpuCtx->r15 = pCtxCore->r15;
+    pFdpCpuCtx->cr0 = CPUMGetGuestCR0(pVCpu);
+    pFdpCpuCtx->cr2 = CPUMGetGuestCR2(pVCpu);
+    pFdpCpuCtx->cr3 = CPUMGetGuestCR3(pVCpu);
+    pFdpCpuCtx->cr4 = CPUMGetGuestCR4(pVCpu);
+}
+
+HardwarePage_t* VMR3GetAllocatedHardwarePage(PUVM pUVM, uint64_t GCPhys)
+{
+    //Look for a breakpoint already using a convient page
+    int BreakpointId = VMMGetBreakpointIdFromPage(pUVM->pVM, GCPhys, FDP_SOFTHBP);
+    if(BreakpointId >= 0
+    && BreakpointId < MAX_BREAKPOINT_ID){
+        //A breakpoint using a convient page exists
+        pUVM->pVM->bp.l[BreakpointId].breakpointHardwarePage->ReferenceCount++;
+        return pUVM->pVM->bp.l[BreakpointId].breakpointHardwarePage;
+    }
+
+    //Look in the Free HardwarePage table
+    for(uint32_t i=0; i<pUVM->pVM->mystate.s.u32HardwarePageTableCount; i++){
+        if(pUVM->pVM->mystate.s.aHardwarePageTable[i].ReferenceCount == 0
+        && pUVM->pVM->mystate.s.aHardwarePageTable[i].HCPhys != 0
+        && pUVM->pVM->mystate.s.aHardwarePageTable[i].R3Ptr != NULL){
+            pUVM->pVM->mystate.s.aHardwarePageTable[i].ReferenceCount = 1;
+            return &pUVM->pVM->mystate.s.aHardwarePageTable[i];
+        }
+    }
+
+    LogRel(("[WDEBUG] Allocate a new HardwarePage for %p !\n", GCPhys));
+    //None are free, allocate a new one !
+    ALLOCPAGEREQ Req;
+    Req.Hdr.u32Magic = SUPVMMR0REQHDR_MAGIC;
+    Req.Hdr.cbReq    = sizeof(Req);
+    Req.newPageSize = _4K;
+    int rc = SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0ForCall, NIL_VMCPUID, VMMR0_DO_ALLOC_HCPHYS, 0, &Req.Hdr);
+    if(rc != 0){
+        LogRel(("[WDEBUG] Failed to allocate a new HardwarePage %d\n", rc));
+        return NULL;
+    }
+
+    HardwarePage_t* TmpHardwarePage = &pUVM->pVM->mystate.s.aHardwarePageTable[pUVM->pVM->mystate.s.u32HardwarePageTableCount];
+
+    TmpHardwarePage->PageSize = _4K;
+    TmpHardwarePage->HCPhys = Req.newPageHCPHys;
+    TmpHardwarePage->R3Ptr = Req.newPageR3Ptr;
+    TmpHardwarePage->ReferenceCount = 1;
+
+    pUVM->pVM->mystate.s.u32HardwarePageTableCount++;
+
+    return TmpHardwarePage;
+}
+
+
+/*
+ * @brief: Restore all Original HCPhys for SoftHyperBreakpointed GCPhys
+ */
+VMMR3_INT_DECL(int)    VMR3RestoreAllOriginalPage(PUVM pUVM, bool bIsRead, bool bIsWrite, bool bIsExecute)
+{
+    PVM pVM = pUVM->pVM;
+    PVMCPU pVCpu = pUVM->aCpus[0].pVCpu;
+    BreakpointEntrie_t *pTempBreakpointEntrie = NULL;
+    for(uint8_t BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        //Check if Breakpoint is Activated and if it is a SoftWareBreakpoint
+        if(pTempBreakpointEntrie->breakpointActivated == true &&
+           pTempBreakpointEntrie->breakpointType == FDP_SOFTHBP &&
+           pTempBreakpointEntrie->breakpointOrigHCPhys != 0x0 &&
+           pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start != 0x0){
+            //Set Original Page as Read and Write
+            uint64_t GCPhys = pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start;
+            PGMShwSetHCPage(pVCpu, GCPhys, pTempBreakpointEntrie->breakpointOrigHCPhys);
+            if(bIsRead == true){
+                PGMShwPresent(pVCpu, GCPhys);
+            }else{
+                PGMShwNoPresent(pVCpu, GCPhys);
+            }
+            if(bIsWrite == true){
+                PGMShwWrite(pVCpu, GCPhys);
+            }else{
+                PGMShwNoWrite(pVCpu, GCPhys);
+            }
+            if(bIsExecute == true){
+                PGMShwExecute(pVCpu, GCPhys);
+            }else{
+                PGMShwNoExecute(pVCpu, GCPhys);
+            }
+            //Set page as breakable !
+            PGMShwSetBreakable(pVCpu, GCPhys, true);
+            //Invalidate the page !
+            PGMShwInvalidate(pVCpu, GCPhys);
+        }
+    }
+    return 0;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddMsrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress)
+{
+    PVM pVM = pUVM->pVM;
+    //Look for a free breakpoint
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            pTempBreakpointEntrie->breakpointActivated = true;
+            pTempBreakpointEntrie->breakpointGCPtr = BreakpointAddress;
+            pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+            pTempBreakpointEntrie->breakpointType = FDP_MSRHBP;
+            pTempBreakpointEntrie->breakpointLength = 1;
+            pTempBreakpointEntrie->breakpointAccessType = BreakpointAccessType;
+            pTempBreakpointEntrie->breakpointPageSize = 0x0;
+            pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+
+            return BreakpointId;
+        }
+    }
+    return -1;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddCrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress)
+{
+    PVM pVM = pUVM->pVM;
+    //Look for a free breakpoint
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            pTempBreakpointEntrie->breakpointActivated = true;
+            pTempBreakpointEntrie->breakpointGCPtr = BreakpointAddress;
+            pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+            pTempBreakpointEntrie->breakpointType = FDP_CRHBP;
+            pTempBreakpointEntrie->breakpointLength = 1;
+            pTempBreakpointEntrie->breakpointAccessType = BreakpointAccessType;
+            pTempBreakpointEntrie->breakpointPageSize = 0x0;
+            pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+
+            return BreakpointId;
+        }
+    }
+    return -1;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddSoftBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointCr3)
+{ //TODO: Move it to VMMAll !
+
+    LogRel(("[WDEBUG] VMR3AddSoftBreakpoint in\n"));
+    VMR3RestoreAllOriginalPage(pUVM, true, true, false);
+
+    PVM pVM = pUVM->pVM;
+
+    //Convert GCPtr to GCPhys if needed
+    uint64_t GCPhys;
+    uint64_t GCPtr = 0;
+    if(BreakpointAddressType == 0x1){//Virtual
+        GCPtr = BreakpointAddress;
+        PGMPhysGCPtr2GCPhys(pVCpu, BreakpointAddress, &GCPhys);
+        //PGMGstGetPage(pVCpu, BreakpointAddress, NULL, &GCPhys);
+    }else{ //Physical
+        GCPhys = BreakpointAddress;
+    }
+
+    //Look for an already existing SoftHyperBreakpoint with same GCPhys
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true &&
+           pTempBreakpointEntrie->breakpointType == FDP_SOFTHBP &&
+           pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start == GCPhys){
+               //We found one !
+               return BreakpointId;
+        }
+    }
+
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+
+        //Find a free breakpoint
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            //Get Original HCPhys
+            uint64_t origHCPhys;
+            //It is the OriginalPage because we called VMR3RestoreAllOriginalPage(pUVM);
+            PGMShwGetHCPage(pVCpu, GCPhys, &origHCPhys);
+            //After restore EPTPTE are not initilized
+            if(origHCPhys < 0x100){
+       LogRel(("[WDEBUG] AddSoft %p %p\n", GCPhys, origHCPhys));
+                return -1;
+            }
+
+            //Get a HardwarePage
+            HardwarePage_t* pTempHardwarePage = VMR3GetAllocatedHardwarePage(pUVM, GCPhys);
+            if(pTempHardwarePage != NULL){
+                if(pTempHardwarePage->ReferenceCount == 1){
+                    //This is the first breakpoint using this hardware page
+                    //Copy original page content to new page only if the page is new
+                    LogRel(("[WDEBUG] Copy OrignalPage to ModificatedPage\n"));
+                    PGMPhysSimpleReadGCPhys(pUVM->pVM, (void*)pTempHardwarePage->R3Ptr, (RTGCPHYS)(GCPhys & ~(pTempHardwarePage->PageSize-1)), pTempHardwarePage->PageSize);
+                }
+
+                LogRel(("[WDEBUG] SoftHyperBreakpoint installation : \n"));
+                LogRel(("[WDEBUG] Original page HCPhys: 0x%p\n", origHCPhys));
+                LogRel(("[WDEBUG] GCPhys: 0x%p\n", GCPhys));
+                LogRel(("[WDEBUG] pTempHardwarePage: %p\n", pTempHardwarePage));
+                LogRel(("[WDEBUG] Modificated page HCPhys:  0x%p\n", pTempHardwarePage->HCPhys));
+                LogRel(("[WDEBUG] Modificated page R3Ptr:  0x%p\n", pTempHardwarePage->R3Ptr));
+                LogRel(("[WDEBUG] HardwarePage Reference Count: %d\n", pTempHardwarePage->ReferenceCount));
+                LogRel(("[WDEBUG] \n"));
+
+                pTempBreakpointEntrie->breakpointActivated = true;
+                pTempBreakpointEntrie->breakpointGCPtr = GCPtr;
+                pTempBreakpointEntrie->breakpointOrigHCPhys = origHCPhys;
+                pTempBreakpointEntrie->breakpointType = FDP_SOFTHBP;
+                pTempBreakpointEntrie->breakpointLength = 1;
+                pTempBreakpointEntrie->breakpointCr3 = BreakpointCr3;
+                pTempBreakpointEntrie->breakpointAccessType = FDP_EXECUTE_BP;
+                pTempBreakpointEntrie->breakpointPageSize = pTempHardwarePage->PageSize;
+                pTempBreakpointEntrie->breakpointHardwarePage = pTempHardwarePage;
+                //Save the original byte
+                pTempBreakpointEntrie->breakpointOriginalByte = pTempHardwarePage->R3Ptr[(GCPhys & (pTempHardwarePage->PageSize-1))]; //TODO change % to &
+                //Install a HLT in the new page
+                pTempHardwarePage->R3Ptr[(GCPhys & (pTempHardwarePage->PageSize-1))] = 0xCC;
+                pTempBreakpointEntrie->breakpointGCPhysAreaCount = 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(1 * sizeof(GCPhysArea_t));
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start = GCPhys;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].End = GCPhys+1;
+
+                //Set page as original and read/write
+                PGMShwSetHCPage(pVCpu, GCPhys, origHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwNoExecute(pVCpu, GCPhys);
+                //Set page as breakable !
+                PGMShwSetBreakable(pVCpu, GCPhys, true);
+                //Invalidate the page !
+                PGMShwInvalidate(pVCpu, GCPhys);
+
+                return BreakpointId;
+            }else{
+       LogRel(("[WDEBUG] Failed to Allocate HardwarePage\n"));
+                return -1;
+            }
+        }
+    }
+    return -1;
+}
+
+void ApplyBreakpointOnPage(PVM pVM, PVMCPU pVCpu, uint64_t GCPhys, uint8_t BreakpointAccessType)
+{
+    //No access at all for FDP_READ_BP
+    if(BreakpointAccessType & FDP_READ_BP){
+        PGMShwNoPresent(pVCpu, GCPhys);
+        PGMShwNoWrite(pVCpu, GCPhys);
+        PGMShwNoExecute(pVCpu, GCPhys);
+    }
+    if(BreakpointAccessType & FDP_WRITE_BP)
+        PGMShwNoWrite(pVCpu, GCPhys);
+    if(BreakpointAccessType & FDP_EXECUTE_BP)
+        PGMShwNoExecute(pVCpu, GCPhys);
+
+    //Set the page as Breakable page
+    PGMShwSetBreakable(pVCpu, GCPhys, true);
+    //Save the final page rights
+    PGMShwSaveRights(pVCpu, GCPhys);
+    //Invalidate the page !
+    PGMShwInvalidate(pVCpu, GCPhys);
+}
+
+void DisableBreakpointOnPage(PVM pVM, PVMCPU pVCpu, uint64_t GCPhys)
+{
+    PGMShwPresent(pVCpu, GCPhys);
+    PGMShwWrite(pVCpu, GCPhys);
+    PGMShwExecute(pVCpu, GCPhys);
+
+    //Set the page as Standard page
+    PGMShwSetBreakable(pVCpu, GCPhys, false);
+    //Save the final page rights
+    PGMShwSaveRights(pVCpu, GCPhys);
+    //Invalidate the page !
+    PGMShwInvalidate(pVCpu, GCPhys);
+}
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+void AddGCPhysAreaInBreakpoint(BreakpointEntrie_t *pTempBreakpointEntrie, uint64_t Start, uint64_t End)
+{
+    if(pTempBreakpointEntrie){
+        int CurrentGCPhysAreaIndex = pTempBreakpointEntrie->breakpointGCPhysAreaCount;
+        //LogRel(("[WDEBUG] %d. %p->%p\n", CurrentGCPhysAreaIndex, Start, End));
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable[CurrentGCPhysAreaIndex].Start = Start;
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable[CurrentGCPhysAreaIndex].End = End;
+        pTempBreakpointEntrie->breakpointGCPhysAreaCount++;
+    }
+}
+
+void DisableAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+            }
+        }
+    }
+}
+
+void EnableAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            //Apply on pages
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                ApplyBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start, pTempBreakpointEntrie->breakpointAccessType);
+            }
+        }
+    }
+}
+
+void InstallAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+            }
+            if(pTempBreakpointEntrie->breakpointGCPhysAreaTable)
+                free(pTempBreakpointEntrie->breakpointGCPhysAreaTable);
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+        }
+    }
+
+    //Remove rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP){
+            uint64_t BreakpointLength = pTempBreakpointEntrie->breakpointLength;
+            if(pTempBreakpointEntrie->breakpointGCPtr > 0){ //VirtualAddress Breakpoint
+                uint64_t GCPhys;
+                uint64_t GCPtr = pTempBreakpointEntrie->breakpointGCPtr;
+                int MaxGCPhysAreaCount = (BreakpointLength/_4K) + 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(MaxGCPhysAreaCount * sizeof(GCPhysArea_t));
+
+                //First chunk Page
+                int rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr, &GCPhys);
+                uint64_t GCPhysPageEnd = (GCPhys & 0xFFFFFFFFFFFFF000) + _4K;
+                uint64_t AlreadyBreakpointSize = MIN(GCPhysPageEnd - GCPhys, BreakpointLength);
+                if(RT_SUCCESS(rc)){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+AlreadyBreakpointSize);
+                }
+                //Intermediate complete page
+                int64_t LeftToBreakpoint = BreakpointLength - AlreadyBreakpointSize;
+                while (LeftToBreakpoint >= _4K){ //More than 1 page to breakpoint !
+                    rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr + AlreadyBreakpointSize, &GCPhys);
+                    if(RT_SUCCESS(rc)){
+                        AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+_4K);
+                    }
+                    LeftToBreakpoint = LeftToBreakpoint - _4K;
+                    AlreadyBreakpointSize = AlreadyBreakpointSize + _4K;
+                }
+
+                //Last chunk page
+                if (LeftToBreakpoint > 0){ //Left breakpoint bytes
+                    rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr + AlreadyBreakpointSize, &GCPhys);
+                    if(RT_SUCCESS(rc)){
+                        AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+LeftToBreakpoint);
+                    }
+                }
+            }else{ //PhysicalAddress Breakpoint
+                uint64_t LeftToBreakpoint = 0;
+                int MaxGCPhysAreaCount = (BreakpointLength/_4K) + 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(MaxGCPhysAreaCount * sizeof(GCPhysArea_t));
+                uint64_t GCPhysPageEnd = (pTempBreakpointEntrie->breakpointGCPhys & ~(_4K-1)) + _4K;
+                uint64_t LastPageEnd = MIN(GCPhysPageEnd, pTempBreakpointEntrie->breakpointGCPhys+BreakpointLength);
+                LeftToBreakpoint = BreakpointLength - (LastPageEnd - pTempBreakpointEntrie->breakpointGCPhys);
+                AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, pTempBreakpointEntrie->breakpointGCPhys, LastPageEnd);
+                while(LeftToBreakpoint >= _4K){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, LastPageEnd, LastPageEnd+_4K);
+                    LeftToBreakpoint -= _4K;
+                    LastPageEnd += _4K;
+                }
+                if(LeftToBreakpoint > 0){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, LastPageEnd, LastPageEnd+LeftToBreakpoint);
+                }
+            }
+
+
+            //Apply on pages
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                ApplyBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start, pTempBreakpointEntrie->breakpointAccessType);
+            }
+        }
+    }
+
+    return;
+}
+
+
+bool IsOneCPURunning(PUVM pUVM)
+{
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        if(!(pUVM->aCpus[i].pVM->mystate.s.u8StateBitmap & FDP_STATE_PAUSED)){
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+
+VMMR3_INT_DECL(int)    VMR3AddPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointId, uint8_t BreakpointAccessType, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointLength)
+{ //TODO: Move it to VMMAll !
+    if(IsOneCPURunning(pUVM) == true){
+        //NO WAY !!!!!!
+        return -1;
+    }
+
+    PVM pVM = pUVM->pVM;
+
+    BreakpointEntrie_t *pTempBreakpointEntrie = NULL;
+    //If not a reserved to the guest breakpoint
+    if(BreakpointId < 0 || BreakpointId > 3){
+        bool BreakpointIdFound = false;
+        for(BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+            pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+            //Find a free breakpoint
+            if(pTempBreakpointEntrie->breakpointActivated == false){
+                break;
+            }
+        }
+    }else{
+        pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+    }
+
+    if(pTempBreakpointEntrie != NULL
+    && pTempBreakpointEntrie->breakpointActivated == false){
+        uint64_t GCPhys;
+        uint64_t GCPtr = 0;
+        if(BreakpointAddressType == FDP_VIRTUAL_ADDRESS){//Virtual
+            GCPtr = BreakpointAddress;
+            int rc = PGMPhysGCPtr2GCPhys(pVCpu, BreakpointAddress, &GCPhys);
+            if(RT_FAILURE(rc)){
+                //LogRel(("Fail to convert GCPtr(%p) -> GCphys\n", BreakpointAddress));
+                return -1;
+            }
+        }else{ //Physical
+            GCPhys = BreakpointAddress;
+        }
+
+        pVM->bp.l[BreakpointId].breakpointActivated = true;
+        pVM->bp.l[BreakpointId].breakpointGCPtr = GCPtr;
+        pVM->bp.l[BreakpointId].breakpointGCPhys = GCPhys;
+        pVM->bp.l[BreakpointId].breakpointType = FDP_PAGEHBP;
+        pVM->bp.l[BreakpointId].breakpointLength = BreakpointLength;
+        pVM->bp.l[BreakpointId].breakpointAccessType = BreakpointAccessType;
+        pVM->bp.l[BreakpointId].breakpointPageSize = _4K;
+
+        InstallAllPageBreakpoint(pVM, pVCpu);
+        return BreakpointId;
+    }
+    return -1;
+}
+
+//TODO: Move it to VMMAll !
+VMMR3_INT_DECL(bool) VMR3RemoveBreakpoint(PUVM pUVM, int BreakpointId)
+{
+
+    if(BreakpointId < 0 || BreakpointId > MAX_BREAKPOINT_ID){
+        return false;
+    }
+
+    //If one Cpu is running, we can't remove a breakpoint !
+    if(IsOneCPURunning(pUVM) == true){
+        return false;
+    }
+
+    PVM pVM = pUVM->pVM;
+    PVMCPU pVCpu = pUVM->aCpus[0].pVCpu;
+
+    //Restore OriginalPage for all SoftHyperBreakpoint
+    VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+
+    BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+
+    if(pTempBreakpointEntrie->breakpointActivated == true){
+        //Set the breakpoint as disabled
+        pTempBreakpointEntrie->breakpointActivated = false;
+
+        switch(pTempBreakpointEntrie->breakpointType)
+        {
+            case FDP_PAGEHBP:
+            {
+                //Enable all rights for page in this breakpoint
+                for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                    DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+                }
+                //Enable all other page Breakpoint
+                InstallAllPageBreakpoint(pVM, pVCpu);
+                break;
+            }
+            case FDP_SOFTHBP:
+            {
+                pTempBreakpointEntrie->breakpointHardwarePage->ReferenceCount--;
+                if(pTempBreakpointEntrie->breakpointHardwarePage->ReferenceCount == 0){
+                    uint64_t GCPhys = pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start;
+                    LogRelDebug(("[WDEBUG] HardwarePage->ReferenceCount == 0\n"));
+                    //No more breakpoint use this HardwarePage !
+                    //Restore Original page
+                    PGMShwSetHCPage(pVCpu, GCPhys, pTempBreakpointEntrie->breakpointOrigHCPhys);
+                    PGMShwPresent(pVCpu, GCPhys);
+                    PGMShwWrite(pVCpu, GCPhys);
+                    PGMShwExecute(pVCpu, GCPhys);
+
+                    PGMShwSetBreakable(pVCpu, GCPhys, false);
+
+                    PGMShwInvalidate(pVCpu, GCPhys);
+                }
+                break;
+            }
+            default:
+                break;
+        }
+
+        pTempBreakpointEntrie->breakpointTag = 0;
+        pTempBreakpointEntrie->breakpointGCPtr = 0;
+        pTempBreakpointEntrie->breakpointType = 0;
+        pTempBreakpointEntrie->breakpointLength = 0;
+        pTempBreakpointEntrie->breakpointAccessType = 0x0;
+        pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+        pTempBreakpointEntrie->breakpointOriginalByte = 0x0;
+        pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+        pTempBreakpointEntrie->breakpointPageSize = 0x0;
+
+        if(pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            free(pTempBreakpointEntrie->breakpointGCPhysAreaTable);
+        }
+
+        pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+        return true;
+    }
+    return false;
+}
+
+VMMDECL(int) VMR3PhysSimpleReadGCPhysU(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb)
+{
+    return PGMPhysSimpleReadGCPhys(pUVM->pVM, pvDst, GCPhysSrc, cb);
+}
+
+VMMDECL(int) VMR3PhysSimpleWriteGCPhysU(PUVM pUVM, const void *pvBuf, RTGCPHYS GCPhys, size_t cbWrite)
+{
+    return PGMPhysSimpleWriteGCPhys(pUVM->pVM, GCPhys, pvBuf, cbWrite);
+}
+
+VMMDECL(int) VMR3SingleStep(PUVM pUVM, PVMCPU pVCpu)
+{
+    //Dont try to single step on a running
+    if(pVCpu->mystate.s.u8StateBitmap & FDP_STATE_PAUSED){
+        pVCpu->mystate.s.bSingleStepRequired = true;
+        while(pVCpu->mystate.s.bSingleStepRequired){
+            //Yield
+            RTThreadSleep(0);
+        }
+        return 0;
+    }
+    return -1;
+}
+
+VMMDECL(int) VMR3BreakNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] BREAK !\n"));
+
+    //Wait for all cpu paused
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        pUVM->aCpus[i].pVCpu->mystate.s.bPauseRequired = true;
+
+        //Inject a IPI
+        SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0ForCall, pUVM->aCpus[i].pVCpu->idCpu, VMMR0_DO_GVMM_SCHED_WAKE_UP, 0, NULL);
+        SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0ForCall, pUVM->aCpus[i].pVCpu->idCpu, VMMR0_DO_GVMM_SCHED_POKE, 0, NULL);
+
+        do{
+            //LogRel(("[WDEBUG] Waiting for CPU[%d] to pause state %02x\n", i, pUVM->aCpus[i].pVCpu->mystate.s.u8StateBitmap));
+            //RTThreadSleep(10);
+        }while(!(pUVM->aCpus[i].pVCpu->mystate.s.u8StateBitmap & FDP_STATE_PAUSED));
+        //LogRel(("[WDEBUG] CPU[%d] is paused !\n", i));
+    }
+
+    //LogRel(("[WDEBUG] All Cpus are PAUSED !\n"));
+    return 0;
+}
+
+VMMDECL(int) VMR3Break(PUVM pUVM)
+{
+    RTSpinlockAcquire(pUVM->pVM->mystate.s.CpuLock);
+
+    VMR3BreakNoLock(pUVM);
+
+    RTSpinlockRelease(pUVM->pVM->mystate.s.CpuLock);
+    return 0;
+}
+
+VMMDECL(int) VMR3ContinueNoWaitNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] VMR3ContinueNoWaitNoLock !\n"));
+
+    pUVM->pVM->mystate.s.u8StateBitmap &= ~FDP_STATE_DEBUGGER_ALERTED;
+
+    //Wait for all CPUs resumed
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = pUVM->aCpus[i].pVCpu;
+        uint64_t oldu64TickCount = pVCpu->mystate.s.u64TickCount;
+        pVCpu->mystate.s.bPauseRequired = false;
+        //VMCPU_FF_SET(pVCpu, VMCPU_FF_EXTERNAL_SUSPENDED_MASK);
+    }
+
+    return 0;
+}
+
+VMMDECL(int) VMR3ContinueWaitNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] VMR3ContinueWaitNoLock !\n"));
+
+    pUVM->pVM->mystate.s.u8StateBitmap &= ~FDP_STATE_DEBUGGER_ALERTED;
+
+    //Wait for all CPUs resumed
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = pUVM->aCpus[i].pVCpu;
+        uint64_t oldu64TickCount = pVCpu->mystate.s.u64TickCount;
+        pVCpu->mystate.s.bPauseRequired = false;
+        //VMCPU_FF_SET(pVCpu, VMCPU_FF_EXTERNAL_SUSPENDED_MASK);
+        while(oldu64TickCount == pVCpu->mystate.s.u64TickCount){
+            //Yield
+            RTThreadSleep(0);
+        }
+    }
+
+    return 0;
+}
+
+VMMDECL(int) VMR3Continue(PUVM pUVM)
+{
+    RTSpinlockAcquire(pUVM->pVM->mystate.s.CpuLock);
+
+    VMR3ContinueWaitNoLock(pUVM);
+
+    RTSpinlockRelease(pUVM->pVM->mystate.s.CpuLock);
+    return 0;
+}
+
+VMMDECL(uint8_t) VMR3GetFDPState(PUVM pUVM)
+{
+    uint8_t u8OldState = 0;
+    bool bIsPaused = true;
+    bool bIsBreakpointHitted = false;
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        //If one CPU is Running not in pause
+        if(!(pUVM->aCpus[i].pVCpu->mystate.s.u8StateBitmap & FDP_STATE_PAUSED)){
+            bIsPaused = false;
+        }
+        //If one CPU hit a breakpoint
+        if(pUVM->aCpus[i].pVCpu->mystate.s.u8StateBitmap & FDP_STATE_BREAKPOINT_HIT){
+            bIsBreakpointHitted = true;
+        }
+    }
+
+    if(bIsPaused){
+        u8OldState |= FDP_STATE_PAUSED;
+        if(bIsBreakpointHitted){
+            u8OldState |= FDP_STATE_BREAKPOINT_HIT;
+        }
+    }
+
+    if(pUVM->pVM->mystate.s.u8StateBitmap & FDP_STATE_DEBUGGER_ALERTED){
+        u8OldState |= FDP_STATE_DEBUGGER_ALERTED;
+    }
+    if(u8OldState & FDP_STATE_BREAKPOINT_HIT){
+        pUVM->pVM->mystate.s.u8StateBitmap |= FDP_STATE_DEBUGGER_ALERTED;
+    }
+    return u8OldState;
+}
+
+VMMDECL(bool) VMR3DisableAllMsrBreakpoint(PVM pVM)
+{
+    for(int BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+            && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP){
+                pTempBreakpointEntrie->breakpointActivated = false;
+        }
+    }
+    return 0;
+}
+
+VMMDECL(bool) VMR3EnableAllMsrBreakpoint(PVM pVM)
+{
+    for(int BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointType == FDP_MSRHBP){
+                pTempBreakpointEntrie->breakpointActivated = true;
+        }
+    }
+    return 0;
+}
+
+VMMDECL(bool) VMR3HandleSingleStep(PVM pVM, PVMCPU pVCpu)
+{
+    //Check if Single step is required !
+    if(pVCpu->mystate.s.bSingleStepRequired){
+
+        TMR3NotifyResume(pVM, pVCpu);
+
+        LogRelDebug(("[WDEBUG] CPU[%d] bSingleStepRequired !\n", pVCpu->idCpu));
+
+        //Restore Original Page with Execute right, avoid Breakpoint in SingleStep
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, true);
+        //Disable All Msr Breakpoint, avoid Breakpoint in Breakpoint
+        VMR3DisableAllMsrBreakpoint(pVM);
+        //Disable PageHyperBreapoint
+        DisableAllPageBreakpoint(pVM, pVCpu);
+        //Disable Debug Register
+        uint64_t OldDr7 = CPUMGetGuestDR7(pVCpu);
+        CPUMSetGuestDR7(pVCpu, 0x400);
+
+        int rc = 0;
+        //First call is for instruction that jump on self "jmp -2 (ebfe)"
+        rc = VBOXSTRICTRC_VAL(EMR3HmSingleInstruction(pVM, pVCpu, 0));
+
+        LogRelDebug(("[WDEBUG] CPU[%d] Single Step => %d!\n", pVCpu->idCpu, rc));
+
+        if(VM_FF_IS_ANY_SET(pVM, VM_FF_ALL_REM_MASK)
+        || VMCPU_FF_IS_ANY_SET(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+            EMR3ProcessForcedAction(pVM, pVCpu, rc);
+        }
+
+        //If rc == 0 then it failed, we have to call SingleInstruction whith RIP_CHANGE
+        if(rc == 0){
+            rc = VBOXSTRICTRC_VAL(EMR3HmSingleInstruction(pVM, pVCpu, EM_ONE_INS_FLAGS_RIP_CHANGE));
+
+            LogRelDebug(("[WDEBUG] CPU[%d] Single Step => %d!\n", pVCpu->idCpu, rc));
+
+            if(VM_FF_IS_ANY_SET(pVM, VM_FF_ALL_REM_MASK)
+            || VMCPU_FF_IS_ANY_SET(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+                EMR3ProcessForcedAction(pVM, pVCpu, rc);
+            }
+        }
+
+        //Restore Original Page, avoid VirtualBox being crazy with unknown HCPhys on SoftHyperBreakpoint
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+        //Enable All Msr Breakpoint
+        VMR3EnableAllMsrBreakpoint(pVM);
+        //Enable All PageHyperBreakpoint
+        EnableAllPageBreakpoint(pVM, pVCpu);
+        //Enable Debug Register
+        CPUMSetGuestDR7(pVCpu, OldDr7);
+
+        TMR3NotifySuspend(pVM, pVCpu);
+
+        pVCpu->mystate.s.bSingleStepRequired = false; //Single step no more required !
+        return true;
+    }
+    return false;
+}
+
+VMMDECL(int) VMR3InjectInterrupt(PVM pVM, PVMCPU pVCpu, uint32_t enmXcpt, uint32_t uErr, uint64_t Cr2)
+{
+    // FDPTODO
+    return -1;
+}
+
+#include <VBox/vmm/pdmusb.h>
+
+VMMDECL(int) VMR3ClearInterrupt(PUVM pUVM, PVMCPU pVCpu)
+{
+    //return PDMR3UsbHasHub(pUVM);
+    PDMR3PowerOn(pUVM->pVM);
+    return 0;
+}
+
+VMMDECL(void) VMR3SetFDPShm(PUVM pUVM, void *pFdpShm)
+{
+    pUVM->pVM->mystate.s.pFdpShm = pFdpShm;
+}
+
+VMMDECL(bool) VMR3EnterPause(PVM pVM, PVMCPU pVCpu)
+{
+    if(pVCpu->idCpu == 0){
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+        TMR3NotifySuspend(pVM, pVCpu);
+
+        //Active wait
+        uint32_t u32WaitCount = 0;
+        while(pVCpu->mystate.s.bPauseRequired == true){
+            if(VMR3HandleSingleStep(pVM, pVCpu) == true){
+                //Update FDP_CPU_CTX
+                VMR3UpdateFdpCpuCtx(pVCpu);
+                u32WaitCount = 0;
+            }
+            //Powersaving :)
+            if((u32WaitCount & 0xFFFFFF) == 0xFFFFFF){
+                RTThreadSleep(5);
+            }else{
+                u32WaitCount++;
+            }
+        }
+
+        TMR3NotifyResume(pVM, pVCpu);
+
+        //ProcessForcedAction avoid freeze in CLI...BP...SAVE...STI
+        if(VM_FF_IS_ANY_SET(pVM, VM_FF_ALL_REM_MASK)
+            || VMCPU_FF_IS_ANY_SET(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+            EMR3ProcessForcedAction(pVM, pVCpu, 0);
+        }
+
+
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+    }
+    return true;
+}
+
+#include "VMMInternal.h"
+
+
+#define DR0_ENABLED 0x3
+#define DR1_ENABLED 0xC
+#define DR2_ENABLED 0x30
+#define DR3_ENABLED 0xC0
+
+#define DR_READ 0x03
+#define DR_WRITE 0x01
+#define DR_EXECUTE 0x00
+
+/*
+* @brief Convert a Debug Register Breakpoint Type to FDP Breakpoint Type
+*
+*/
+int GetDrType(uint64_t DrType)
+{
+    switch(DrType){
+        case DR_READ:
+            return FDP_READ_BP;
+        case DR_WRITE:
+            return FDP_WRITE_BP;
+        case DR_EXECUTE:
+            return FDP_EXECUTE_BP;
+    }
+    return 0;
+}
+
+/*
+ * @brief Get the Breakpoint Lenght from Debug Register Breakpoint Lenght
+ */
+uint64_t GetDrLength(uint64_t DrLength)
+{
+    switch(DrLength){
+        case 0:
+            return 1;
+        case 1:
+            return 2;
+        case 2:
+            return 8;
+        case 3:
+            return 4;
+    }
+    return 1;
+}
+
+VMMR3DECL(uint32_t) VMR3GetCPUCount(PUVM pUVM)
+{
+    return pUVM->pVM->cCpus;
+}
+
+
 
 /**
  * Halted VM Wait.
@@ -1102,6 +2053,121 @@ VMMR3_INT_DECL(void) VMR3NotifyCpuFFU(PUVMCPU pUVCpu, uint32_t fFlags)
  */
 VMMR3_INT_DECL(int) VMR3WaitHalted(PVM pVM, PVMCPU pVCpu, bool fIgnoreInterrupts)
 {
+    /*MYCODE*/
+   LogRel(("[WDEBUG] VMR3WaitHalted\n"));
+   if(pVCpu->mystate.s.bInstallDrBreakpointRequired){
+        LogRelDebug(("[WDEBUG] CPU[%d] Entering bInstallDrBreakpointRequired !!\n", pVCpu->idCpu));
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+
+        //Break all CPUs
+        VMR3Break(pVM->pUVM);
+
+        //Remove all breakpoint
+        int BreakpointId = 0;
+        for(int BreakpointId = (0+(pVCpu->idCpu*4)); BreakpointId<(int)(4+(pVCpu->idCpu*4)); BreakpointId++){
+            VMR3RemoveBreakpoint(pVM->pUVM, BreakpointId);
+        }
+
+        //Install all breakpoint
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[0] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[0]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[1] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[1]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[2] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[2]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[3] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[3]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[7] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[7]));
+
+        //Update Guest Breakpoint
+        for(uint8_t i=0; i<4; i++){
+            if(pVCpu->mystate.s.aGuestDr[7] & (0x3<< (i*2))){
+                uint8_t TEMP_DRX_LENGTH = (pVCpu->mystate.s.aGuestDr[7] & (0x3 << (18+i*4))) >> (18+i*4);
+                uint8_t DRX_LENGTH = GetDrLength(TEMP_DRX_LENGTH);
+                uint8_t TEMP_DRX_TYPE = (pVCpu->mystate.s.aGuestDr[7] & (0x3 << (16+i*4))) >> (16+i*4);
+                int DRX_TYPE = GetDrType(TEMP_DRX_TYPE);
+
+                int BreakpointId = -1;
+                if(DRX_TYPE > 0){
+                    BreakpointId = VMR3AddPageBreakpoint(pVM->pUVM, pVCpu, i+(pVCpu->idCpu*4), DRX_TYPE, FDP_VIRTUAL_ADDRESS, pVCpu->mystate.s.aGuestDr[i], DRX_LENGTH);
+                }
+                //LogRel(("INSTALL DR[%d] %d\n", i, BreakpointId));
+            }
+        }
+
+
+        pVCpu->mystate.s.u8StateBitmap &= ~FDP_STATE_PAUSED;
+        pVCpu->mystate.s.bPauseRequired = false;
+        pVCpu->mystate.s.bInstallDrBreakpointRequired = false;
+
+        //Continue all CPUs
+        VMR3ContinueNoWaitNoLock(pVM->pUVM);
+
+        LogRelDebug(("[WDEBUG] CPU[%d] Leaving bInstallDrBreakpointRequired !!\n", pVCpu->idCpu));
+        return VINF_EM_RESCHEDULE;
+    }
+
+    if(pVCpu->mystate.s.bHardHyperBreakPointHitted
+    || pVCpu->mystate.s.bPageHyperBreakPointHitted
+    || pVCpu->mystate.s.bSoftHyperBreakPointHitted
+    || pVCpu->mystate.s.bMsrHyperBreakPointHitted
+    || pVCpu->mystate.s.bCrHyperBreakPointHitted){
+
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+
+        if(pVCpu->mystate.s.bPageHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bPageHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bSoftHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bSoftHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bHardHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bHardHyperBreakPointHitted !!\n", pVCpu->idCpu));
+            pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_HARD_BREAKPOINT_HIT;
+        }
+        if(pVCpu->mystate.s.bMsrHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bMsrHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bCrHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bCrHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+
+
+        //Restore OriginalPage for all SoftHyperBreakpoint
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+
+        //Set the CPU as PAUSED and BREAKPOINT_HITTED
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_BREAKPOINT_HIT;
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+
+        //Break all CPUs
+        VMR3Break(pVM->pUVM);
+
+        //TODO: Protect this !
+        FDP_SHM *pFdpShm = (FDP_SHM *)pVM->mystate.s.pFdpShm;
+        FDP_SetStateChanged(pFdpShm);
+
+        //Waiting for debugger resume !
+        VMR3EnterPause(pVM, pVCpu);
+
+        bool bMsrHyperBreakpointHitted = pVCpu->mystate.s.bMsrHyperBreakPointHitted;
+
+        //We are ready to go !
+        pVCpu->mystate.s.bHardHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bPageHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bSoftHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bMsrHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bCrHyperBreakPointHitted = false;
+        pVCpu->mystate.s.u8StateBitmap = 0;
+
+        //Single step for MsrBreakpoint... Maybe this stuff should be done in Winbagility...
+        if(bMsrHyperBreakpointHitted == true){
+            pVCpu->mystate.s.bSingleStepRequired = true;
+            VMR3HandleSingleStep(pVM, pVCpu);
+            pVCpu->mystate.s.bSingleStepRequired = false;
+        }
+
+        LogRel(("[WDEBUG] CPU[%d] Leaving Breakpoint !\n", pVCpu->idCpu));
+        return VINF_EM_RESCHEDULE;
+    }
+    /*ENDMYCODE*/
     LogFlow(("VMR3WaitHalted: fIgnoreInterrupts=%d\n", fIgnoreInterrupts));
 
     /*
diff --git a/src/VBox/VMM/VMMR3/VMM.cpp b/src/VBox/VMM/VMMR3/VMM.cpp
index f89b2ae6..ed55c688 100644
--- a/src/VBox/VMM/VMMR3/VMM.cpp
+++ b/src/VBox/VMM/VMMR3/VMM.cpp
@@ -1101,6 +1101,10 @@ VMMR3_INT_DECL(int) VMMR3HmRunGC(PVM pVM, PVMCPU pVCpu)
             if (RT_LIKELY(rc == VINF_SUCCESS))
                 rc = pVCpu->vmm.s.iLastGZRc;
 #endif
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
         } while (rc == VINF_EM_RAW_INTERRUPT_HYPER);
 
 #if 0 /** @todo triggers too often */
diff --git a/src/VBox/VMM/include/PGMInternal.h b/src/VBox/VMM/include/PGMInternal.h
index 1a757db6..ec16ae49 100644
--- a/src/VBox/VMM/include/PGMInternal.h
+++ b/src/VBox/VMM/include/PGMInternal.h
@@ -98,6 +98,9 @@
  * Large page support enabled only on 64 bits hosts; applies to nested paging only.
  */
 #define PGM_WITH_LARGE_PAGES
+/*MYCODE*/
+#undef PGM_WITH_LARGE_PAGES
+/*ENDMYENCODE*/
 
 /**
  * Enables optimizations for MMIO handlers that exploits X86_TRAP_PF_RSVD and
