diff --git a/Config.kmk b/Config.kmk
index 5143b164..73a5a76b 100644
--- a/Config.kmk
+++ b/Config.kmk
@@ -1589,9 +1589,9 @@ endif
 ifdef VBOX_STRICT
  DEFS += VBOX_STRICT
 endif
-ifdef LOG_ENABLED
+#ifdef LOG_ENABLED
  DEFS += LOG_ENABLED
-endif
+#endif
 ifdef VBOX_OSE
  DEFS += VBOX_OSE
 endif
@@ -1606,9 +1606,9 @@ ifdef VBOX_WITH_RAW_MODE
 endif
 
 # Don't flood CDEFS, old MASMs doesn't like too many defines.
-ifdef VBOX_WITH_DEBUGGER
+#ifdef VBOX_WITH_DEBUGGER
  CDEFS += VBOX_WITH_DEBUGGER
-endif
+#endif
 ifdef VBOX_WITH_HARDENING
  CDEFS += VBOX_WITH_HARDENING
 endif
@@ -2215,8 +2215,12 @@ ifeq ($(KBUILD_TARGET),darwin)
   endif
  endif
  ifdef VBOX_WITH_NEW_XCODE
+  if $(KBUILD_HOST_VERSION_MAJOR) >= 18 # HACK ALERT! dtrace doesn't work on Mojave if we specify our Xcode 6.2 environment.
+   override TOOL_StandardDTrace_DTRACE := dtrace "-xcpppath=$(VBOX_PATH_MACOSX_DEVEL_ROOT)/usr/bin/gcc"
+  else
    override TOOL_StandardDTrace_DTRACE := $(TOOL_$(VBOX_GCC_TOOL)_ENV_SETUP) dtrace "-xcpppath=$(VBOX_PATH_MACOSX_DEVEL_ROOT)/usr/bin/gcc"
-   export PATH:=$(VBOX_PATH_MACOSX_SDK)/usr/bin:$(PATH)
+  endif
+  export PATH:=$(VBOX_PATH_MACOSX_SDK)/usr/bin:$(PATH)
  else
   if  $(VBOX_XCODE_VERSION_MAJOR) > 4 || ($(VBOX_XCODE_VERSION_MAJOR) == 4 && $(VBOX_XCODE_VERSION_MINOR) >= 2)
    TOOL_GXX4MACHO_PREFIX ?= llvm-
diff --git a/configure b/configure
index ca59623e..a6e37960 100755
--- a/configure
+++ b/configure
@@ -153,7 +153,7 @@ INCVPX=""
 LIBVPX="-lvpx"
 PKGCONFIG="`which_wrapper pkg-config`"
 PYTHONDIR="/usr /usr/local"
-QT5DIR="/usr/lib/qt5 /usr/share/qt5 /usr/lib64/qt5 /usr /usr/local"
+QT5DIR="/usr/lib/qt5 /usr/share/qt5 /usr/lib64/qt5 /usr /usr/local /opt/local/libexec/qt5"
 QT5DIR_PKGCONFIG=1
 QT5MAJ=5
 QT5MIN=6
@@ -1510,7 +1510,7 @@ EOF
     # Now try the user provided directory and some of the standard directories.
     QT_TRIES="$QT5DIR /System/Library /Library"
     for t in $QT_TRIES; do
-      if [ -f "$t/Frameworks/QtCore.framework/QtCore" ]; then
+      if [ -f "$t/lib/QtCore.framework/QtCore" ]; then
         PATH_SDK_QT5="$t"
         break
       fi
@@ -1518,8 +1518,8 @@ EOF
     # Add the necessary params for building the test application
     if [ -n "$PATH_SDK_QT5" ]; then
       foundqt5=1
-      INCQT5=-I$PATH_SDK_QT5/Frameworks/QtCore.framework/Headers
-      LIBQT5=-F$PATH_SDK_QT5/Frameworks
+      INCQT5=-I$PATH_SDK_QT5/lib/QtCore.framework/Headers
+      LIBQT5=-F$PATH_SDK_QT5/lib
       FLGQT5="-framework QtCore"
     else
       log_failure "Qt5 framework not found (can be disabled using --disable-qt)"
@@ -1600,9 +1600,9 @@ EOF
         if [ "$OS" = "darwin" ]; then
           # Successful build & run the test application so add the necessary
           # params to AutoConfig.kmk:
-          cnf_append "PATH_SDK_QT5_INC" "$PATH_SDK_QT5/Frameworks"
-          cnf_append "PATH_SDK_QT5_LIB" "$PATH_SDK_QT5/Frameworks"
-          cnf_append "PATH_SDK_QT5" "$PATH_SDK_QT5/Frameworks"
+          cnf_append "PATH_SDK_QT5_INC" "$PATH_SDK_QT5/inc"
+          cnf_append "PATH_SDK_QT5_LIB" "$PATH_SDK_QT5/lib"
+          cnf_append "PATH_SDK_QT5" "$PATH_SDK_QT5"
           # Check for the moc tool in the Qt directory found & some standard
           # directories.
           for q in $PATH_SDK_QT5 /usr /Developer/Tools/Qt; do
@@ -2167,6 +2167,14 @@ check_darwinversion()
   test_header "Darwin version"
   darwin_ver=`uname -r`
   case "$darwin_ver" in
+    18\.*)
+      check_xcode_sdk_path "$WITH_XCODE_DIR"
+      [ $? -eq 1 ] || fail
+      darwin_ver="10.14" # Mojave
+      sdk=$WITH_XCODE_DIR/Developer/SDKs/MacOSX10.6.sdk
+      cnf_append "VBOX_WITH_MACOSX_COMPILERS_FROM_DEVEL" "1"
+      cnf_append "VBOX_PATH_MACOSX_DEVEL_ROOT" "$WITH_XCODE_DIR/Developer"
+      ;;
     17\.*)
       check_xcode_sdk_path "$WITH_XCODE_DIR"
       [ $? -eq 1 ] || fail
diff --git a/include/VBox/vmm/em.h b/include/VBox/vmm/em.h
index 254a5a25..da3f9278 100644
--- a/include/VBox/vmm/em.h
+++ b/include/VBox/vmm/em.h
@@ -288,6 +288,11 @@ VMMR3_INT_DECL(int)             EMR3NotifyResume(PVM pVM);
 VMMR3_INT_DECL(int)             EMR3NotifySuspend(PVM pVM);
 VMMR3_INT_DECL(VBOXSTRICTRC)    EMR3HmSingleInstruction(PVM pVM, PVMCPU pVCpu, uint32_t fFlags);
 
+/*MYCODE*/
+VMMR3_INT_DECL(void)            EMR3ResetU(PUVM pUVM);
+VMMR3_INT_DECL(int)             EMR3ProcessForcedAction(PVM pVM, PVMCPU pVCpu, int rc);
+/*ENDMYCODE*/
+
 /** @} */
 #endif /* IN_RING3 */
 
diff --git a/include/VBox/vmm/gmm.h b/include/VBox/vmm/gmm.h
index df50d0a7..c15c390c 100644
--- a/include/VBox/vmm/gmm.h
+++ b/include/VBox/vmm/gmm.h
@@ -545,6 +545,17 @@ typedef GMMMEMSTATSREQ *PGMMMEMSTATSREQ;
 GMMR0DECL(int)  GMMR0QueryHypervisorMemoryStatsReq(PGMMMEMSTATSREQ pReq);
 GMMR0DECL(int)  GMMR0QueryMemoryStatsReq(PGVM pGVM, PVM pVM, VMCPUID idCpu, PGMMMEMSTATSREQ pReq);
 
+/*MYCODE*/
+typedef struct ALLOCPAGEREQ
+{
+    SUPVMMR0REQHDR  Hdr;
+    uint64_t        newPageSize;
+    uint64_t        newPageHCPHys;
+    uint8_t*        newPageR3Ptr;
+} ALLOCPAGEREQ;
+/*ENDMYCODE*/
+
+
 /**
  * Request buffer for GMMR0MapUnmapChunkReq / VMMR0_DO_GMM_MAP_UNMAP_CHUNK.
  * @see GMMR0MapUnmapChunk
diff --git a/include/VBox/vmm/hm.h b/include/VBox/vmm/hm.h
index 974742ba..469e27f9 100644
--- a/include/VBox/vmm/hm.h
+++ b/include/VBox/vmm/hm.h
@@ -173,6 +173,9 @@ VMM_INT_DECL(void)              HMSvmNstGstVmExitNotify(PVMCPU pVCpu, PCPUMCTX p
 #ifndef IN_RC
 VMM_INT_DECL(int)               HMFlushTLB(PVMCPU pVCpu);
 VMM_INT_DECL(int)               HMFlushTLBOnAllVCpus(PVM pVM);
+/*MYCODE*/
+VMM_INT_DECL(int)               HMFlushTLBOnAllVCpus2(PVM pVM);
+/*ENCODE*/
 VMM_INT_DECL(int)               HMInvalidatePageOnAllVCpus(PVM pVM, RTGCPTR GCVirt);
 VMM_INT_DECL(int)               HMInvalidatePhysPage(PVM pVM, RTGCPHYS GCPhys);
 VMM_INT_DECL(bool)              HMIsNestedPagingActive(PVM pVM);
@@ -194,6 +197,7 @@ VMM_INT_DECL(PGMMODE)           HMGetShwPagingMode(PVM pVM);
  * @{
  */
 VMMR0_INT_DECL(int)             HMR0Init(void);
+VMMR0_INT_DECL(int)             HMR0FlushEPT(PVM pVM, PVMCPU pVCpu);
 VMMR0_INT_DECL(int)             HMR0Term(void);
 VMMR0_INT_DECL(int)             HMR0InitVM(PVM pVM);
 VMMR0_INT_DECL(int)             HMR0TermVM(PVM pVM);
diff --git a/include/VBox/vmm/mm.h b/include/VBox/vmm/mm.h
index 685d0cb7..651bb6cd 100644
--- a/include/VBox/vmm/mm.h
+++ b/include/VBox/vmm/mm.h
@@ -228,6 +228,7 @@ VMMDECL(bool)       MMHyperIsInsideArea(PVM pVM, RTGCPTR GCPtr);
 
 VMMDECL(RTHCPHYS)   MMPage2Phys(PVM pVM, void *pvPage);
 VMMDECL(void *)     MMPagePhys2Page(PVM pVM, RTHCPHYS HCPhysPage);
+VMMDECL(void *)     MMPagePhys2PageU(PUVM pUVM, RTHCPHYS HCPhysPage);
 VMMDECL(int)        MMPagePhys2PageEx(PVM pVM, RTHCPHYS HCPhysPage, void **ppvPage);
 VMMDECL(int)        MMPagePhys2PageTry(PVM pVM, RTHCPHYS HCPhysPage, void **ppvPage);
 
@@ -295,6 +296,7 @@ VMMR3DECL(int)      MMR3HyperReadGCVirt(PVM pVM, void *pvDst, RTGCPTR GCPtr, siz
  * @todo retire this group, elimintating or moving MMR3PhysGetRamSize to PGMPhys.
  * @{ */
 VMMR3DECL(uint64_t) MMR3PhysGetRamSize(PVM pVM);
+VMMR3DECL(uint64_t) MMR3PhysGetRamSizeU(PUVM pUVM);
 VMMR3DECL(uint32_t) MMR3PhysGetRamSizeBelow4GB(PVM pVM);
 VMMR3DECL(uint64_t) MMR3PhysGetRamSizeAbove4GB(PVM pVM);
 VMMR3DECL(uint32_t) MMR3PhysGet4GBRamHoleSize(PVM pVM);
diff --git a/include/VBox/vmm/pgm.h b/include/VBox/vmm/pgm.h
index 92edd91a..70247db2 100644
--- a/include/VBox/vmm/pgm.h
+++ b/include/VBox/vmm/pgm.h
@@ -421,6 +421,24 @@ VMMDECL(int)            PGMShwMakePageNotPresent(PVMCPU pVCpu, RTGCPTR GCPtr, ui
 /** The page is an MMIO2. */
 #define PGM_MK_PG_IS_MMIO2           RT_BIT(1)
 /** @}*/
+
+
+/*MYCODE*/
+VMMDECL(int)        PGMShwGetHCPage(PVMCPU pVCpu, uint64_t GCPhys, uint64_t *HCPhys);
+VMMDECL(int)        PGMShwSetHCPage(PVMCPU pVCpu, uint64_t GCPhys, uint64_t HCPhys);
+VMMDECL(int)        PGMShwSaveRights(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwRestoreRights(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwPresent(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoPresent(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwWrite(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoWrite(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwExecute(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwNoExecute(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwInvalidate(PVMCPU pVCpu, uint64_t GCPhys);
+VMMDECL(int)        PGMShwSetBreakable(PVMCPU pVCpu, uint64_t GCPhys, bool Breakable);
+VMMDECL(bool)       PGMShwIsBreakable(PVMCPU pVCpu, uint64_t GCPhys);
+/*ENDMYCODE*/
+
 VMMDECL(int)        PGMGstGetPage(PVMCPU pVCpu, RTGCPTR GCPtr, uint64_t *pfFlags, PRTGCPHYS pGCPhys);
 VMMDECL(bool)       PGMGstIsPagePresent(PVMCPU pVCpu, RTGCPTR GCPtr);
 VMMDECL(int)        PGMGstSetPage(PVMCPU pVCpu, RTGCPTR GCPtr, size_t cb, uint64_t fFlags);
@@ -629,6 +647,7 @@ VMMDECL(VBOXSTRICTRC) PGMPhysReadGCPtr(PVMCPU pVCpu, void *pvDst, RTGCPTR GCPtrS
 VMMDECL(VBOXSTRICTRC) PGMPhysWriteGCPtr(PVMCPU pVCpu, RTGCPTR GCPtrDst, const void *pvSrc, size_t cb, PGMACCESSORIGIN enmOrigin);
 
 VMMDECL(int)        PGMPhysSimpleReadGCPhys(PVM pVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+VMMDECL(int)        PGMPhysSimpleReadGCPhys2(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
 VMMDECL(int)        PGMPhysSimpleWriteGCPhys(PVM pVM, RTGCPHYS GCPhysDst, const void *pvSrc, size_t cb);
 VMMDECL(int)        PGMPhysSimpleReadGCPtr(PVMCPU pVCpu, void *pvDst, RTGCPTR GCPtrSrc, size_t cb);
 VMMDECL(int)        PGMPhysSimpleWriteGCPtr(PVMCPU pVCpu, RTGCPTR GCPtrDst, const void *pvSrc, size_t cb);
@@ -698,6 +717,7 @@ VMMR0_INT_DECL(int) PGMR0PhysSetupIoMmu(PGVM pGVM, PVM pVM);
 VMMR0DECL(int)      PGMR0SharedModuleCheck(PVM pVM, PGVM pGVM, VMCPUID idCpu, PGMMSHAREDMODULE pModule, PCRTGCPTR64 paRegionsGCPtrs);
 VMMR0DECL(int)      PGMR0Trap0eHandlerNestedPaging(PVM pVM, PVMCPU pVCpu, PGMMODE enmShwPagingMode, RTGCUINT uErr, PCPUMCTXCORE pRegFrame, RTGCPHYS pvFault);
 VMMR0DECL(VBOXSTRICTRC) PGMR0Trap0eHandlerNPMisconfig(PVM pVM, PVMCPU pVCpu, PGMMODE enmShwPagingMode, PCPUMCTXCORE pRegFrame, RTGCPHYS GCPhysFault, uint32_t uErr);
+VMMR0DECL(VBOXSTRICTRC) PGMR0PhysSimpleReadGCPhys(PVM pVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
 # ifdef VBOX_WITH_2X_4GB_ADDR_SPACE
 VMMR0DECL(int)      PGMR0DynMapInit(void);
 VMMR0DECL(void)     PGMR0DynMapTerm(void);
@@ -728,6 +748,7 @@ VMMR3_INT_DECL(void)    PGMR3MemSetup(PVM pVM, bool fReset);
 VMMR3DECL(int)      PGMR3Term(PVM pVM);
 VMMR3DECL(int)      PGMR3LockCall(PVM pVM);
 VMMR3DECL(int)      PGMR3ChangeMode(PVM pVM, PVMCPU pVCpu, PGMMODE enmGuestMode);
+VMMR3DECL(int)      PGMR3ChangeMode2(PUVM pUVM, PVMCPU pVCpu, PGMMODE enmGuestMode);
 
 VMMR3DECL(int)      PGMR3PhysRegisterRam(PVM pVM, RTGCPHYS GCPhys, RTGCPHYS cb, const char *pszDesc);
 VMMR3DECL(int)      PGMR3PhysChangeMemBalloon(PVM pVM, bool fInflate, unsigned cPages, RTGCPHYS *paPhysPage);
@@ -832,6 +853,10 @@ VMMR3DECL(int)      PGMR3PhysGCPhys2CCPtrReadOnlyExternal(PVM pVM, RTGCPHYS GCPh
 VMMR3DECL(int)      PGMR3PhysChunkMap(PVM pVM, uint32_t idChunk);
 VMMR3DECL(void)     PGMR3PhysChunkInvalidateTLB(PVM pVM);
 VMMR3DECL(int)      PGMR3PhysAllocateHandyPages(PVM pVM);
+/*MYCODE*/
+VMMR3DECL(int)      PGMR3PhysAllocateLargeHandyPage2(PVM pVM);
+VMMR3_INT_DECL(int) PGMR3DbgScanPhysicalU(PUVM pUVM, RTGCPHYS GCPhys, RTGCPHYS cbRange, RTGCPHYS GCPhysAlign, const uint8_t *pabNeedle, size_t cbNeedle, PRTGCPHYS pGCPhysHit);
+/*ENDMYCODE*/
 VMMR3DECL(int)      PGMR3PhysAllocateLargeHandyPage(PVM pVM, RTGCPHYS GCPhys);
 
 VMMR3DECL(int)      PGMR3CheckIntegrity(PVM pVM);
diff --git a/include/VBox/vmm/vm.h b/include/VBox/vmm/vm.h
index 9e4e6de2..45203960 100644
--- a/include/VBox/vmm/vm.h
+++ b/include/VBox/vmm/vm.h
@@ -47,6 +47,61 @@
  * @{
  */
 
+/*MYCODE*/
+typedef struct HardwarePage_t{
+    int            ReferenceCount; //Number of breakpoint using this page
+    uint64_t    PageSize;        //Size of the page
+    uint64_t    HCPhys;            //Host-Context physical address of the page
+    uint8_t*    R3Ptr;            //Ring-3 virtual address of the page
+}HardwarePage_t;
+
+typedef struct GCPhysArea_t{
+    uint64_t    Start;
+    uint64_t    End;
+}GCPhysArea_t;
+
+typedef struct PfnEntrie_t{
+    uint8_t n;
+    struct{
+        bool u1Present;
+        bool u1Write;
+        bool u1Execute;
+        bool u1Breakable;
+    }u;
+}PfnEntrie_t;
+
+typedef struct BreakpointEntrie_t{
+            //Is the breakpoint activated or free
+            bool        breakpointActivated;
+            //Tag the breakpoint to know if the breakpoint changed...
+            uint64_t    breakpointTag;
+            //Kind of breakpoint PAGEHBP, HARDHBP, SOFTHBP
+            uint8_t        breakpointType;
+            //Guest virtual address of the breakpoint or start of the breakpoint
+            uint64_t    breakpointGCPtr;
+            //Guest physical address of the breakpoint or start of the breakpoint
+            uint64_t    breakpointGCPhys;
+            //Lengt of the breakpoint (PAGEHBP only)
+            uint64_t    breakpointLength;
+            //EXECUTE_BP, READ_BP, WRITE_BP
+            uint8_t        breakpointAccessType;
+            //Size of the page where the breakpoint is
+            uint64_t    breakpointPageSize;
+            //Original host physical page
+            uint64_t    breakpointOrigHCPhys;
+            //Original opcode byte
+            uint8_t        breakpointOriginalByte;
+            //Pointer to HardwarePage
+            HardwarePage_t* breakpointHardwarePage;
+            uint64_t        breakpointGCPhysAreaCount;
+            GCPhysArea_t*    breakpointGCPhysAreaTable;
+            //Condition
+            uint64_t    breakpointCr3;
+}BreakpointEntrie_t;
+
+#define MAX_BREAKPOINT_ID 255
+/*ENDMYCODE*/
+
 /**
  * The state of a Virtual CPU.
  *
@@ -149,6 +204,34 @@ typedef struct VMCPU
         uint8_t             padding[18496];     /* multiple of 64 */
     } iem;
 
+    /*MYCODE*/
+    union
+    {
+        struct{
+            volatile uint8_t    u8StateBitmap;
+            volatile bool        bSingleStepRequired;
+            volatile bool        bPauseRequired;
+            volatile bool        bDisableInterrupt;
+            volatile bool        bRebootRequired;
+            volatile bool        bSuspendRequired;
+            volatile bool        bRestoreRequired;
+            volatile bool        bPageFaultOverflowGuard;
+
+            volatile bool        bHardHyperBreakPointHitted;
+            volatile bool        bPageHyperBreakPointHitted;
+            volatile bool        bSoftHyperBreakPointHitted;
+            volatile bool        bMsrHyperBreakPointHitted;
+            volatile bool        bCrHyperBreakPointHitted;
+            volatile bool        bInstallDrBreakpointRequired;
+            //Fake Debug registers to keep "legit-guest" values
+            uint64_t            aGuestDr[8];
+            volatile uint64_t   u64TickCount;
+            void*               pCpuShm;
+        }s;
+        uint8_t             padding[4096];      /* multiple of 4096 */
+    } mystate;
+    /*ENDMYCODE*/
+
     /** HM part. */
     union VMCPUUNIONHM
     {
@@ -278,6 +361,7 @@ typedef struct VMCPU
 #endif
         uint8_t             padding[4096];      /* multiple of 4096 */
     } cpum;
+
 } VMCPU;
 
 
@@ -1110,6 +1194,28 @@ typedef struct VM
         uint8_t     padding[1600];      /* multiple of 64 */
     } vmm;
 
+    /*MYCODE*/
+    union{
+        BreakpointEntrie_t  l[MAX_BREAKPOINT_ID+1];
+        uint8_t             padding[4096*32];      /* Must be page aligned ! */
+    }bp;
+
+    union{
+        struct{
+            void                *pFdpShm;
+            uint32_t            u32HardwarePageTableCount;
+            HardwarePage_t      aHardwarePageTable[64];
+            volatile uint8_t    u8StateBitmap;
+            char                PageSpinLockName[256];
+            RTSPINLOCK          PageSpinlock;
+            PfnEntrie_t         *pPfnTableR3;
+            PfnEntrie_t         *pPfnTableR0;
+            RTSPINLOCK          CpuLock;
+        }s;
+        uint8_t     padding[4096];      /* Must be page aligned ! */
+    }mystate;
+    /*ENDMYCODE*/
+
     /** PGM part. */
     union
     {
@@ -1119,6 +1225,7 @@ typedef struct VM
         uint8_t     padding[4096*2+6080];      /* multiple of 64 */
     } pgm;
 
+
     /** HM part. */
     union
     {
@@ -1329,6 +1436,7 @@ typedef struct VM
      * Must be aligned on a page boundary for TLB hit reasons as well as
      * alignment of VMCPU members. */
     VMCPU           aCpus[1];
+
 } VM;
 
 
diff --git a/include/VBox/vmm/vm.mac b/include/VBox/vmm/vm.mac
index da1fa31b..f3302c99 100644
--- a/include/VBox/vmm/vm.mac
+++ b/include/VBox/vmm/vm.mac
@@ -61,6 +61,7 @@ struc VMCPU
 
     alignb 64
     .iem                    resb 18496
+    .mystate                resb 4096
     .hm                     resb 5824
     .em                     resb 1408
     .trpm                   resb 128
@@ -151,6 +152,8 @@ struc VM
     alignb 64
     .cpum                   resb 1536
     .vmm                    resb 1600
+    .bp                     resb (4096*32)
+    .mystate                resb 4096
     .pgm                    resb (4096*2+6080)
     .hm                     resb 5440
     .trpm                   resb 5248
diff --git a/include/VBox/vmm/vmapi.h b/include/VBox/vmm/vmapi.h
index cd5fb2c2..6dad9610 100644
--- a/include/VBox/vmm/vmapi.h
+++ b/include/VBox/vmm/vmapi.h
@@ -478,6 +478,32 @@ VMMR3_INT_DECL(void)        VMR3NotifyGlobalFFU(PUVM pUVM, uint32_t fFlags);
 VMMR3_INT_DECL(void)        VMR3NotifyCpuFFU(PUVMCPU pUVMCpu, uint32_t fFlags);
 VMMR3DECL(int)              VMR3NotifyCpuDeviceReady(PVM pVM, VMCPUID idCpu);
 VMMR3_INT_DECL(int)         VMR3WaitHalted(PVM pVM, PVMCPU pVCpu, bool fIgnoreInterrupts);
+/*MYCODE*/
+VMMDECL(uint8_t)            VMR3GetFDPState(PUVM pUVM);
+VMMR3_INT_DECL(int)         VMR3AddExecHardBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint64_t GCPtr, uint8_t BreakpointId);
+VMMR3_INT_DECL(int)         VMR3AddSoftBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointCr3);
+VMMR3_INT_DECL(int)         VMR3AddPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointId, uint8_t BreakpointAccessType, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointLength);
+VMMR3_INT_DECL(int)         VMR3AddMsrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress);
+VMMR3_INT_DECL(int)         VMR3AddCrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress);
+VMMR3_INT_DECL(void)        VMR3ClearBreakpoint(uint8_t BreakpointId);
+VMMR3_INT_DECL(bool)        VMR3IsBreakpoint(uint64_t CurrentRIP);
+VMMDECL(int)                VMR3PhysSimpleReadGCPhysU(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb);
+VMMDECL(int)                VMR3PhysSimpleWriteGCPhysU(PUVM pUVM, const void *pvBuf, RTGCPHYS GCPhys, size_t cbWrite);
+VMMR3_INT_DECL(int)         VMR3AddExecPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint64_t GCPtr, uint64_t Length);
+VMMR3_INT_DECL(bool)        VMR3RemoveBreakpoint(PUVM pUVM, int BreakpointId);
+VMMDECL(int)                VMR3SingleStep(PUVM pUVM, PVMCPU pVCpu);
+VMMDECL(int)                VMR3Break(PUVM pUVM);
+VMMDECL(int)                VMR3Continue(PUVM pUVM);
+VMMDECL(bool)               VMR3GetFDPRunning(PUVM pUVM);
+VMMDECL(void)               VMR3SetFDPRunning(PUVM pUVM, bool newFDPRunning);
+VMMR3DECL(uint32_t)         VMR3GetCPUCount(PUVM pUVM);
+VMMDECL(bool)               VMR3HandleSingleStep(PVM pVM, PVMCPU pVCpu);
+VMMDECL(bool)               VMR3EnterPause(PVM pVM, PVMCPU pVCpu);
+VMMDECL(void)               VMR3SetFDPShm(PUVM pUVM, void *pFdpShm);
+VMMDECL(uint64_t)           VMR3Test(PVMCPU pVCpu);
+VMMDECL(int)                VMR3InjectInterrupt(PVM pVM, PVMCPU pVCpu, uint32_t enmXcpt, uint32_t uErr, uint64_t Cr2);
+VMMDECL(int)                VMR3ClearInterrupt(PUVM pUVM, PVMCPU pVCpu);
+/*ENDMYCODE*/
 VMMR3_INT_DECL(int)         VMR3WaitU(PUVMCPU pUVMCpu);
 VMMR3DECL(int)              VMR3WaitForDeviceReady(PVM pVM, VMCPUID idCpu);
 VMMR3_INT_DECL(int)         VMR3AsyncPdmNotificationWaitU(PUVMCPU pUVCpu);
diff --git a/include/VBox/vmm/vmm.h b/include/VBox/vmm/vmm.h
index 7fc1ccc6..869fcf68 100644
--- a/include/VBox/vmm/vmm.h
+++ b/include/VBox/vmm/vmm.h
@@ -288,7 +288,11 @@ VMM_INT_DECL(void)          VMMTrashVolatileXMMRegs(void);
 VMM_INT_DECL(int)           VMMPatchHypercall(PVM pVM, void *pvBuf, size_t cbBuf, size_t *pcbWritten);
 VMM_INT_DECL(void)          VMMHypercallsEnable(PVMCPU pVCpu);
 VMM_INT_DECL(void)          VMMHypercallsDisable(PVMCPU pVCpu);
-
+/*MYCODE*/
+VMM_INT_DECL(bool)          VMMMatchBreakpointId(PVM pVM, int BreakpointId, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess);
+VMM_INT_DECL(int)           VMMGetBreakpointId(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess);
+VMM_INT_DECL(int)           VMMGetBreakpointIdFromPage(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType);
+/*ENDMYCODE*/
 
 #if defined(IN_RING3) || defined(DOXYGEN_RUNNING)
 /** @defgroup grp_vmm_api_r3    The VMM Host Context Ring 3 API
@@ -505,6 +509,8 @@ typedef enum VMMR0OPERATION
     /** Test the 32->64 bits switcher. */
     VMMR0_DO_TEST_SWITCHER3264,
 
+    VMMR0_DO_ALLOC_HCPHYS,
+
     /** The usual 32-bit type blow up. */
     VMMR0_DO_32BIT_HACK = 0x7fffffff
 } VMMR0OPERATION;
diff --git a/src/VBox/Debugger/DBGCTcp.cpp b/src/VBox/Debugger/DBGCTcp.cpp
index 247d2e17..b28d6873 100644
--- a/src/VBox/Debugger/DBGCTcp.cpp
+++ b/src/VBox/Debugger/DBGCTcp.cpp
@@ -30,6 +30,12 @@
 
 #include <iprt/string.h>
 
+/*MYCODE*/
+#include <pthread.h>
+#include <unistd.h>
+
+#include <VBox/vmm/vm.h>
+/*MYCODE*/
 
 /*********************************************************************************************************************************
 *   Structures and Typedefs                                                                                                      *
@@ -205,6 +211,914 @@ static DECLCALLBACK(int) dbgcTcpConnection(RTSOCKET Sock, void *pvUser)
     return rc;
 }
 
+/*MYCODE*/
+#include <stdio.h>
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+#include <FDP/FDP.c>
+
+#include <VBox/vmm/pgm.h>
+#include <VBox/vmm/mm.h>
+#include <VBox/vmm/cpum.h>
+
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+#define DEBUG_LEVEL 0
+#define DEBUG_FLOW 0
+
+#if DEBUG_LEVEL > 0
+#define Log1(fmt,...) printf(fmt, ##__VA_ARGS__)
+#else
+#define Log1(fmt,...)
+#endif
+
+#if DEBUG_LEVEL > 2
+#define Log3(fmt,...) printf(fmt, ##__VA_ARGS__)
+#else
+#define Log3(fmt,...)
+#endif
+
+#ifdef DEBUG_FLOW > 0
+#define LogFloww() printf("%s\n", __FUNCTION__);
+#else
+#define LogFloww()
+#endif
+
+typedef struct _MEMORY_SSM_T{
+    uint8_t        *pMemory;
+    uint64_t    cbMemory;
+    uint64_t    CurrentOffset;
+    uint64_t    MaxOffset;
+}MEMORY_SSM_T;
+
+typedef struct FDPVBOX_USERHANDLE_T{
+    PUVM            pUVM;
+    MEMORY_SSM_T*    pMemorySSM;
+    FDP_SHM*        pFDPServer;
+    uint64_t        aVisibleGuestDebugRegisterSave[7];
+    char            TempBuffer[1*1024*1024];
+}FDPVBOX_USERHANDLE_T;
+
+bool FDPVBOX_Resume(void *pUserHandle)
+{
+    LogFlow(("RESUME\n"));
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    VMR3Continue(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_Pause(void *pUserHandle)
+{
+    Log1("PAUSE !\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    VMR3Break(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_singleStep(void *pUserHandle, uint32_t CpuId)
+{
+    LogFlow(("SINGLE_STEP\n"));
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    int rc = VMR3SingleStep(myVBOXHandle->pUVM, pVCpu);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_getMemorySize(void *pUserHandle, uint64_t* MemorySize)
+{
+    Log1("GET_PHYSICALMEMORYSIZE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *MemorySize = MMR3PhysGetRamSizeU(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_readPhysicalMemory(void *pUserHandle, uint8_t *pDstBuffer, uint64_t PhysicalAddress, uint32_t ReadSize)
+{
+    Log1("READ_PHYSICAL %p %d ... ", PhysicalAddress, ReadSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    int rc = VMR3PhysSimpleReadGCPhysU(myVBOXHandle->pUVM, pDstBuffer, PhysicalAddress, ReadSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+
+bool FDPVBOX_writePhysicalMemory(void *pUserHandle, uint8_t *pSrcBuffer, uint64_t PhysicalAddress, uint32_t WriteSize)
+{
+    Log1("WRITE_PHYSICAL %p %d...", PhysicalAddress, WriteSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+
+    //Check Read access
+    if(FDPVBOX_readPhysicalMemory(pUserHandle, (uint8_t*)myVBOXHandle->TempBuffer, PhysicalAddress, WriteSize) == false){
+        return false;
+    }
+    //Effective Write
+    int rc =  VMR3PhysSimpleWriteGCPhysU(myVBOXHandle->pUVM, pSrcBuffer, PhysicalAddress, WriteSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+
+bool FDPVBOX_writeVirtualMemory(void *pUserHandle, uint32_t CpuId, uint8_t *pSrcBuffer, uint64_t VirtualAddress, uint32_t WriteSize)
+{
+    Log1("writeVirtualMemory %p %d ...", VirtualAddress, WriteSize);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    int rc = PGMPhysSimpleWriteGCPtr(pVCpu, VirtualAddress, pSrcBuffer, WriteSize);
+    Log1(" %s\n", RT_SUCCESS(rc) ? "OK" : "KO");
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_writeMsr(void *pUserHandle, uint32_t CpuId, uint64_t MSRId, uint64_t MSRValue)
+{
+    Log1("WRITE_MSR %p %p\n", MSRId, MSRValue);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    CPUMSetGuestMsr(pVCpu, MSRId, MSRValue);
+    //if(RT_SUCCESS(rc)){
+    //    return true;
+    //}
+    return false;
+}
+
+bool FDPVBOX_getState(void *pUserHandle, uint8_t *currentState)
+{
+    Log3("GET_STATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *currentState = VMR3GetFDPState(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_getCpuState(void *pUserHandle, uint32_t CpuId, uint8_t *pCurrentState)
+{
+    Log1("GET_CPU_STATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    *pCurrentState = pVCpu->mystate.s.u8StateBitmap;
+    return true;
+}
+
+
+bool FDPVBOX_getCpuCount(void *pUserHandle, uint32_t *pCpuCount)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    *pCpuCount = VMR3GetCPUCount(myVBOXHandle->pUVM);
+    return true;
+}
+
+bool FDPVBOX_readMsr(void *pUserHandle, uint32_t CpuId, uint64_t MsrId, uint64_t *pMsrValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    CPUMQueryGuestMsr(pVCpu, MsrId, pMsrValue);
+    Log1("READ_MSR %p => %p\n", MsrId, *pMsrValue);
+    return true;
+}
+
+bool FDPVBOX_readRegister(void *pUserHandle, uint32_t CpuId, FDP_Register RegisterId, uint64_t *pRegisterValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    PCPUMCTXCORE pRegFrame = (PCPUMCTXCORE)CPUMGetGuestCtxCore(pVCpu);
+
+    switch(RegisterId){
+        case FDP_CR0_REGISTER: *pRegisterValue = CPUMGetGuestCR0(pVCpu); break;
+        case FDP_CR2_REGISTER: *pRegisterValue = CPUMGetGuestCR2(pVCpu); break;
+        case FDP_CR3_REGISTER: *pRegisterValue = CPUMGetGuestCR3(pVCpu); break;
+        case FDP_CR4_REGISTER: *pRegisterValue = CPUMGetGuestCR4(pVCpu); break;
+        case FDP_CR8_REGISTER: *pRegisterValue = CPUMGetGuestCR8(pVCpu); break;
+        case FDP_RAX_REGISTER: *pRegisterValue = pCtxCore->rax; break;
+        case FDP_RBX_REGISTER: *pRegisterValue = pCtxCore->rbx; break;
+        case FDP_RCX_REGISTER: *pRegisterValue = pCtxCore->rcx; break;
+        case FDP_RDX_REGISTER: *pRegisterValue = pCtxCore->rdx; break;
+        case FDP_R8_REGISTER:  *pRegisterValue = pCtxCore->r8; break;
+        case FDP_R9_REGISTER:  *pRegisterValue = pCtxCore->r9; break;
+        case FDP_R10_REGISTER: *pRegisterValue = pCtxCore->r10; break;
+        case FDP_R11_REGISTER: *pRegisterValue = pCtxCore->r11; break;
+        case FDP_R12_REGISTER: *pRegisterValue = pCtxCore->r12; break;
+        case FDP_R13_REGISTER: *pRegisterValue = pCtxCore->r13; break;
+        case FDP_R14_REGISTER: *pRegisterValue = pCtxCore->r14; break;
+        case FDP_R15_REGISTER: *pRegisterValue = pCtxCore->r15; break;
+        case FDP_RSP_REGISTER: *pRegisterValue = pCtxCore->rsp; break;
+        case FDP_RBP_REGISTER: *pRegisterValue = pCtxCore->rbp; break;
+        case FDP_RSI_REGISTER: *pRegisterValue = pCtxCore->rsi; break;
+        case FDP_RDI_REGISTER: *pRegisterValue = pCtxCore->rdi; break;
+        case FDP_RIP_REGISTER: *pRegisterValue = pCtxCore->rip; break;
+
+        //Visible for Guest Debug Register
+        case FDP_VDR0_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[0]; break;
+        case FDP_VDR1_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[1]; break;
+        case FDP_VDR2_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[2]; break;
+        case FDP_VDR3_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[3]; break;
+        case FDP_VDR6_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[6]; break;
+        case FDP_VDR7_REGISTER: *pRegisterValue = pVCpu->mystate.s.aGuestDr[7]; break;
+
+        //Invisible for Guest Debug Register
+        case FDP_DR0_REGISTER: *pRegisterValue = CPUMGetGuestDR0(pVCpu); break;
+        case FDP_DR1_REGISTER: *pRegisterValue = CPUMGetGuestDR1(pVCpu); break;
+        case FDP_DR2_REGISTER: *pRegisterValue = CPUMGetGuestDR2(pVCpu); break;
+        case FDP_DR3_REGISTER: *pRegisterValue = CPUMGetGuestDR3(pVCpu); break;
+        case FDP_DR6_REGISTER: *pRegisterValue = CPUMGetGuestDR6(pVCpu); break;
+        case FDP_DR7_REGISTER: *pRegisterValue = CPUMGetGuestDR7(pVCpu); break;
+
+        case FDP_CS_REGISTER: *pRegisterValue = CPUMGetGuestCS(pVCpu); break;
+        case FDP_DS_REGISTER: *pRegisterValue = CPUMGetGuestDS(pVCpu); break;
+        case FDP_ES_REGISTER: *pRegisterValue = CPUMGetGuestES(pVCpu); break;
+        case FDP_FS_REGISTER: *pRegisterValue = CPUMGetGuestFS(pVCpu); break;
+        case FDP_GS_REGISTER: *pRegisterValue = CPUMGetGuestGS(pVCpu); break;
+        case FDP_SS_REGISTER: *pRegisterValue = CPUMGetGuestSS(pVCpu); break;
+        case FDP_RFLAGS_REGISTER: *pRegisterValue = CPUMGetGuestEFlags(pVCpu); break;
+        case FDP_GDTRB_REGISTER:
+            {
+                VBOXGDTR gdtr = {0, 0};
+                CPUMGetGuestGDTR(pVCpu,&gdtr);
+                *pRegisterValue = gdtr.pGdt;
+                break;
+            }
+        case FDP_GDTRL_REGISTER:
+            {
+                VBOXGDTR gdtr = {0, 0};
+                CPUMGetGuestGDTR(pVCpu,&gdtr);
+                *pRegisterValue = gdtr.cbGdt;
+                break;
+            }
+        case FDP_IDTRB_REGISTER:
+            {
+                uint16_t cbIDT;
+                RTGCPTR    GCPtrIDT = (RTGCPTR)CPUMGetGuestIDTR(pVCpu, &cbIDT);
+                *pRegisterValue = GCPtrIDT;
+                break;
+            }
+        case FDP_IDTRL_REGISTER:
+            {
+                uint16_t cbIDT;
+                RTGCPTR    GCPtrIDT = (RTGCPTR)CPUMGetGuestIDTR(pVCpu, &cbIDT);
+                *pRegisterValue = cbIDT;
+                break;
+            }
+        case FDP_LDTR_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                *pRegisterValue = CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                break;
+            }
+        case FDP_LDTRB_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                *pRegisterValue = Ldtrb;
+                break;
+            }
+        case FDP_LDTRL_REGISTER:
+            {
+                uint64_t Ldtrb;
+                uint32_t Ldtrl;
+                CPUMGetGuestLdtrEx(pVCpu, &Ldtrb, &Ldtrl);
+                *pRegisterValue = Ldtrl;
+                break;
+            }
+        case FDP_TR_REGISTER:
+            {
+                *pRegisterValue = CPUMGetGuestTR(pVCpu, NULL);
+                break;
+            }
+        default:
+            {
+                *pRegisterValue = 0xBADBADBADBADBADB;
+                return false;
+            }
+    }
+    return true;
+}
+
+bool FDPVBOX_writeRegister(void *pUserHandle, uint32_t CpuId, FDP_Register RegisterId, uint64_t RegisterValue)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    PCPUMCTXCORE pRegFrame = (PCPUMCTXCORE)CPUMGetGuestCtxCore(pVCpu);
+
+    FDP_CPU_CTX* pFdpCpuCtx = (FDP_CPU_CTX *)pVCpu->mystate.s.pCpuShm;
+
+    switch(RegisterId){
+        case FDP_RAX_REGISTER: pRegFrame->rax = RegisterValue; pFdpCpuCtx->rax = RegisterValue; break;
+        case FDP_RBX_REGISTER: pRegFrame->rbx = RegisterValue; pFdpCpuCtx->rbx = RegisterValue; break;
+        case FDP_RCX_REGISTER: pRegFrame->rcx = RegisterValue; pFdpCpuCtx->rcx = RegisterValue; break;
+        case FDP_RDX_REGISTER: pRegFrame->rdx = RegisterValue; pFdpCpuCtx->rdx = RegisterValue; break;
+        case FDP_R8_REGISTER:  pRegFrame->r8 = RegisterValue; pFdpCpuCtx->r8 = RegisterValue; break;
+        case FDP_R9_REGISTER:  pRegFrame->r9 = RegisterValue; pFdpCpuCtx->r9 = RegisterValue; break;
+        case FDP_R10_REGISTER: pRegFrame->r10 = RegisterValue; pFdpCpuCtx->r10 = RegisterValue; break;
+        case FDP_R11_REGISTER: pRegFrame->r11 = RegisterValue; pFdpCpuCtx->r11 = RegisterValue; break;
+        case FDP_R12_REGISTER: pRegFrame->r12 = RegisterValue; pFdpCpuCtx->r12 = RegisterValue; break;
+        case FDP_R13_REGISTER: pRegFrame->r13 = RegisterValue; pFdpCpuCtx->r13 = RegisterValue; break;
+        case FDP_R14_REGISTER: pRegFrame->r14 = RegisterValue; pFdpCpuCtx->r14 = RegisterValue; break;
+        case FDP_R15_REGISTER: pRegFrame->r15 = RegisterValue; pFdpCpuCtx->r15 = RegisterValue; break;
+        case FDP_RSP_REGISTER: pRegFrame->rsp = RegisterValue; pFdpCpuCtx->rsp = RegisterValue; break;
+        case FDP_RBP_REGISTER: pRegFrame->rbp = RegisterValue; pFdpCpuCtx->rbp = RegisterValue; break;
+        case FDP_RSI_REGISTER: pRegFrame->rsi = RegisterValue; pFdpCpuCtx->rsi = RegisterValue; break;
+        case FDP_RDI_REGISTER: pRegFrame->rdi = RegisterValue; pFdpCpuCtx->rdi = RegisterValue; break;
+        case FDP_RIP_REGISTER: pRegFrame->rip = RegisterValue; pFdpCpuCtx->rip = RegisterValue; break;
+
+        //Invisible for Guest Debug Register
+        case FDP_DR0_REGISTER: CPUMSetGuestDR0(pVCpu, RegisterValue); break;
+        case FDP_DR1_REGISTER: CPUMSetGuestDR1(pVCpu, RegisterValue); break;
+        case FDP_DR2_REGISTER: CPUMSetGuestDR2(pVCpu, RegisterValue); break;
+        case FDP_DR3_REGISTER: CPUMSetGuestDR3(pVCpu, RegisterValue); break;
+        case FDP_DR6_REGISTER: CPUMSetGuestDR6(pVCpu, RegisterValue); break;
+        case FDP_DR7_REGISTER: CPUMSetGuestDR7(pVCpu, RegisterValue); break;
+
+        //Visible for Guest Debug Register
+        case FDP_VDR0_REGISTER: pVCpu->mystate.s.aGuestDr[0] = RegisterValue; break;
+        case FDP_VDR1_REGISTER: pVCpu->mystate.s.aGuestDr[1] = RegisterValue; break;
+        case FDP_VDR2_REGISTER: pVCpu->mystate.s.aGuestDr[2] = RegisterValue; break;
+        case FDP_VDR3_REGISTER: pVCpu->mystate.s.aGuestDr[3] = RegisterValue; break;
+        case FDP_VDR6_REGISTER: pVCpu->mystate.s.aGuestDr[6] = RegisterValue; break;
+        case FDP_VDR7_REGISTER: pVCpu->mystate.s.aGuestDr[7] = RegisterValue; break;
+
+        case FDP_CS_REGISTER: CPUMSetGuestCS(pVCpu, RegisterValue); break;
+        case FDP_DS_REGISTER: CPUMSetGuestDS(pVCpu, RegisterValue); break;
+        case FDP_ES_REGISTER: CPUMSetGuestES(pVCpu, RegisterValue); break;
+        case FDP_FS_REGISTER: CPUMSetGuestFS(pVCpu, RegisterValue); break;
+        case FDP_GS_REGISTER: CPUMSetGuestGS(pVCpu, RegisterValue); break;
+        case FDP_SS_REGISTER: CPUMSetGuestSS(pVCpu, RegisterValue); break;
+        case FDP_CR0_REGISTER: CPUMSetGuestCR0(pVCpu, RegisterValue); pFdpCpuCtx->cr0 = RegisterValue; break;
+        case FDP_CR2_REGISTER: CPUMSetGuestCR2(pVCpu, RegisterValue); pFdpCpuCtx->cr3 = RegisterValue; break;
+        case FDP_CR3_REGISTER:
+        {
+            CPUMSetGuestCR3(pVCpu, RegisterValue);
+            PGMFlushTLB(pVCpu, RegisterValue, 0);
+            pFdpCpuCtx->cr3 = RegisterValue;
+            break;
+        }
+        case FDP_CR4_REGISTER: CPUMSetGuestCR4(pVCpu, RegisterValue); pFdpCpuCtx->cr4 = RegisterValue; break;
+        //case FDP_CR8_REGISTER: CPUMSetGuestCR8(pVCpu, RegisterValue); break;
+        case FDP_RFLAGS_REGISTER: CPUMSetGuestEFlags(pVCpu, RegisterValue); break;
+        default: break;
+    }
+    return true;
+}
+
+bool FDPVBOX_virtualToPhysical(void *pUserHandle, uint32_t CpuId, uint64_t VirtualAddress, uint64_t *PhysicalAddress)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+    //int rc = PGMPhysGCPtr2GCPhys(pVCpu, VirtualAddress, PhysicalAddress);
+    int rc = PGMGstGetPage(pVCpu, VirtualAddress, NULL, PhysicalAddress);
+    if(RT_FAILURE(rc)){
+        return false;
+    }
+    return true;
+}
+
+bool FDPVBOX_unsetBreakpoint(void *pUserHandle, uint8_t BreakpointId)
+{
+    Log1("UNSET_BP [%d] ! \n", BreakpointId);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    int rc = VMR3RemoveBreakpoint(myVBOXHandle->pUVM, BreakpointId);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+bool FDPVBOX_getFxState64(void *pUserHandle, uint32_t CpuId, uint8_t *pDstBuffer, uint32_t *pDstSize)
+{
+    Log1("GET_FXSTATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    PX86FXSTATE pFpuCtx = &pCtx->CTX_SUFF(pXState)->x87;
+    memcpy(pDstBuffer, pFpuCtx, sizeof(X86FXSTATE));
+    *pDstSize = sizeof(X86FXSTATE);
+    return true;
+}
+
+bool FDPVBOX_setFxState64(void *pUserHandle, uint32_t CpuId, uint8_t *pSrcBuffer, uint32_t uSrcSize)
+{
+    Log1("SET_FXSTATE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    PX86FXSTATE pFpuCtx = &pCtx->CTX_SUFF(pXState)->x87;
+    memcpy(pFpuCtx, pSrcBuffer, sizeof(X86FXSTATE));
+    return true;
+}
+
+bool FDPVBOX_readVirtualMemory(void *pUserHandle, uint32_t CpuId, uint64_t VirtualAddress, uint32_t ReadSize, uint8_t *pDstBuffer)
+{
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return false;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    int rc = 0;
+    rc = PGMPhysSimpleReadGCPtr(pVCpu, pDstBuffer, VirtualAddress, ReadSize);
+    if(RT_SUCCESS(rc)){
+        return true;
+    }
+    return false;
+}
+
+int FDPVBOX_setBreakpoint(
+    void *pUserHandle,
+    uint32_t CpuId,
+    FDP_BreakpointType BreakpointType,
+    uint8_t BreakpointId,
+    FDP_Access BreakpointAccessType,
+    FDP_AddressType BreakpointAddressType,
+    uint64_t BreakpointAddress,
+    uint64_t BreakpointLength,
+    uint64_t BreakpointCr3)
+{
+    Log1("SET_BREAKPOINT %p\n", BreakpointAddress);
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    if(CpuId >= VMR3GetCPUCount(myVBOXHandle->pUVM)){
+        return -1;
+    }
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(myVBOXHandle->pUVM, CpuId);
+
+    BreakpointId = -1;
+    switch(BreakpointType){
+        case FDP_SOFTHBP:
+        {
+            BreakpointId = VMR3AddSoftBreakpoint(myVBOXHandle->pUVM, pVCpu, BreakpointAddressType, BreakpointAddress, BreakpointCr3);
+            Log1("FDP_SOFTHBP[%d] %c %p %p\n", BreakpointId, BreakpointAddressType == 0x1 ? 'v' : 'p', BreakpointAddress, BreakpointCr3);
+            break;
+        }
+        case FDP_PAGEHBP:
+        {
+            BreakpointId = VMR3AddPageBreakpoint(myVBOXHandle->pUVM, pVCpu, -1, BreakpointAccessType, BreakpointAddressType, BreakpointAddress, BreakpointLength);
+            Log1("FDP_PAGEHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        case FDP_MSRHBP:
+        {
+            BreakpointId = VMR3AddMsrBreakpoint(myVBOXHandle->pUVM, BreakpointAccessType, BreakpointAddress);
+            Log1("FDP_MSRHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        case FDP_CRHBP:
+        {
+            BreakpointId = VMR3AddCrBreakpoint(myVBOXHandle->pUVM, BreakpointAccessType, BreakpointAddress);
+            Log1("FDP_CRHBP[%d] %02x %p\n", BreakpointId, BreakpointAccessType, BreakpointAddress);
+            break;
+        }
+        default:
+        {
+            Log1("Unknown BreakpointType!\n");
+            break;
+        }
+    }
+
+    return BreakpointId;
+}
+
+
+bool FDPVBOX_InjectInterrupt(void *pUserHandle, uint32_t CpuId, uint32_t InterruptionCode, uint32_t ErrorCode, uint64_t Cr2){
+    Log1("InjectInterrupt\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+    VMR3InjectInterrupt(NULL, pVCpu, InterruptionCode, ErrorCode, Cr2);
+    return true;
+}
+
+bool FDPVBOX_Reboot(void *pUserHandle)
+{
+    Log1("REBOOT\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+    FDPVBOX_Pause(pUserHandle);
+    for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+        FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+    }
+    CPUMSetGuestDR7(pVCpu, 0);
+
+    //Ask the EMT the Triple fault
+    pVCpu->mystate.s.bRebootRequired = true;
+
+    FDPVBOX_Resume(pUserHandle);
+
+    //TODO: Wait for the startup
+    usleep(100 * 1000);
+
+    //Signal that the VM as changed, and what a change...
+    myVBOXHandle->pFDPServer->pSharedFDPSHM->stateChanged = true;
+
+    return true;
+}
+
+
+
+#include <VBox/vmm/ssm.h>
+#include <iprt/file.h>
+
+
+
+static DECLCALLBACK(int) nullProgressCallback(PUVM pUVM, unsigned uPercent, void *pvUser)
+{
+    NOREF(pUVM);
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryWrite(void *pvUser, uint64_t offStream, const void *pvBuf, size_t cbToWrite)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    memcpy(pMemorySSM->pMemory+offStream, pvBuf, cbToWrite);
+    pMemorySSM->CurrentOffset = offStream;
+    if(offStream+cbToWrite > pMemorySSM->MaxOffset){
+        pMemorySSM->MaxOffset = offStream+cbToWrite;
+    }
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryRead(void *pvUser, uint64_t offStream, void *pvBuf, size_t cbToRead, size_t *pcbRead)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    memcpy(pvBuf, pMemorySSM->pMemory+offStream, cbToRead);
+    *pcbRead = cbToRead;
+    pMemorySSM->CurrentOffset = offStream + cbToRead;
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemorySeek(void *pvUser, int64_t offSeek, unsigned uMethod, uint64_t *poffActual)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    if(uMethod == RTFILE_SEEK_BEGIN){
+        pMemorySSM->CurrentOffset = offSeek;
+    }
+    if(uMethod == RTFILE_SEEK_END){
+        pMemorySSM->CurrentOffset = pMemorySSM->cbMemory-offSeek;
+    }
+    if(uMethod == RTFILE_SEEK_CURRENT){
+        pMemorySSM->CurrentOffset += offSeek;
+    }
+    *poffActual = pMemorySSM->CurrentOffset;
+    if(*poffActual > pMemorySSM->MaxOffset){
+        pMemorySSM->MaxOffset = *poffActual;
+    }
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(uint64_t) pfnMemoryTell(void *pvUser)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    return pMemorySSM->CurrentOffset;
+}
+
+static DECLCALLBACK(int) pfnMemorySize(void *pvUser, uint64_t *pcb)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    *pcb = pMemorySSM->MaxOffset;
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryIsOk(void *pvUser){
+    return VINF_SUCCESS;
+}
+
+static DECLCALLBACK(int) pfnMemoryClose(void *pvUser, bool fCancelled)
+{
+    MEMORY_SSM_T* pMemorySSM = (MEMORY_SSM_T*)pvUser;
+    pMemorySSM->CurrentOffset = 0;
+    pMemorySSM->MaxOffset = 0;
+    return VINF_SUCCESS;
+}
+
+static SSMSTRMOPS const g_ftmR3MemoryOps =
+{
+    SSMSTRMOPS_VERSION,
+    pfnMemoryWrite,
+    pfnMemoryRead,
+    pfnMemorySeek,
+    pfnMemoryTell,
+    pfnMemorySize,
+    pfnMemoryIsOk,
+    pfnMemoryClose,
+    SSMSTRMOPS_VERSION
+};
+
+
+
+bool FDPVBOX_Save(void *pUserHandle)
+{
+    Log1("SAVE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+    //Avoid Interrupt during save, we don't want Interrupt in our save state
+    pVCpu->mystate.s.bDisableInterrupt = true;
+
+    //Ask all CPU to suspend
+    printf("Save.FDPVBOX_Pause\n");
+    FDPVBOX_Pause(pUserHandle);
+
+    printf("Save.UsetBreakpoint\n");
+    for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+        FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+    }
+    //Disable Hardware breakpoint
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR0_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR1_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR2_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR3_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR6_REGISTER, 0);
+    FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR7_REGISTER, 0);
+
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR0_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[0]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR1_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[1]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR2_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[2]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR3_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[3]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR6_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[6]);
+    FDPVBOX_readRegister(pUserHandle, 0, FDP_VDR7_REGISTER, &myVBOXHandle->aVisibleGuestDebugRegisterSave[7]);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bSuspendRequired = true;
+    }
+
+    //Resume all CPU for suspend
+    printf("Save.FDPVBOX_Resume\n");
+    FDPVBOX_Resume(pUserHandle);
+
+    //Suspend all CPU
+    printf("Save.VMR3Suspend\n");
+    VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu2 = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu2->mystate.s.bSuspendRequired = false;
+    }
+
+    //Alloc SaveState memory
+    if(myVBOXHandle->pMemorySSM->pMemory == NULL){
+        myVBOXHandle->pMemorySSM->cbMemory = MMR3PhysGetRamSizeU(pUVM);
+        myVBOXHandle->pMemorySSM->pMemory = (uint8_t*)malloc(myVBOXHandle->pMemorySSM->cbMemory);
+    }
+
+    //Set offset
+    myVBOXHandle->pMemorySSM->CurrentOffset = 0;
+    myVBOXHandle->pMemorySSM->MaxOffset = 0;
+
+    //Save state
+    printf("Save.VMR3SaveFT\n");
+    bool bSuspended = false;
+    VMR3SaveFT(pUVM, &g_ftmR3MemoryOps, (void*)myVBOXHandle->pMemorySSM, &bSuspended, true);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bRestoreRequired = true;
+    }
+
+    printf("Save.VMR3Resume\n");
+    VMR3Resume(pUVM, VMRESUMEREASON_STATE_RESTORED);
+
+    printf("Save.FDPVBOX_Pause\n");
+    FDPVBOX_Pause(pUserHandle);
+
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, i);
+        pVCpu->mystate.s.bRestoreRequired = false;
+    }
+
+    pVCpu->mystate.s.bDisableInterrupt = false;
+
+    return true;
+}
+
+bool FDPVBOX_Restore(void *pUserHandle)
+{
+    Log1("RESTORE\n");
+    FDPVBOX_USERHANDLE_T* myVBOXHandle = (FDPVBOX_USERHANDLE_T*)pUserHandle;
+    PUVM pUVM = myVBOXHandle->pUVM;
+    int rc;
+    if(myVBOXHandle->pMemorySSM->pMemory != NULL){
+        PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+
+        //Avoid Interrupt during save, we don't want Interrupt in our save state
+        pVCpu->mystate.s.bDisableInterrupt = true;
+
+        printf("Restore.Pause\n");
+        FDPVBOX_Pause(pUserHandle);
+
+        printf("Restore.UsetBreakpoint\n");
+        for(int BreakpointId = 0; BreakpointId < FDP_MAX_BREAKPOINT; BreakpointId++){
+            FDPVBOX_unsetBreakpoint(pUserHandle, BreakpointId);
+        }
+        //Disable Hardware breakpoint
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR0_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR1_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR2_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR3_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR6_REGISTER, 0);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_DR7_REGISTER, 0);
+
+        printf("Restore.FDPVBOX_Resume\n");
+        //Force console client to reconnect
+        FDPVBOX_Resume(pUserHandle);
+
+        printf("Restore.VMR3Reset\n");
+        VMR3Reset(pUVM);
+
+        usleep(500 * 1000);
+
+        printf("Restore.VMR3Suspend\n");
+        rc = VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+
+
+        //rc = VMR3Suspend(pUVM, VMSUSPENDREASON_USER);
+        //printf("%d\n", rc);
+
+        printf("Restore.VMR3LoadFromStream\n");
+        VMR3LoadFromStream(pUVM, &g_ftmR3MemoryOps, (void*)myVBOXHandle->pMemorySSM, nullProgressCallback, NULL);
+
+        printf("Restore.VMR3Resume\n");
+        pVCpu->mystate.s.bRestoreRequired = true;
+        VMR3Resume(pUVM, VMRESUMEREASON_STATE_RESTORED);
+
+        printf("Restore.FDPVBOX_Pause\n");
+        FDPVBOX_Pause(pUserHandle);
+        pVCpu->mystate.s.bRestoreRequired = false;
+
+        //Restore visible for Guest Debug Register
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR0_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[0]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR1_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[1]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR2_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[2]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR3_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[3]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR6_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[6]);
+        FDPVBOX_writeRegister(pUserHandle, 0, FDP_VDR7_REGISTER, myVBOXHandle->aVisibleGuestDebugRegisterSave[7]);
+
+        pVCpu->mystate.s.bDisableInterrupt = false;
+
+        //printf("%d\n", VMR3ClearInterrupt(pUVM, NULL));
+
+        printf("Restore.Done!\n");
+        return true;
+    }
+
+    return false;
+}
+
+void *CreateCPUSHM(PUVM pUVM)
+{
+    int hMapFile;
+    void* pBuf;
+
+    char aCpuShmName[512] = {0};
+    strcpy(aCpuShmName,"CPU_");
+    strcat(aCpuShmName, VMR3GetName(pUVM));
+
+    pBuf = CreateSHM(aCpuShmName, sizeof(FDP_CPU_CTX));
+    if (pBuf == NULL) {
+        return NULL;
+    }
+    //Clear SHM
+    memset((void*)pBuf, 0, sizeof(FDP_CPU_CTX));
+
+    printf("0x%p\n", sizeof(FDP_CPU_CTX));
+
+    return pBuf;
+}
+
+void* FDPServerThread(LPVOID lpParam)
+{
+    PUVM pUVM = (PUVM)lpParam;
+    MEMORY_SSM_T MemorySSM;
+    MemorySSM.pMemory = NULL;
+    MemorySSM.CurrentOffset = 0;
+
+    FDP_SHM* pFDPServer = FDP_CreateSHM((char*)VMR3GetName(pUVM));
+    if(pFDPServer == NULL){
+        printf("FDP SHM creation failed !\n");
+        return NULL;
+    }
+
+    PVMCPU pVCpu = VMMR3GetCpuByIdU(pUVM, 0);
+    //PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
+    void* pCpuShm = CreateCPUSHM(pUVM);
+    pVCpu->mystate.s.pCpuShm = pCpuShm;
+    if(pCpuShm == NULL){
+        printf("Failed to CreateCpuShm\n");
+        return NULL;
+    }
+
+    printf("FDP_CreateSHM OK\n");
+    FDPVBOX_USERHANDLE_T *pUserHandle = (FDPVBOX_USERHANDLE_T*)malloc(sizeof(FDPVBOX_USERHANDLE_T));
+    pUserHandle->pUVM = pUVM;
+    pUserHandle->pMemorySSM = &MemorySSM;
+    pUserHandle->pFDPServer = pFDPServer;
+
+    //Configure FDP Server Interface
+    FDP_SERVER_INTERFACE_T FDPServerInterface;
+    FDPServerInterface.pUserHandle = pUserHandle;
+
+    FDPServerInterface.pfnGetState = &FDPVBOX_getState;
+    FDPServerInterface.pfnReadRegister = &FDPVBOX_readRegister;
+    FDPServerInterface.pfnWriteRegister =  &FDPVBOX_writeRegister;
+    FDPServerInterface.pfnWritePhysicalMemory = &FDPVBOX_writePhysicalMemory;
+    FDPServerInterface.pfnWriteVirtualMemory = &FDPVBOX_writeVirtualMemory;
+    FDPServerInterface.pfnGetMemorySize = &FDPVBOX_getMemorySize;
+    FDPServerInterface.pfnResume =  &FDPVBOX_Resume;
+    FDPServerInterface.pfnSingleStep =  &FDPVBOX_singleStep;
+    FDPServerInterface.pfnPause =  &FDPVBOX_Pause;
+    FDPServerInterface.pfnReadMsr =  &FDPVBOX_readMsr;
+    FDPServerInterface.pfnWriteMsr =  &FDPVBOX_writeMsr;
+    FDPServerInterface.pfnGetCpuCount =  &FDPVBOX_getCpuCount;
+    FDPServerInterface.pfnGetCpuState = &FDPVBOX_getCpuState;
+    FDPServerInterface.pfnVirtualToPhysical = &FDPVBOX_virtualToPhysical;
+    FDPServerInterface.pfnUnsetBreakpoint = &FDPVBOX_unsetBreakpoint;
+    FDPServerInterface.pfnGetFxState64 = &FDPVBOX_getFxState64;
+    FDPServerInterface.pfnSetFxState64 = &FDPVBOX_setFxState64;
+    FDPServerInterface.pfnReadVirtualMemory = &FDPVBOX_readVirtualMemory;
+    FDPServerInterface.pfnReadPhysicalMemory = &FDPVBOX_readPhysicalMemory;
+    FDPServerInterface.pfnSetBreakpoint = &FDPVBOX_setBreakpoint;
+    FDPServerInterface.pfnReadPhysicalMemory = &FDPVBOX_readPhysicalMemory;
+    FDPServerInterface.pfnSave = &FDPVBOX_Save;
+    FDPServerInterface.pfnRestore = &FDPVBOX_Restore;
+    FDPServerInterface.pfnReboot = &FDPVBOX_Reboot;
+    FDPServerInterface.pfnInjectInterrupt = &FDPVBOX_InjectInterrupt;
+
+    if (FDP_SetFDPServer(pFDPServer, &FDPServerInterface) == false){
+        printf("Failed to FDP_SerFDPServer\n");
+        return NULL;
+    }
+
+    printf("FDP_SetFDPServer OK\n");
+
+    VMR3SetFDPShm(pUVM, pFDPServer);
+
+    printf("VMR3SetFDPShm OK\n");
+
+    if (FDP_ServerLoop(pFDPServer) == false){
+        printf("Failed to FDP_ServerLoop\n");
+        return NULL;
+    }
+
+    if(pUserHandle != NULL){
+        free(pUserHandle);
+    }
+
+    return NULL;
+}
+/*ENDMYCODE*/
+
 
 /**
  * Spawns a new thread with a TCP based debugging console service.
@@ -215,6 +1129,10 @@ static DECLCALLBACK(int) dbgcTcpConnection(RTSOCKET Sock, void *pvUser)
  */
 DBGDECL(int)    DBGCTcpCreate(PUVM pUVM, void **ppvData)
 {
+    /*MYCODE*/
+    pthread_t t;
+    pthread_create(&t, NULL, FDPServerThread, pUVM);
+    /*ENDMYCODE*/
     /*
      * Check what the configuration says.
      */
diff --git a/src/VBox/Devices/Audio/DevHDA.cpp b/src/VBox/Devices/Audio/DevHDA.cpp
index 0a90d6ff..a4ce56cb 100644
--- a/src/VBox/Devices/Audio/DevHDA.cpp
+++ b/src/VBox/Devices/Audio/DevHDA.cpp
@@ -3501,12 +3501,12 @@ static int hdaR3SaveStream(PPDMDEVINS pDevIns, PSSMHANDLE pSSM, PHDASTREAM pStre
         RTCircBufReleaseReadBlock(pStream->State.pCircBuf, 0 /* Don't advance read pointer -- see comment above */);
     }
 
-    Log2Func(("[SD%RU8] LPIB=%RU32, CBL=%RU32, LVI=%RU32\n",
+    /*Log2Func(("[SD%RU8] LPIB=%RU32, CBL=%RU32, LVI=%RU32\n",
               pStream->u8SD,
               HDA_STREAM_REG(pThis, LPIB, pStream->u8SD), HDA_STREAM_REG(pThis, CBL, pStream->u8SD), HDA_STREAM_REG(pThis, LVI, pStream->u8SD)));
-
+*/
 #ifdef LOG_ENABLED
-    hdaR3BDLEDumpAll(pThis, pStream->u64BDLBase, pStream->u16LVI + 1);
+    //hdaR3BDLEDumpAll(pThis, pStream->u64BDLBase, pStream->u16LVI + 1);
 #endif
 
     return rc;
diff --git a/src/VBox/Devices/Audio/DevHDACommon.cpp b/src/VBox/Devices/Audio/DevHDACommon.cpp
index 43f4fb25..71d4eec4 100644
--- a/src/VBox/Devices/Audio/DevHDACommon.cpp
+++ b/src/VBox/Devices/Audio/DevHDACommon.cpp
@@ -179,10 +179,10 @@ bool hdaR3WalClkSet(PHDASTATE pThis, uint64_t u64WalClk, bool fForce)
 
     const uint64_t u64WalClkNew = hdaWalClkGetCurrent(pThis);
 
-    Log3Func(("Cur: %RU64, New: %RU64 (force %RTbool) -> %RU64 %s\n",
+/*    Log3Func(("Cur: %RU64, New: %RU64 (force %RTbool) -> %RU64 %s\n",
               u64WalClkCur, u64WalClk, fForce,
               u64WalClkNew, u64WalClkNew == u64WalClk ? "[OK]" : "[DELAYED]"));
-
+*/
     return (u64WalClkNew == u64WalClk);
 }
 
diff --git a/src/VBox/Devices/Network/DevE1000.cpp b/src/VBox/Devices/Network/DevE1000.cpp
index 21478b6b..3d256911 100644
--- a/src/VBox/Devices/Network/DevE1000.cpp
+++ b/src/VBox/Devices/Network/DevE1000.cpp
@@ -3297,14 +3297,16 @@ static DECLCALLBACK(void) e1kTxDelayTimer(PPDMDEVINS pDevIns, PTMTIMER pTimer, v
     PE1KSTATE pThis = (PE1KSTATE )pvUser;
     Assert(PDMCritSectIsOwner(&pThis->csTx));
 
-    E1K_INC_ISTAT_CNT(pThis->uStatTxDelayExp);
+    E1K_INC_ISTAT_CNT(pThis->uStatTxDelayExp)
 #  ifdef E1K_INT_STATS
     uint64_t u64Elapsed = RTTimeNanoTS() - pThis->u64ArmedAt;
     if (u64Elapsed > pThis->uStatMaxTxDelay)
         pThis->uStatMaxTxDelay = u64Elapsed;
 #  endif
     int rc = e1kXmitPending(pThis, false /*fOnWorkerThread*/);
-    AssertMsg(RT_SUCCESS(rc) || rc == VERR_TRY_AGAIN, ("%Rrc\n", rc));
+	/*MYCODE*/
+	//AssertMsg(RT_SUCCESS(rc) || rc == VERR_TRY_AGAIN, ("%Rrc\n", rc));
+	/*ENDMYCODE*/
 }
 # endif /* E1K_TX_DELAY */
 
diff --git a/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp b/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
index 4498678e..8024b794 100644
--- a/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
+++ b/src/VBox/Devices/Storage/DevLsiLogicSCSI.cpp
@@ -1029,10 +1029,10 @@ static int lsilogicR3ProcessMessageRequest(PLSILOGICSCSI pThis, PMptMessageHdr p
     bool fForceReplyPostFifo = false;
 
 # ifdef LOG_ENABLED
-    if (pMessageHdr->u8Function < RT_ELEMENTS(g_apszMPTFunctionNames))
+    /*if (pMessageHdr->u8Function < RT_ELEMENTS(g_apszMPTFunctionNames))
         Log(("Message request function: %s\n", g_apszMPTFunctionNames[pMessageHdr->u8Function]));
     else
-        Log(("Message request function: <unknown>\n"));
+        Log(("Message request function: <unknown>\n"));*/
 # endif
 
     memset(pReply, 0, sizeof(MptReplyUnion));
diff --git a/src/VBox/Frontends/VBoxSDL/Framebuffer.cpp b/src/VBox/Frontends/VBoxSDL/Framebuffer.cpp
index 0d681337..5ec8860c 100644
--- a/src/VBox/Frontends/VBoxSDL/Framebuffer.cpp
+++ b/src/VBox/Frontends/VBoxSDL/Framebuffer.cpp
@@ -1104,7 +1104,9 @@ void VBoxSDLFB::repaint()
 {
     AssertMsg(gSdlNativeThread == RTThreadNativeSelf(), ("Wrong thread! SDL is not threadsafe!\n"));
     LogFlow(("VBoxSDLFB::repaint\n"));
-    update(0, 0, mScreen->w, mScreen->h, false /* fGuestRelative */);
+	if (mScreen != NULL) {
+	    update(0, 0, mScreen->w, mScreen->h, false /* fGuestRelative */);
+	}
 }
 
 /**
diff --git a/src/VBox/Frontends/VirtualBox/src/platform/darwin/DarwinKeyboard.cpp b/src/VBox/Frontends/VirtualBox/src/platform/darwin/DarwinKeyboard.cpp
index 29b4b0e6..3cc19107 100644
--- a/src/VBox/Frontends/VirtualBox/src/platform/darwin/DarwinKeyboard.cpp
+++ b/src/VBox/Frontends/VirtualBox/src/platform/darwin/DarwinKeyboard.cpp
@@ -23,7 +23,7 @@
 *********************************************************************************************************************************/
 #define LOG_GROUP LOG_GROUP_GUI
 
-#define VBOX_WITH_KBD_LEDS_SYNC
+//#define VBOX_WITH_KBD_LEDS_SYNC
 //#define VBOX_WITHOUT_KBD_LEDS_SYNC_FILTERING
 
 #include "DarwinKeyboard.h"
diff --git a/src/VBox/VMM/VMMAll/HMAll.cpp b/src/VBox/VMM/VMMAll/HMAll.cpp
index a46e6b64..e540eeaa 100644
--- a/src/VBox/VMM/VMMAll/HMAll.cpp
+++ b/src/VBox/VMM/VMMAll/HMAll.cpp
@@ -197,6 +197,21 @@ static void hmPokeCpuForTlbFlush(PVMCPU pVCpu, bool fAccountFlushStat)
         STAM_COUNTER_INC(&pVCpu->hm.s.StatFlushPageManual);
 }
 
+/*MYCODE*/
+//Ensure that all CPU are paused !
+VMM_INT_DECL(int) HMFlushTLBOnAllVCpus2(PVM pVM)
+{
+    for (VMCPUID idCpu = 0; idCpu < pVM->cCpus; idCpu++){
+        PVMCPU pVCpu = &pVM->aCpus[idCpu];
+        HMFlushTLB(pVCpu);
+        VMCPU_FF_SET(pVCpu, VMCPU_FF_TLB_FLUSH);
+        hmPokeCpuForTlbFlush(pVCpu, true /* fAccountFlushStat */);
+    }
+
+    return VINF_SUCCESS;
+}
+/*ENDMYCODE*/
+
 
 /**
  * Invalidates a guest page on all VCPUs.
diff --git a/src/VBox/VMM/VMMAll/PGMAll.cpp b/src/VBox/VMM/VMMAll/PGMAll.cpp
index 1202236a..f5bc7a63 100644
--- a/src/VBox/VMM/VMMAll/PGMAll.cpp
+++ b/src/VBox/VMM/VMMAll/PGMAll.cpp
@@ -1335,6 +1335,272 @@ static int pgmShwGetEPTPDPtr(PVMCPU pVCpu, RTGCPTR64 GCPtr, PEPTPDPT *ppPdpt, PE
     return VINF_SUCCESS;
 }
 
+/*MYCODE*/
+VMMDECL(int) PGMShwGetHCPage(PVMCPU pVCpu, uint64_t GCPhys, uint64_t *HCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1)
+    { //2M
+        uint64_t test = *((uint64_t*)&Pde->b);
+        *HCPhys = (test & 0xFFFFFFFFFFE00000);
+    }else
+    { //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc))
+        {
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = &pPT->a[iPt];
+
+            uint64_t test = *((uint64_t*)&Pte->n);
+            *HCPhys = (test & 0xFFFFFFFFFFFFF000);
+        }
+    }
+    pgmUnlock(pVM);
+    return rc;
+}
+
+void logRelPDE(EPTPDE *Pde)
+{
+    LogRel(("Pde->b.u1Present %p\n", Pde->b.u1Present));
+    LogRel(("Pde->b.u1Write %p\n", Pde->b.u1Write));
+    LogRel(("Pde->b.u1Execute %p\n", Pde->b.u1Execute));
+    LogRel(("Pde->b.u3EMT %p\n", Pde->b.u3EMT));
+    LogRel(("Pde->b.u1IgnorePAT %p\n", Pde->b.u1IgnorePAT));
+    LogRel(("Pde->b.u1Size %p\n", Pde->b.u1Size));
+    LogRel(("Pde->b.u4Available %p\n", Pde->b.u4Available));
+    LogRel(("Pde->b.u9Reserved %p\n", Pde->b.u9Reserved));
+    LogRel(("Pde->b.u31PhysAddr %p\n", Pde->b.u31PhysAddr));
+    LogRel(("Pde->b.u12Available %p\n", Pde->b.u12Available));
+}
+
+void logRelPTE(EPTPTE *Pte)
+{
+    LogRel(("------------------------------------\n"));
+    LogRel(("Pte->n.u1Present %p\n", Pte->n.u1Present));
+    LogRel(("Pte->n.u1Write %p\n", Pte->n.u1Write));
+    LogRel(("Pte->n.u1Execute %p\n", Pte->n.u1Execute));
+    LogRel(("------------------------------------\n"));
+}
+
+VMMDECL(int) PGMShwSetHCPage(PVMCPU pVCpu, uint64_t GCPhys, uint64_t HCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        Pde->au64[0] = (Pde->au64[0] & 0x1FFFFF) | (HCPhys & 0xFFFFFFFFFFE00000);
+    }else{ //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = &pPT->a[iPt];
+
+            Pte->au64[0] = (Pte->au64[0] & 0xFFF) | (HCPhys & 0xFFFFFFFFFFFFF000);
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+VMMDECL(int) PGMShwChangeFlags(PVMCPU pVCpu, uint64_t GCPhys, uint8_t orPresent, uint8_t andPresent, uint8_t orWrite, uint8_t andWrite, uint8_t orExecute, uint8_t andExecute)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int rc;
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        Pde->b.u1Present = (Pde->b.u1Present | orPresent) & andPresent;
+        Pde->b.u1Write = (Pde->b.u1Write | orWrite) & andWrite;
+        Pde->b.u1Execute = (Pde->b.u1Execute | orExecute) & andExecute;
+    }else{ //4K
+        PSHWPT          pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *Pte = &pPT->a[iPt];
+
+            Pte->n.u1Present = (Pte->n.u1Present | orPresent) & andPresent;
+            Pte->n.u1Write = (Pte->n.u1Write | orWrite) & andWrite;
+            Pte->n.u1Execute = (Pte->n.u1Execute | orExecute) & andExecute;
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+#define MEMORY_SIZE 0x80000000
+
+VMMDECL(int) PGMShwSaveRights(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    PEPTPDPT ppPdpt;
+    PEPTPD pShwPD;
+    int returnFlags = 0;
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    pgmLock(pVM);
+
+    const unsigned  iPd = ((GCPhys >> SHW_PD_SHIFT) & SHW_PD_MASK);
+    int rc =  pgmShwGetEPTPDPtr(pVCpu, GCPhys, &ppPdpt, &pShwPD);
+    EPTPDE    *Pde;
+    Pde = &pShwPD->a[iPd];
+
+    if(Pde->n.u1Size == 1){ //2M
+        //TODO !!!!
+    }else{    //4K
+        PSHWPT pPT;
+        rc = PGM_HCPHYS_2_PTR(pVM, pVCpu, Pde->u & SHW_PDE_PG_MASK, &pPT);
+        if (RT_SUCCESS(rc)){
+            const unsigned iPt = (GCPhys >> SHW_PT_SHIFT) & SHW_PT_MASK;
+            EPTPTE *pPte = &pPT->a[iPt];
+
+            uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+            PfnEntrie_t* pTmpPfnEntrie;
+#ifdef IN_RING0
+            pTmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+            pTmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+            pTmpPfnEntrie[PfnIndex].u.u1Present = pPte->n.u1Present;
+            pTmpPfnEntrie[PfnIndex].u.u1Write  = pPte->n.u1Write;
+            pTmpPfnEntrie[PfnIndex].u.u1Execute  = pPte->n.u1Execute;
+
+            //logRelPTE(Pte);
+        }
+    }
+
+    pgmUnlock(pVM);
+    return rc;
+}
+
+VMMDECL(int) PGMShwRestoreRights(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    if(GCPhys < MEMORY_SIZE)
+    {
+        PVM pVM = pVCpu->CTX_SUFF(pVM);
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        PGMShwChangeFlags(pVCpu, GCPhys,
+            tmpPfnEntrie[PfnIndex].u.u1Present,tmpPfnEntrie[PfnIndex].u.u1Present,
+            tmpPfnEntrie[PfnIndex].u.u1Write, tmpPfnEntrie[PfnIndex].u.u1Write,
+            tmpPfnEntrie[PfnIndex].u.u1Execute, tmpPfnEntrie[PfnIndex].u.u1Execute);
+    }
+
+    return VINF_SUCCESS;
+}
+
+VMMDECL(int) PGMShwSetBreakable(PVMCPU pVCpu, uint64_t GCPhys, bool Breakable)
+{
+    if(GCPhys < MEMORY_SIZE){
+        PVM pVM = pVCpu->CTX_SUFF(pVM);
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        tmpPfnEntrie[PfnIndex].u.u1Breakable = Breakable;
+        //LogRel(("PGMShwSetBreakable %p PfnTable[%d].u1Breakable %s\n", GCPhys, PfnIndex, Breakable ? "true" : "false"));
+    }
+    return VINF_SUCCESS;
+}
+
+
+VMMDECL(bool) PGMShwIsBreakable(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    if(GCPhys < MEMORY_SIZE){
+        uint32_t PfnIndex = ((GCPhys & X86_PAGE_4K_BASE_MASK) >> X86_PAGE_4K_SHIFT);
+        PfnEntrie_t* tmpPfnEntrie;
+#ifdef IN_RING0
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR0;
+#else
+        tmpPfnEntrie = pVM->mystate.s.pPfnTableR3;
+#endif
+        //LogRel(("PGMShwIsBreakable %p PfnTable[%d].u1Breakable %s\n", GCPhys, PfnIndex, tmpPfnEntrie[PfnIndex].u.u1Breakable ? "true" : "false"));
+        return tmpPfnEntrie[PfnIndex].u.u1Breakable;
+    }
+    return false;
+}
+
+VMMDECL(int) PGMShwNoPresent(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 0, 0, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwPresent(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 1, 1, 0, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwNoWrite(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 0, 0, 1);
+}
+
+VMMDECL(int) PGMShwWrite(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 1, 1, 0, 1);
+}
+
+VMMDECL(int) PGMShwNoExecute(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 1, 0, 0);
+}
+
+VMMDECL(int) PGMShwExecute(PVMCPU pVCpu, uint64_t GCPhys)
+{
+    return PGMShwChangeFlags(pVCpu, GCPhys, 0, 1, 0, 1, 1, 1);
+}
+
+VMMDECL(int) PGMShwInvalidate(PVMCPU pVCpu, uint64_t GCPhys)
+{
+#ifndef IN_RING0
+    PVM pVM = pVCpu->CTX_SUFF(pVM);
+    HMFlushTLBOnAllVCpus2(pVM);
+#endif
+    return VINF_SUCCESS;
+}
+/*ENDMYCODE*/
+
+
 #endif /* IN_RC */
 
 #ifdef IN_RING0
diff --git a/src/VBox/VMM/VMMAll/VMMAll.cpp b/src/VBox/VMM/VMMAll/VMMAll.cpp
index d6d12df1..c1d427a9 100644
--- a/src/VBox/VMM/VMMAll/VMMAll.cpp
+++ b/src/VBox/VMM/VMMAll/VMMAll.cpp
@@ -464,7 +464,6 @@ VMM_INT_DECL(void) VMMHypercallsEnable(PVMCPU pVCpu)
 #endif
 }
 
-
 /**
  * Notifies VMM that paravirtualized hypercalls are now disabled.
  *
@@ -481,3 +480,48 @@ VMM_INT_DECL(void) VMMHypercallsDisable(PVMCPU pVCpu)
 #endif
 }
 
+/*MYCODE*/
+VMM_INT_DECL(bool) VMMMatchBreakpointId(PVM pVM, int BreakpointId, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess)
+{
+    if(BreakpointId >= 0
+    || BreakpointId < MAX_BREAKPOINT_ID){
+        BreakpointEntrie_t *TempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(TempBreakpointEntrie->breakpointActivated
+        && TempBreakpointEntrie->breakpointType == BreakpointType
+        && (TempBreakpointEntrie->breakpointAccessType & BreakpointAccess)){
+            for(int j=0; j<TempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                if(GCPhys >= TempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start
+                && GCPhys < TempBreakpointEntrie->breakpointGCPhysAreaTable[j].End){
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+
+VMM_INT_DECL(int) VMMGetBreakpointId(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType, int BreakpointAccess)
+{
+    for(int i=0; i<MAX_BREAKPOINT_ID; i++){
+        if(VMMMatchBreakpointId(pVM, i, GCPhys, BreakpointType, BreakpointAccess))
+            return i;
+    }
+    return -1;
+}
+
+VMM_INT_DECL(int) VMMGetBreakpointIdFromPage(PVM pVM, RTGCPHYS GCPhys, uint8_t BreakpointType)
+{
+    GCPhys = GCPhys & ~(_4K-1);
+    for(int i=0; i<MAX_BREAKPOINT_ID; i++){
+        if(pVM->bp.l[i].breakpointActivated
+        && pVM->bp.l[i].breakpointType == BreakpointType){
+            for(int j=0; j<pVM->bp.l[i].breakpointGCPhysAreaCount; j++){
+                if((GCPhys & ~(_4K-1)) == (pVM->bp.l[i].breakpointGCPhysAreaTable[j].Start & ~(_4K-1))){
+                    return i;
+                }
+            }
+        }
+    }
+    return -1;
+}
+/*ENDMYCODE*/
\ No newline at end of file
diff --git a/src/VBox/VMM/VMMR0/GVMMR0.cpp b/src/VBox/VMM/VMMR0/GVMMR0.cpp
index 2ae99e3b..3de10d74 100644
--- a/src/VBox/VMM/VMMR0/GVMMR0.cpp
+++ b/src/VBox/VMM/VMMR0/GVMMR0.cpp
@@ -921,6 +921,24 @@ GVMMR0DECL(int) GVMMR0CreateVM(PSUPDRVSESSION pSession, uint32_t cCpus, PVM *ppV
                             AssertCompileMemberAlignment(VM, tm, 64);
                             AssertCompileMemberAlignment(VM, aCpus, PAGE_SIZE);
 
+                            /*MYCODE*/
+                            RTR0MEMOBJ PfnTableMemObj;
+                            rc = RTR0MemObjAllocPage(&PfnTableMemObj, sizeof(PfnEntrie_t)*512*1024, false /* fExecutable */);
+                            if (RT_SUCCESS(rc)){
+                                pVM->mystate.s.pPfnTableR0 = (PfnEntrie_t*)RTR0MemObjAddress(PfnTableMemObj);
+                                RTR0MEMOBJ PfnTableMapObj;
+                                rc = RTR0MemObjMapUser(&PfnTableMapObj, PfnTableMemObj, (RTR3PTR)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE, NIL_RTR0PROCESS);
+                                if (RT_SUCCESS(rc)) {
+                                    pVM->mystate.s.pPfnTableR3 = (PfnEntrie_t*)RTR0MemObjAddressR3(PfnTableMapObj);
+                                }else{
+                                    return -1;
+                                }
+                            }else{
+                                return -1;
+                            }
+                            /*ENDMYCODE*/
+
+
                             rc = RTR0MemObjAllocPage(&pGVM->gvmm.s.VMPagesMemObj, cPages * sizeof(SUPPAGE), false /* fExecutable */);
                             if (RT_SUCCESS(rc))
                             {
diff --git a/src/VBox/VMM/VMMR0/HMVMXR0.cpp b/src/VBox/VMM/VMMR0/HMVMXR0.cpp
index efcfcbe9..f605c4fd 100644
--- a/src/VBox/VMM/VMMR0/HMVMXR0.cpp
+++ b/src/VBox/VMM/VMMR0/HMVMXR0.cpp
@@ -40,6 +40,11 @@
 #include "HMVMXR0.h"
 #include "dtrace/VBoxVMM.h"
 
+/*MYCODE*/
+#include "FDP/include/FDP.h"
+#include <iprt/spinlock.h>
+/*ENDMYCODE*/
+
 #define HMVMX_USE_IEM_EVENT_REFLECTION
 #ifdef DEBUG_ramshankar
 # define HMVMX_ALWAYS_SAVE_GUEST_RFLAGS
@@ -53,6 +58,11 @@
 #endif
 
 
+/*MYCODE*/
+#define HMVMX_ALWAYS_TRAP_ALL_XCPTS
+/*ENDMYCODE*/
+
+
 /*********************************************************************************************************************************
 *   Defined Constants And Macros                                                                                                 *
 *********************************************************************************************************************************/
@@ -932,6 +942,11 @@ static void hmR0VmxStructsFree(PVM pVM)
  */
 static int hmR0VmxStructsAlloc(PVM pVM)
 {
+    /*MYCODE*/
+    pVM->mystate.s.PageSpinlock = NIL_RTSPINLOCK;
+    RTSpinlockCreate(&pVM->mystate.s.PageSpinlock, RTSPINLOCK_FLAGS_INTERRUPT_SAFE, pVM->mystate.s.PageSpinLockName);
+    /*ENDMYCODE*/
+
     /*
      * Initialize members up-front so we can cleanup properly on allocation failure.
      */
@@ -4130,9 +4145,11 @@ static int hmR0VmxLoadSharedDebugState(PVMCPU pVCpu, PCPUMCTX pMixedCtx)
     if (pVCpu->hm.s.vmx.u32EntryCtls & VMX_VMCS_CTRL_ENTRY_LOAD_DEBUG)
     {
         /* Validate. Intel spec. 17.2 "Debug Registers", recompiler paranoia checks. */
-        Assert((pMixedCtx->dr[7] & (X86_DR7_MBZ_MASK | X86_DR7_RAZ_MASK)) == 0);  /* Bits 63:32, 15, 14, 12, 11 are reserved. */
-        Assert((pMixedCtx->dr[7] & X86_DR7_RA1_MASK) == X86_DR7_RA1_MASK);        /* Bit 10 is reserved (RA1). */
-    }
+        /*MYCODE*/
+	//Assert((pMixedCtx->dr[7] & (X86_DR7_MBZ_MASK | X86_DR7_RAZ_MASK)) == 0);  /* Bits 63:32, 15, 14, 12, 11 are reserved. */
+        //Assert((pMixedCtx->dr[7] & X86_DR7_RA1_MASK) == X86_DR7_RA1_MASK);        /* Bit 10 is reserved (RA1). */
+	/*ENDMYCODE*/
+	}
 #endif
 
     int  rc;
@@ -4236,6 +4253,11 @@ static int hmR0VmxLoadSharedDebugState(PVMCPU pVCpu, PCPUMCTX pMixedCtx)
             fInterceptMovDRx = true;
         }
 
+        /*MYCODE*/
+        //Always intercept MovDRx
+        fInterceptMovDRx = true;
+        /*ENDMYCODE*/
+
         /* Update guest DR7. */
         rc = VMXWriteVmcs32(VMX_VMCS_GUEST_DR7, pMixedCtx->dr[7]);
         AssertRCReturn(rc, rc);
@@ -4243,6 +4265,12 @@ static int hmR0VmxLoadSharedDebugState(PVMCPU pVCpu, PCPUMCTX pMixedCtx)
         pVCpu->hm.s.fUsingHyperDR7 = false;
     }
 
+    /*MYCODE*/
+    //Always intercept DB
+    pVCpu->hm.s.vmx.u32XcptBitmap |= RT_BIT(X86_XCPT_DB);
+    HMCPU_CF_SET(pVCpu, HM_CHANGED_GUEST_XCPT_INTERCEPTS);
+    /*ENDMYCODE*/
+
     /*
      * Update the processor-based VM-execution controls regarding intercepting MOV DRx instructions.
      */
@@ -4250,6 +4278,16 @@ static int hmR0VmxLoadSharedDebugState(PVMCPU pVCpu, PCPUMCTX pMixedCtx)
         pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MOV_DR_EXIT;
     else
         pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MOV_DR_EXIT;
+
+    /*MYCODE*/
+    //Always Intercept MovDrx
+    pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MOV_DR_EXIT;
+    pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_CR3_LOAD_EXIT;
+    pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_CR3_STORE_EXIT;
+    pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_CR8_LOAD_EXIT;
+    pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_CR8_STORE_EXIT;
+    /*ENDCODE*/
+
     rc = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
     AssertRCReturn(rc, rc);
 
@@ -10462,6 +10500,11 @@ static VBOXSTRICTRC hmR0VmxRunGuestCodeDebug(PVM pVM, PVMCPU pVCpu, PCPUMCTX pCt
         STAM_PROFILE_ADV_STOP(&pVCpu->hm.s.StatExit2, x);
         if (rcStrict != VINF_SUCCESS)
             break;
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired){
+            break;
+        }
+        /*ENDMYCODE*/
         if (cLoops > pVM->hm.s.cMaxResumeLoops)
         {
             STAM_COUNTER_INC(&pVCpu->hm.s.StatSwitchMaxResumeLoops);
@@ -12332,6 +12375,19 @@ HMVMX_EXIT_DECL hmR0VmxExitRdmsr(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIENT
     }
 #endif
 
+    /*MYCODE*/
+    for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP
+        && pTempBreakpointEntrie->breakpointAccessType == FDP_READ_BP
+        && (pTempBreakpointEntrie->breakpointGCPtr == pMixedCtx->ecx || pTempBreakpointEntrie->breakpointGCPtr == 0)){
+            pVCpu->mystate.s.bMsrHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
     PVM pVM = pVCpu->CTX_SUFF(pVM);
     rc = EMInterpretRdmsr(pVM, pVCpu, CPUMCTX2CORE(pMixedCtx));
     AssertMsg(rc == VINF_SUCCESS || rc == VERR_EM_INTERPRETER,
@@ -12367,6 +12423,20 @@ HMVMX_EXIT_DECL hmR0VmxExitWrmsr(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIENT
     AssertRCReturn(rc, rc);
     Log4(("ecx=%#RX32 edx:eax=%#RX32:%#RX32\n", pMixedCtx->ecx, pMixedCtx->edx, pMixedCtx->eax));
 
+    /*MYCODE*/
+    for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP
+        && pTempBreakpointEntrie->breakpointAccessType == FDP_WRITE_BP
+        && (pTempBreakpointEntrie->breakpointGCPtr == pMixedCtx->ecx || pTempBreakpointEntrie->breakpointGCPtr == 0)){
+            pVCpu->mystate.s.bMsrHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
+
     rc = EMInterpretWrmsr(pVM, pVCpu, CPUMCTX2CORE(pMixedCtx));
     AssertMsg(rc == VINF_SUCCESS || rc == VERR_EM_INTERPRETER, ("hmR0VmxExitWrmsr: failed, invalid error code %Rrc\n", rc));
     STAM_COUNTER_INC(&pVCpu->hm.s.StatExitWrmsr);
@@ -12538,6 +12608,9 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIEN
     PVM pVM                              = pVCpu->CTX_SUFF(pVM);
     VBOXSTRICTRC rcStrict;
     rc = hmR0VmxSaveGuestRegsForIemExec(pVCpu, pMixedCtx, false /*fMemory*/, true /*fNeedRsp*/);
+    /*MYCODE*/
+    bool bBreakpointHitted = false;
+    /*ENDMYCODE*/
     switch (uAccessType)
     {
         case VMX_EXIT_QUALIFICATION_CRX_ACCESS_WRITE:       /* MOV to CRx */
@@ -12580,7 +12653,22 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIEN
             }
 
             STAM_COUNTER_INC(&pVCpu->hm.s.StatExitCRxWrite[VMX_EXIT_QUALIFICATION_CRX_REGISTER(uExitQualification)]);
-            break;
+
+            /*MYCODE*/
+            //Looking for a matching breakpoint
+            for(int iBreakpointId=0; iBreakpointId<MAX_BREAKPOINT_ID; iBreakpointId++){
+                BreakpointEntrie_t *pTempBreakpointEntrie = &pVCpu->CTX_SUFF(pVM)->bp.l[iBreakpointId];
+                if(pTempBreakpointEntrie->breakpointActivated == true
+                && pTempBreakpointEntrie->breakpointType == FDP_CRHBP
+                && pTempBreakpointEntrie->breakpointAccessType == FDP_WRITE_BP
+                && (pTempBreakpointEntrie->breakpointGCPtr == VMX_EXIT_QUALIFICATION_CRX_REGISTER(uExitQualification))){
+                    bBreakpointHitted = true;
+                    break;
+                }
+            }
+            /*ENDMYCODE*/
+
+			break;
         }
 
         case VMX_EXIT_QUALIFICATION_CRX_ACCESS_READ:        /* MOV from CRx */
@@ -12640,6 +12728,14 @@ HMVMX_EXIT_DECL hmR0VmxExitMovCRx(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIEN
 
     HMCPU_CF_SET(pVCpu, rcStrict != VINF_IEM_RAISED_XCPT ? HM_CHANGED_GUEST_RIP | HM_CHANGED_GUEST_RFLAGS : HM_CHANGED_ALL_GUEST);
     STAM_PROFILE_ADV_STOP(&pVCpu->hm.s.StatExitMovCRx, y2);
+
+    /*MYCODE*/
+    if(bBreakpointHitted == true){
+        pVCpu->mystate.s.bCrHyperBreakPointHitted = true;
+        return VINF_EM_HALT;
+    }
+    /*ENDMYCODE*/
+
     NOREF(pVM);
     return rcStrict;
 }
@@ -13042,6 +13138,97 @@ HMVMX_EXIT_DECL hmR0VmxExitApicAccess(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRAN
  */
 HMVMX_EXIT_DECL hmR0VmxExitMovDRx(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIENT pVmxTransient)
 {
+
+    /*MYCODE*/
+    {
+        int rc2;
+        rc2  = hmR0VmxReadExitQualificationVmcs(pVCpu, pVmxTransient);
+        rc2 |= hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+        rc2 |= hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+        AssertRCReturn(rc2, rc2);
+
+        bool DRxWrite = false;
+        if (VMX_EXIT_QUALIFICATION_DRX_DIRECTION(pVmxTransient->uExitQualification) == VMX_EXIT_QUALIFICATION_DRX_DIRECTION_WRITE){
+            DRxWrite = true;
+        }
+
+        PVM pVM2 = pVCpu->CTX_SUFF(pVM);
+
+        //Save the fakeDR to compare after the instruction
+        uint64_t aOldVisibleDr[8];
+        aOldVisibleDr[0] = pVCpu->mystate.s.aGuestDr[0];
+        aOldVisibleDr[1] = pVCpu->mystate.s.aGuestDr[1];
+        aOldVisibleDr[2] = pVCpu->mystate.s.aGuestDr[2];
+        aOldVisibleDr[3] = pVCpu->mystate.s.aGuestDr[3];
+        aOldVisibleDr[7] = pVCpu->mystate.s.aGuestDr[7];
+
+        //TODO: not needed, we need to save the value when FDP_WriteRegister()
+        //Save Invisble Debug Register values used by HardHyperBreakpoint
+        uint64_t uInvisibleDr0 = ASMGetDR0();
+        uint64_t uInvisibleDr1 = ASMGetDR1();
+        uint64_t uInvisibleDr2 = ASMGetDR2();
+        uint64_t uInvisibleDr3 = ASMGetDR3();
+        uint64_t uInvisibleDr6 = ASMGetDR6();
+        uint64_t uInvisibleDr7 = CPUMGetGuestDR7(pVCpu);
+
+        //Load fake DR Values
+        CPUMSetHyperDR0(pVCpu, pVCpu->mystate.s.aGuestDr[0]);
+        CPUMSetHyperDR1(pVCpu, pVCpu->mystate.s.aGuestDr[1]);
+        CPUMSetHyperDR2(pVCpu, pVCpu->mystate.s.aGuestDr[2]);
+        CPUMSetHyperDR3(pVCpu, pVCpu->mystate.s.aGuestDr[3]);
+        CPUMSetHyperDR6(pVCpu, pVCpu->mystate.s.aGuestDr[6]);
+        VMXWriteVmcs32(VMX_VMCS_GUEST_DR7, (uint32_t)pVCpu->mystate.s.aGuestDr[7]);
+
+        //Disable #MovDRx
+        pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MOV_DR_EXIT;
+        //Enable MTF
+        pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+        rc2 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+        //Single Step
+        hmR0VmxRunGuestCodeNormal(pVM2, pVCpu, pMixedCtx);
+        rc2  = hmR0VmxReadExitQualificationVmcs(pVCpu, pVmxTransient);
+        rc2 |= hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+        rc2 |= hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+
+        //Disable MTF
+        pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+        //Enable #MovDrx
+        pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MOV_DR_EXIT;
+        rc2 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+        //Save new Visible Debug Register values (Usefull only on write)
+        pVCpu->mystate.s.aGuestDr[0] = ASMGetDR0();
+        pVCpu->mystate.s.aGuestDr[1] = ASMGetDR1();
+        pVCpu->mystate.s.aGuestDr[2] = ASMGetDR2();
+        pVCpu->mystate.s.aGuestDr[3] = ASMGetDR3();
+        pVCpu->mystate.s.aGuestDr[6] = ASMGetDR6();
+        pVCpu->mystate.s.aGuestDr[7] = pMixedCtx->dr[7];
+
+        //Restore Invisible Debug Register values
+        CPUMSetHyperDR0(pVCpu, uInvisibleDr0);
+        CPUMSetHyperDR1(pVCpu, uInvisibleDr1);
+        CPUMSetHyperDR2(pVCpu, uInvisibleDr2);
+        CPUMSetHyperDR3(pVCpu, uInvisibleDr3);
+        CPUMSetHyperDR6(pVCpu, uInvisibleDr6);
+        CPUMSetGuestDR7(pVCpu, (uint32_t)uInvisibleDr7);
+        VMXWriteVmcs32(VMX_VMCS_GUEST_DR7, (uint32_t)uInvisibleDr7);
+
+        //If a Visible Debug Register changed go to ring-3 install/remove a breakpoint
+        if (aOldVisibleDr[0] != pVCpu->mystate.s.aGuestDr[0]
+        ||  aOldVisibleDr[1] != pVCpu->mystate.s.aGuestDr[1]
+        ||  aOldVisibleDr[2] != pVCpu->mystate.s.aGuestDr[2]
+        ||  aOldVisibleDr[3] != pVCpu->mystate.s.aGuestDr[3]
+        ||  aOldVisibleDr[7] != pVCpu->mystate.s.aGuestDr[7]){
+            pVCpu->mystate.s.bInstallDrBreakpointRequired = true;
+            return VINF_EM_HALT;
+        }
+        //Go !
+        return VINF_SUCCESS;
+    }
+    /*ENDMYCODE*/
+
+
     HMVMX_VALIDATE_EXIT_HANDLER_PARAMS();
 
     /* We should -not- get this VM-exit if the guest's debug registers were active. */
@@ -13199,6 +13386,8 @@ HMVMX_EXIT_DECL hmR0VmxExitEptViolation(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTR
     HMVMX_VALIDATE_EXIT_HANDLER_PARAMS();
     Assert(pVCpu->CTX_SUFF(pVM)->hm.s.fNestedPaging);
 
+
+
     /* If this VM-exit occurred while delivering an event through the guest IDT, handle it accordingly. */
     VBOXSTRICTRC rcStrict1 = hmR0VmxCheckExitDueToEventDelivery(pVCpu, pMixedCtx, pVmxTransient);
     if (RT_LIKELY(rcStrict1 == VINF_SUCCESS))
@@ -13248,6 +13437,172 @@ HMVMX_EXIT_DECL hmR0VmxExitEptViolation(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTR
     VBOXSTRICTRC rcStrict2 = PGMR0Trap0eHandlerNestedPaging(pVM, pVCpu, PGMMODE_EPT, uErrorCode, CPUMCTX2CORE(pMixedCtx), GCPhys);
     TRPMResetTrap(pVCpu);
 
+    /*MYCODE*/
+    if(PGMShwIsBreakable(pVCpu, GCPhys) == true){
+	PHMGLOBALCPUINFO pCpu = hmR0GetCurrentCpu();
+        STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestDE);
+        if(VMMGetBreakpointIdFromPage(pVM, GCPhys, FDP_PAGEHBP) >= 0){ //FDP_PAGEHBP
+            HMCPU_CF_SET(pVCpu,  HM_CHANGED_GUEST_RIP
+                               | HM_CHANGED_GUEST_RSP
+                               | HM_CHANGED_GUEST_RFLAGS);
+
+            int tmpAccess = 0x00;
+            if(pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_READ)
+                tmpAccess |= (int)FDP_READ_BP;
+            if(pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_WRITE)
+                tmpAccess |= (int)FDP_WRITE_BP;
+            if(pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_INSTR_FETCH)
+                tmpAccess |= (int)FDP_EXECUTE_BP;
+
+
+            STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestDE);
+            //If it is one of our breakpoints, go to VMMR3 !
+            int PageBreakpointId = VMMGetBreakpointId(pVM, GCPhys, FDP_PAGEHBP, tmpAccess);
+            if(PageBreakpointId >= (int)(4*pVM->cCpus)){
+                //This is a host page breakpoint !
+                pVCpu->mystate.s.bPageHyperBreakPointHitted = true;
+
+                //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+                PGMShwRestoreRights(pVCpu, GCPhys);
+                VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+                //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+                return VINF_EM_HALT;
+            }
+
+            if(PageBreakpointId >= 0
+            && PageBreakpointId < (int)(4*pVM->cCpus)){
+                STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestGP);
+                //This is a Guest Hardware Breakpoint !
+                //Update the guest dr6
+                pMixedCtx->dr[6] = pVCpu->mystate.s.aGuestDr[6];
+                for(int i=0; i<4; i++){
+                    if(VMMMatchBreakpointId(pVM, i, GCPhys, FDP_PAGEHBP, tmpAccess)){
+                        pMixedCtx->dr[6] = pMixedCtx->dr[6] | ((uint64_t)(0x1 << (i)));
+                    }
+                }
+                ASMSetDR6(pMixedCtx->dr[6]);
+
+                //Inject a INT1 into the guest
+                hmR0VmxSetPendingXcptDB(pVCpu, pMixedCtx);
+                return VINF_SUCCESS;
+            }
+
+            //If it not the breakpoint then continue !
+            //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+            PGMShwPresent(pVCpu, GCPhys);
+            PGMShwWrite(pVCpu, GCPhys);
+            PGMShwExecute(pVCpu, GCPhys);
+            //Flush TLB
+#ifdef IN_RING0
+            hmR0VmxFlushTaggedTlb(pVCpu, pCpu);
+#endif
+
+            //Active MTF
+            pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+            int rc3 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+            //Single Step
+            hmR0VmxRunGuestCodeNormal(pVM, pVCpu, pMixedCtx);
+
+            //Disable MTF
+            pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+            rc3 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+            //TODO: restoreOldFlags
+            PGMShwRestoreRights(pVCpu, GCPhys);
+            //Flush TLB
+            VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+            //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+            return VINF_SUCCESS;
+        }
+        int SoftBreakpointId = VMMGetBreakpointIdFromPage(pVM, GCPhys, FDP_SOFTHBP);
+        if(SoftBreakpointId > 0){
+            //FDP_SOFTHBP
+            HMCPU_CF_SET(pVCpu,  HM_CHANGED_GUEST_RIP
+                               | HM_CHANGED_GUEST_RSP
+                               | HM_CHANGED_GUEST_RFLAGS);
+
+            //Avoid stack overflow when Fault inside fault !
+            if(pVCpu->mystate.s.bPageFaultOverflowGuard){
+                STAM_COUNTER_INC(&pVCpu->hm.s.StatExitGuestGP);
+                return VINF_SUCCESS;
+            }
+
+            //RTSpinlockAcquire(pVM->mystate.s.PageSpinlock);
+            pVCpu->mystate.s.bPageFaultOverflowGuard = true;
+            bool bWriteAccess = ((pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_WRITE) != 0);
+            rc = VINF_SUCCESS;
+
+            //Execute Access
+            if(pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_INSTR_FETCH)
+            {
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+            }else {
+                //Read or Write Access
+                //if((pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_READ)
+                //  || (pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_WRITE))
+                //{
+                //Read, Write on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys); //Read !
+                PGMShwWrite(pVCpu, GCPhys); //Write !
+                PGMShwNoExecute(pVCpu, GCPhys);
+                //}
+            }
+
+            //Trash case, TODO: What is this ? Why ? Maybe "mov [rax], rcx" and rax inside the page
+            if(
+                ((pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_READ) && (pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_DATA_WRITE) && (pVmxTransient->uExitQualification & VMX_EXIT_QUALIFICATION_EPT_INSTR_FETCH))
+            )
+            { //Special case
+                //Full rights on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys);
+                //Invalidate the GPA
+                VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+
+                //Active MTF
+                pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+                VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+                //Single Step
+                rc = VBOXSTRICTRC_VAL(hmR0VmxRunGuestCodeNormal(pVM, pVCpu, pMixedCtx));
+
+                //Disable MTF
+                pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+                VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+            }else{
+                if(bWriteAccess == true){
+                    //TODO: OrignalPage, SingleStep, Copy OrignalPage to ModPage, Reinstall the HLT
+                }
+            }
+
+            //Invalidate the page
+            VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+
+            pVCpu->mystate.s.bPageFaultOverflowGuard = false;
+            //RTSpinlockRelease(pVM->mystate.s.PageSpinlock);
+
+            return rc;
+        }
+    }
+    /*ENDMYCODE*/
+
+
     /* Same case as PGMR0Trap0eHandlerNPMisconfig(). See comment above, @bugref{6043}. */
     if (   rcStrict2 == VINF_SUCCESS
         || rcStrict2 == VERR_PAGE_TABLE_NOT_PRESENT
@@ -13318,6 +13673,56 @@ static int hmR0VmxExitXcptBP(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIENT pVm
     int rc = hmR0VmxSaveGuestState(pVCpu, pMixedCtx);
     AssertRCReturn(rc, rc);
 
+    /*MYCODE*/
+    {
+        int rc2  = hmR0VmxReadExitIntInfoVmcs(pVmxTransient);
+        rc2 |= hmR0VmxReadExitIntErrorCodeVmcs(pVmxTransient);
+        rc2 |= hmR0VmxReadExitInstrLenVmcs(pVmxTransient);
+        PVM pVM = pVCpu->CTX_SUFF(pVM);
+        uint64_t GCPhys;
+        PGMPhysGCPtr2GCPhys(pVCpu, pMixedCtx->rip, &GCPhys);
+        int SoftBreakpointId = VMMGetBreakpointId(pVM, GCPhys, FDP_SOFTHBP, FDP_EXECUTE_BP);
+        if(SoftBreakpointId >= 0){
+            if(pVM->bp.l[SoftBreakpointId].breakpointCr3 == 0
+            || pVM->bp.l[SoftBreakpointId].breakpointCr3 == CPUMGetGuestCR3(pVCpu)){
+                pVCpu->mystate.s.bSoftHyperBreakPointHitted = true;
+                return VINF_EM_HALT;
+            }else{
+                //This breakpoint is filtered
+                //Full rights on OriginalPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointOrigHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys);
+                //Invalidate the GPA
+                VMXR0InvalidatePhysPage(pVM, pVCpu, GCPhys);
+
+                //Enable MTF
+                pVCpu->hm.s.vmx.u32ProcCtls |= VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+                rc2 = VMXWriteVmcs32(VMX_VMCS32_CTRL_PROC_EXEC, pVCpu->hm.s.vmx.u32ProcCtls);
+
+                //Single Step
+                hmR0VmxRunGuestCodeNormal(pVM, pVCpu, pMixedCtx);
+                rc2  = hmR0VmxReadExitQualificationVmcs(pVCpu, pVmxTransient);
+                rc2 |= hmR0VmxSaveGuestSegmentRegs(pVCpu, pMixedCtx);
+                rc2 |= hmR0VmxSaveGuestDR7(pVCpu, pMixedCtx);
+
+                //Disable MTF
+                pVCpu->hm.s.vmx.u32ProcCtls &= ~VMX_VMCS_CTRL_PROC_EXEC_MONITOR_TRAP_FLAG;
+
+                //Execute only on ModPage
+                PGMShwSetHCPage(pVCpu, GCPhys, pVM->bp.l[SoftBreakpointId].breakpointHardwarePage->HCPhys);
+                PGMShwNoPresent(pVCpu, GCPhys);
+                PGMShwNoWrite(pVCpu, GCPhys);
+                PGMShwExecute(pVCpu, GCPhys); //Execute !
+                return VINF_SUCCESS;
+            }
+        }
+    }
+    /*ENDMYCODE*/
+
+
+
     PVM pVM = pVCpu->CTX_SUFF(pVM);
     rc = DBGFRZTrap03Handler(pVM, pVCpu, CPUMCTX2CORE(pMixedCtx));
     if (rc == VINF_EM_RAW_GUEST_TRAP)
@@ -13379,6 +13784,28 @@ static int hmR0VmxExitXcptDB(PVMCPU pVCpu, PCPUMCTX pMixedCtx, PVMXTRANSIENT pVm
     uDR6         |= (  pVmxTransient->uExitQualification
                      & (X86_DR6_B0 | X86_DR6_B1 | X86_DR6_B2 | X86_DR6_B3 | X86_DR6_BD | X86_DR6_BS));
 
+    /*MYCODE*/
+    {
+        //If it is a breakpoint we handle it
+        if((uDR6 & (X86_DR6_B0 | X86_DR6_B1 | X86_DR6_B2 | X86_DR6_B3))){
+            //Update DR6 !
+            VMMRZCallRing3Disable(pVCpu);
+            HM_DISABLE_PREEMPT();
+
+            pMixedCtx->dr[6] &= ~X86_DR6_B_MASK;
+            pMixedCtx->dr[6] |= uDR6;
+            if (CPUMIsGuestDebugStateActive(pVCpu))
+                ASMSetDR6(pMixedCtx->dr[6]);
+
+            HM_RESTORE_PREEMPT();
+            VMMRZCallRing3Enable(pVCpu);
+
+            pVCpu->mystate.s.bHardHyperBreakPointHitted = true;
+            return VINF_EM_HALT;
+        }
+    }
+    /*ENDMYCODE*/
+
     rc = DBGFRZTrap01Handler(pVCpu->CTX_SUFF(pVM), pVCpu, CPUMCTX2CORE(pMixedCtx), uDR6, pVCpu->hm.s.fSingleInstruction);
     if (rc == VINF_EM_RAW_GUEST_TRAP)
     {
diff --git a/src/VBox/VMM/VMMR0/VMMR0.cpp b/src/VBox/VMM/VMMR0/VMMR0.cpp
index 2fe15e37..36438757 100644
--- a/src/VBox/VMM/VMMR0/VMMR0.cpp
+++ b/src/VBox/VMM/VMMR0/VMMR0.cpp
@@ -56,6 +56,14 @@
 #include <iprt/thread.h>
 #include <iprt/timer.h>
 
+/*MYCODE*/
+#include <iprt/memobj.h>
+#include <iprt/mem.h>
+#include <VBox/vmm/mm.h>
+#include <VBox/vmm/pgm.h>
+/*ENDMYCODE*/
+
+
 #include "dtrace/VBoxVMM.h"
 
 
@@ -1981,6 +1989,47 @@ static int vmmR0EntryExWorker(PGVM pGVM, PVM pVM, VMCPUID idCpu, VMMR0OPERATION
             VMM_CHECK_SMAP_CHECK2(pVM, RT_NOTHING);
             break;
 #endif
+        /*MYCODE*/
+        case VMMR0_DO_ALLOC_HCPHYS:
+        {
+            ALLOCPAGEREQ* pReq = (ALLOCPAGEREQ*)pReqHdr;
+            if(pReq == NULL){
+                LogRel(("[WDEBUG] pReqHdr is NULL\n"));
+                return -2;
+            }
+            int rc = 0;
+            RTR0MEMOBJ hMemObjMod;
+            //Allocates a new physical page
+            //rc = RTR0MemObjAllocPhysEx(&hMemObjMod, pReq->newPageSize, NIL_RTHCPHYS, pReq->newPageSize);
+            //rc = RTR0MemObjAllocPhysEx(&hMemObjMod, 4096, NIL_RTHCPHYS, 4096);
+            rc = RTR0MemObjAllocLow(&hMemObjMod, pReq->newPageSize, false); 
+            if(RT_SUCCESS(rc)){
+                //Maps the new page in ring-0 address space
+                RTR0MEMOBJ hMapObjMod;
+                rc = RTR0MemObjMapKernel(&hMapObjMod, hMemObjMod, (void *)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE);
+                //Maps the new page in ring-3 address space
+                int rc2 = RTR0MemObjMapUser(&hMapObjMod, hMemObjMod, (RTR3PTR)-1, 0, RTMEM_PROT_READ | RTMEM_PROT_WRITE, NIL_RTR0PROCESS);
+                LogRel(("[WEBUG] Mappin %d %d\n", rc, rc2));
+                if(RT_SUCCESS(rc) && RT_SUCCESS(rc2)){
+                    //Gets the ring-0 address of the new page
+                    //pVM->args.allochcphysreq.R0Ptr = (uint8_t*)RTR0MemObjAddress(hMapObjMod);
+                    //Gets the ring-3 address of the new page
+                    pReq->newPageR3Ptr = (uint8_t*)RTR0MemObjAddressR3(hMapObjMod);
+                    //Gets the physical address of the new page
+                    pReq->newPageHCPHys = RTR0MemObjGetPagePhysAddr(hMapObjMod, 0);
+                    return 0;
+                }else{
+                   LogRel(("[WDEBUG] Map failed ! \n"));
+		   return -3;
+		}
+            }else{
+		LogRel(("[WDEBUG] Alloc failed !\n"));
+                return rc;
+	    }
+            return -4;
+        }
+        return VERR_NOT_SUPPORTED;
+        /*ENMYCODE*/
         default:
             /*
              * We're returning VERR_NOT_SUPPORT here so we've got something else
diff --git a/src/VBox/VMM/VMMR3/CPUM.cpp b/src/VBox/VMM/VMMR3/CPUM.cpp
index ffb39cad..646557d1 100644
--- a/src/VBox/VMM/VMMR3/CPUM.cpp
+++ b/src/VBox/VMM/VMMR3/CPUM.cpp
@@ -1141,6 +1141,12 @@ VMMR3DECL(int) CPUMR3Term(PVM pVM)
  */
 VMMR3DECL(void) CPUMR3ResetCpu(PVM pVM, PVMCPU pVCpu)
 {
+
+    /*MYCODE*/
+    pVCpu->mystate.s.bRestoreRequired = false;
+    pVCpu->mystate.s.bPauseRequired = false;
+    /*ENDMYCODE*/
+
     /** @todo anything different for VCPU > 0? */
     PCPUMCTX pCtx = &pVCpu->cpum.s.Guest;
 
diff --git a/src/VBox/VMM/VMMR3/EM.cpp b/src/VBox/VMM/VMMR3/EM.cpp
index e5e6c0b7..7b920b2f 100644
--- a/src/VBox/VMM/VMMR3/EM.cpp
+++ b/src/VBox/VMM/VMMR3/EM.cpp
@@ -71,6 +71,9 @@
 #include <iprt/stream.h>
 #include <iprt/thread.h>
 
+/*MYCODE*/
+#include <FDP/include/FDP.h>
+/*ENDMYCODE*/
 
 /*********************************************************************************************************************************
 *   Defined Constants And Macros                                                                                                 *
@@ -147,6 +150,12 @@ VMMR3_INT_DECL(int) EMR3Init(PVM pVM)
         pVM->em.s.fGuruOnTripleFault = true;
     }
 
+    /*MYCODE*/
+    //Dont Guru on Triple Fault... This is annoying !
+    pVM->em.s.fGuruOnTripleFault = false;
+    /*ENDMYCODE*/
+
+
     Log(("EMR3Init: fRecompileUser=%RTbool fRecompileSupervisor=%RTbool fRawRing1Enabled=%RTbool fIemExecutesAll=%RTbool fGuruOnTripleFault=%RTbool\n",
          pVM->fRecompileUser, pVM->fRecompileSupervisor, pVM->fRawRing1Enabled, pVM->em.s.fIemExecutesAll, pVM->em.s.fGuruOnTripleFault));
 
@@ -844,8 +853,10 @@ static VBOXSTRICTRC emR3Debug(PVM pVM, PVMCPU pVCpu, VBOXSTRICTRC rc)
              * Simple events: stepped, breakpoint, stop/assertion.
              */
             case VINF_EM_DBG_STEPPED:
-                rc = DBGFR3Event(pVM, DBGFEVENT_STEPPED);
-                break;
+				/*MYCODE*/
+                //rc = DBGFR3Event(pVM, DBGFEVENT_STEPPED);
+				/*ENDMYCODE*/
+				break;
 
             case VINF_EM_DBG_BREAKPOINT:
                 rc = DBGFR3EventBreakpoint(pVM, DBGFEVENT_BREAKPOINT);
@@ -2293,6 +2304,29 @@ VMMR3_INT_DECL(int) EMR3ExecuteVM(PVM pVM, PVMCPU pVCpu)
             else if (fFFDone)
                 fFFDone = false;
 
+            /*MYCODE*/
+            if(pVCpu->mystate.s.bPauseRequired){
+                //Set the active CPU as STATE_PAUSED
+                pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+                //LogRel(("[WDEBUG] CPU[%d] Entering PAUSE in EM!\n", pVCpu->idCpu));
+                VMR3EnterPause(pVM, pVCpu);
+                //LogRel(("[WDEBUG] CPU[%d] Leaving PAUSE in EM!\n", pVCpu->idCpu));
+                rc = VINF_SUCCESS;
+            }
+            pVCpu->mystate.s.u8StateBitmap &= ~FDP_STATE_PAUSED;
+            pVCpu->mystate.s.u64TickCount++;
+            if(pVCpu->mystate.s.bRebootRequired){
+                rc = VINF_EM_TRIPLE_FAULT;
+                pVM->em.s.fGuruOnTripleFault = false;
+                pVCpu->mystate.s.bRebootRequired = false;
+            }
+            if(pVCpu->mystate.s.bSuspendRequired){
+                rc = VINF_EM_SUSPEND;
+                pVCpu->mystate.s.bSuspendRequired = false;
+            }
+            /*MYCODE*/
+
+
             /*
              * Now what to do?
              */
@@ -2807,6 +2841,22 @@ VMMR3_INT_DECL(int) EMR3ExecuteVM(PVM pVM, PVMCPU pVCpu)
     /* not reached */
 }
 
+/*MYCODE*/
+VMMR3_INT_DECL(int) EMR3ProcessForcedAction(PVM pVM, PVMCPU pVCpu, int rc)
+{
+    rc = emR3ForcedActions(pVM, pVCpu, rc);
+    VBOXVMM_EM_FF_ALL_RET(pVCpu, rc);
+
+    EMSTATE enmState = emR3Reschedule(pVM, pVCpu, pVCpu->em.s.pCtx);
+    //LogRel(("EMR3ExecuteVM: VINF_EM_RESCHEDULE: %d -> %d (%s)\n", 0, enmState, "emR3GetStateName(enmState)"));
+    if (pVCpu->em.s.enmState != enmState && enmState == EMSTATE_IEM_THEN_REM)
+        pVCpu->em.s.cIemThenRemInstructions = 0;
+    pVCpu->em.s.enmState = enmState;
+    return rc;
+}
+/*ENDMYCODE*/
+
+
 /**
  * Notify EM of a state change (used by FTM)
  *
diff --git a/src/VBox/VMM/VMMR3/EMHM.cpp b/src/VBox/VMM/VMMR3/EMHM.cpp
index 5effe032..2b34113b 100644
--- a/src/VBox/VMM/VMMR3/EMHM.cpp
+++ b/src/VBox/VMM/VMMR3/EMHM.cpp
@@ -497,6 +497,12 @@ int emR3HmExecute(PVM pVM, PVMCPU pVCpu, bool *pfFFDone)
                 break;
             }
         }
+
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired)
+            break;
+        /*ENDMYCODE*/
+
     }
 
     /*
diff --git a/src/VBox/VMM/VMMR3/MM.cpp b/src/VBox/VMM/VMMR3/MM.cpp
index c28e1e83..e33aca8f 100644
--- a/src/VBox/VMM/VMMR3/MM.cpp
+++ b/src/VBox/VMM/VMMR3/MM.cpp
@@ -854,3 +854,8 @@ VMMR3DECL(uint32_t) MMR3PhysGet4GBRamHoleSize(PVM pVM)
     return pVM->mm.s.cbRamHole;
 }
 
+
+VMMR3DECL(uint64_t) MMR3PhysGetRamSizeU(PUVM pUVM)
+{
+    return pUVM->pVM->mm.s.cbRamBase;
+}
diff --git a/src/VBox/VMM/VMMR3/PDM.cpp b/src/VBox/VMM/VMMR3/PDM.cpp
index 98f61579..fdd6528e 100644
--- a/src/VBox/VMM/VMMR3/PDM.cpp
+++ b/src/VBox/VMM/VMMR3/PDM.cpp
@@ -2037,7 +2037,7 @@ DECLINLINE(int) pdmR3ResumeDev(PPDMDEVINS pDevIns)
  */
 VMMR3_INT_DECL(void) PDMR3Resume(PVM pVM)
 {
-    LogFlow(("PDMR3Resume:\n"));
+    LogRel(("PDMR3Resume:\n"));
 
     /*
      * Iterate thru the device instances and USB device instances,
diff --git a/src/VBox/VMM/VMMR3/PGMDbg.cpp b/src/VBox/VMM/VMMR3/PGMDbg.cpp
index 143e6878..b4afb504 100644
--- a/src/VBox/VMM/VMMR3/PGMDbg.cpp
+++ b/src/VBox/VMM/VMMR3/PGMDbg.cpp
@@ -779,6 +779,10 @@ VMMR3_INT_DECL(int) PGMR3DbgScanPhysical(PVM pVM, RTGCPHYS GCPhys, RTGCPHYS cbRa
     return VERR_DBGF_MEM_NOT_FOUND;
 }
 
+VMMR3_INT_DECL(int) PGMR3DbgScanPhysicalU(PUVM pUVM, RTGCPHYS GCPhys, RTGCPHYS cbRange, RTGCPHYS GCPhysAlign, const uint8_t *pabNeedle, size_t cbNeedle, PRTGCPHYS pGCPhysHit)
+{
+    return PGMR3DbgScanPhysical(pUVM->pVM, GCPhys, cbRange, GCPhysAlign, pabNeedle, cbNeedle, pGCPhysHit);
+}
 
 /**
  * Scans (guest) virtual memory for a byte string.
diff --git a/src/VBox/VMM/VMMR3/TRPM.cpp b/src/VBox/VMM/VMMR3/TRPM.cpp
index bc59b7b9..a14d3a6c 100644
--- a/src/VBox/VMM/VMMR3/TRPM.cpp
+++ b/src/VBox/VMM/VMMR3/TRPM.cpp
@@ -1496,6 +1496,17 @@ VMMR3DECL(bool) TRPMR3IsGateHandler(PVM pVM, RTRCPTR GCPtr)
  */
 VMMR3DECL(int) TRPMR3InjectEvent(PVM pVM, PVMCPU pVCpu, TRPMEVENT enmEvent)
 {
+
+    /*MYCODE*/
+    //Avoid interrupt during restore or pause
+    if(pVCpu->mystate.s.bRestoreRequired
+    || pVCpu->mystate.s.bPauseRequired
+    || pVCpu->mystate.s.bDisableInterrupt){
+        return VINF_EM_RESCHEDULE_HM;
+    }
+    /*ENDMYCODE*/
+
+
 #ifdef VBOX_WITH_RAW_MODE
     PCPUMCTX pCtx = CPUMQueryGuestCtxPtr(pVCpu);
     Assert(!PATMIsPatchGCAddr(pVM, pCtx->eip));
diff --git a/src/VBox/VMM/VMMR3/VM.cpp b/src/VBox/VMM/VMMR3/VM.cpp
index 65904ee0..9d54a134 100644
--- a/src/VBox/VMM/VMMR3/VM.cpp
+++ b/src/VBox/VMM/VMMR3/VM.cpp
@@ -92,6 +92,11 @@
 #include <iprt/thread.h>
 #include <iprt/uuid.h>
 
+/*MYCODE*/
+#include <iprt/spinlock.h>
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+/*ENDMYCODE*/
 
 /*********************************************************************************************************************************
 *   Internal Functions                                                                                                           *
@@ -655,6 +660,22 @@ static int vmR3CreateU(PUVM pUVM, uint32_t cCpus, PFNCFGMCONSTRUCTOR pfnCFGMCons
             rc = vmR3ReadBaseConfig(pVM, pUVM, cCpus);
             if (RT_SUCCESS(rc))
             {
+
+                /*MYCODE*/
+                //This spinlock is created in Ring-0!
+                strcpy(pVM->mystate.s.PageSpinLockName, "PAGELOCK_");
+                strcat(pVM->mystate.s.PageSpinLockName, VMR3GetName(pUVM));
+
+                //Create CpuSpinLock
+                char CpuSpinLockName[256];
+                strcpy(CpuSpinLockName, "CPULOCK_");
+                strcat(CpuSpinLockName, VMR3GetName(pUVM));
+                pVM->mystate.s.CpuLock = NIL_RTSPINLOCK;
+                RTSpinlockCreate(&pVM->mystate.s.CpuLock, RTSPINLOCK_FLAGS_INTERRUPT_UNSAFE, CpuSpinLockName);
+                /*ENDMYCODE*/
+
+
+
                 /*
                  * Init the ring-3 components and ring-3 per cpu data, finishing it off
                  * by a relocation round (intermediate context finalization will do this).
@@ -1482,6 +1503,14 @@ static DECLCALLBACK(VBOXSTRICTRC) vmR3Resume(PVM pVM, PVMCPU pVCpu, void *pvUser
     VMRESUMEREASON enmReason = (VMRESUMEREASON)(uintptr_t)pvUser;
     LogFlow(("vmR3Resume: pVM=%p pVCpu=%p/#%u enmReason=%d\n", pVM, pVCpu, pVCpu->idCpu, enmReason));
 
+    /*MYCODE*/
+    if(pVCpu->mystate.s.bRestoreRequired == true){
+        pVCpu->mystate.s.bPauseRequired = true;
+    }
+    /*ENDMYCODE*/
+
+
+
     /*
      * The first thread thru here tries to change the state.  We shouldn't be
      * called again if this fails.
@@ -2381,6 +2410,28 @@ static DECLCALLBACK(VBOXSTRICTRC) vmR3PowerOff(PVM pVM, PVMCPU pVCpu, void *pvUs
  */
 VMMR3DECL(int)   VMR3PowerOff(PUVM pUVM)
 {
+
+    /*MYCODE*/
+    PVMCPU pVCpu = &pUVM->pVM->aCpus[0];
+    //Do this only if the vCpu is Paused
+    if(pVCpu->mystate.s.bPauseRequired == true){
+        //Avoid freeze
+        //VMR3Break(pUVM);
+        //Clear All Breakpoint
+        for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+            VMR3RemoveBreakpoint(pUVM, BreakpointId);
+        }
+        CPUMSetGuestDR7(pVCpu, 0x400);
+        //Continue
+        //VMR3Continue(pUVM);*/
+        pVCpu->mystate.s.bPauseRequired = false;
+
+        //Stop FDP Debugger
+        FDP_SHM *pFdpShm = (FDP_SHM *)pUVM->pVM->mystate.s.pFdpShm;
+        pFdpShm->pFdpServer->bIsRunning = false;
+    }
+    /*ENDMYCODE*/
+
     LogFlow(("VMR3PowerOff: pUVM=%p\n", pUVM));
     UVM_ASSERT_VALID_EXT_RETURN(pUVM, VERR_INVALID_VM_HANDLE);
     PVM pVM = pUVM->pVM;
diff --git a/src/VBox/VMM/VMMR3/VMEmt.cpp b/src/VBox/VMM/VMMR3/VMEmt.cpp
index 46db8e50..e0fd715e 100644
--- a/src/VBox/VMM/VMMR3/VMEmt.cpp
+++ b/src/VBox/VMM/VMMR3/VMEmt.cpp
@@ -42,6 +42,17 @@
 #include <iprt/thread.h>
 #include <iprt/time.h>
 
+/*MYCODE*/
+#include <stdlib.h>
+
+#include <VBox/vmm/gmm.h>
+#include <VBox/vmm/iem.h>
+#include <VBox/vmm/pgm.h>
+
+#include <FDP/include/FDP.h>
+#include <FDP/include/FDP_structs.h>
+#include <iprt/spinlock.h>
+/*ENDMYCODE*/
 
 /*********************************************************************************************************************************
 *   Internal Functions                                                                                                           *
@@ -373,12 +384,24 @@ static DECLCALLBACK(int) vmR3HaltOldDoHalt(PUVMCPU pUVCpu, const uint32_t fMask,
         if (    VM_FF_IS_PENDING(pVM, VM_FF_EXTERNAL_HALTED_MASK)
             ||  VMCPU_FF_IS_PENDING(pVCpu, fMask))
             break;
+
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
+
         uint64_t u64NanoTS;
         TMTimerPollGIP(pVM, pVCpu, &u64NanoTS);
         if (    VM_FF_IS_PENDING(pVM, VM_FF_EXTERNAL_HALTED_MASK)
             ||  VMCPU_FF_IS_PENDING(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Wait for a while. Someone will wake us up or interrupt the call if
          * anything needs our attention.
@@ -722,6 +745,11 @@ static DECLCALLBACK(int) vmR3HaltGlobal1Halt(PUVMCPU pUVCpu, const uint32_t fMas
             ||  VMCPU_FF_IS_PENDING(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Estimate time left to the next event.
          */
@@ -732,6 +760,11 @@ static DECLCALLBACK(int) vmR3HaltGlobal1Halt(PUVMCPU pUVCpu, const uint32_t fMas
             ||  VMCPU_FF_IS_PENDING(pVCpu, fMask))
             break;
 
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+
         /*
          * Block if we're not spinning and the interval isn't all that small.
          */
@@ -1069,6 +1102,925 @@ VMMR3_INT_DECL(void) VMR3NotifyCpuFFU(PUVMCPU pUVCpu, uint32_t fFlags)
     g_aHaltMethods[pUVM->vm.s.iHaltMethod].pfnNotifyCpuFF(pUVCpu, fFlags);
 }
 
+/*MYCODE*/
+//TODO: include with DBGTcp.cpp
+#define DEBUG_LEVEL 1
+
+#if DEBUG_LEVEL > 0
+#define LogRelDebug(x) LogRel(x)
+#else
+#define LogRelDebug(x)
+#endif
+
+
+//TODO: Add Cs, Ds, Es, Fs, Gs, SS, ...
+void VMR3UpdateFdpCpuCtx(PVMCPU pVCpu)
+{
+    PCCPUMCTXCORE pCtxCore = CPUMGetGuestCtxCore(pVCpu);
+    FDP_CPU_CTX* pFdpCpuCtx = (FDP_CPU_CTX *)pVCpu->mystate.s.pCpuShm;
+
+    pFdpCpuCtx->rip = pCtxCore->rip;
+    pFdpCpuCtx->rax = pCtxCore->rax;
+    pFdpCpuCtx->rcx = pCtxCore->rcx;
+    pFdpCpuCtx->rdx = pCtxCore->rdx;
+    pFdpCpuCtx->rbx = pCtxCore->rbx;
+    pFdpCpuCtx->rsp = pCtxCore->rsp;
+    pFdpCpuCtx->rbp = pCtxCore->rbp;
+    pFdpCpuCtx->rsi = pCtxCore->rsi;
+    pFdpCpuCtx->rdi = pCtxCore->rdi;
+    pFdpCpuCtx->r8 = pCtxCore->r8;
+    pFdpCpuCtx->r9 = pCtxCore->r9;
+    pFdpCpuCtx->r10 = pCtxCore->r10;
+    pFdpCpuCtx->r11 = pCtxCore->r11;
+    pFdpCpuCtx->r12 = pCtxCore->r12;
+    pFdpCpuCtx->r13 = pCtxCore->r13;
+    pFdpCpuCtx->r14 = pCtxCore->r14;
+    pFdpCpuCtx->r15 = pCtxCore->r15;
+    pFdpCpuCtx->cr0 = CPUMGetGuestCR0(pVCpu);
+    pFdpCpuCtx->cr2 = CPUMGetGuestCR2(pVCpu);
+    pFdpCpuCtx->cr3 = CPUMGetGuestCR3(pVCpu);
+    pFdpCpuCtx->cr4 = CPUMGetGuestCR4(pVCpu);
+
+}
+
+HardwarePage_t* VMR3GetAllocatedHardwarePage(PUVM pUVM, uint64_t GCPhys)
+{
+    //Look for a breakpoint already using a convient page
+    int BreakpointId = VMMGetBreakpointIdFromPage(pUVM->pVM, GCPhys, FDP_SOFTHBP);
+    if(BreakpointId >= 0
+    && BreakpointId < MAX_BREAKPOINT_ID){
+        //A breakpoint using a convient page exists
+        pUVM->pVM->bp.l[BreakpointId].breakpointHardwarePage->ReferenceCount++;
+        return pUVM->pVM->bp.l[BreakpointId].breakpointHardwarePage;
+    }
+
+    //Look in the Free HardwarePage table
+    for(uint32_t i=0; i<pUVM->pVM->mystate.s.u32HardwarePageTableCount; i++){
+        if(pUVM->pVM->mystate.s.aHardwarePageTable[i].ReferenceCount == 0
+        && pUVM->pVM->mystate.s.aHardwarePageTable[i].HCPhys != 0
+        && pUVM->pVM->mystate.s.aHardwarePageTable[i].R3Ptr != NULL){
+            pUVM->pVM->mystate.s.aHardwarePageTable[i].ReferenceCount = 1;
+            return &pUVM->pVM->mystate.s.aHardwarePageTable[i];
+        }
+    }
+
+    LogRel(("[WDEBUG] Allocate a new HardwarePage for %p !\n", GCPhys));
+    //None are free, allocate a new one !
+    ALLOCPAGEREQ Req;
+    Req.Hdr.u32Magic = SUPVMMR0REQHDR_MAGIC;
+    Req.Hdr.cbReq    = sizeof(Req);
+    Req.newPageSize = _4K;
+    int rc = SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0, NIL_VMCPUID, VMMR0_DO_ALLOC_HCPHYS, 0, &Req.Hdr);
+    if(rc != 0){
+        LogRel(("[WDEBUG] Failed to allocate a new HardwarePage %d\n", rc));
+        return NULL;
+    }
+
+    HardwarePage_t* TmpHardwarePage = &pUVM->pVM->mystate.s.aHardwarePageTable[pUVM->pVM->mystate.s.u32HardwarePageTableCount];
+
+    TmpHardwarePage->PageSize = _4K;
+    TmpHardwarePage->HCPhys = Req.newPageHCPHys;
+    TmpHardwarePage->R3Ptr = Req.newPageR3Ptr;
+    TmpHardwarePage->ReferenceCount = 1;
+
+    pUVM->pVM->mystate.s.u32HardwarePageTableCount++;
+
+    return TmpHardwarePage;
+}
+
+
+/*
+ * @brief: Restore all Original HCPhys for SoftHyperBreakpointed GCPhys
+ */
+VMMR3_INT_DECL(int)    VMR3RestoreAllOriginalPage(PUVM pUVM, bool bIsRead, bool bIsWrite, bool bIsExecute)
+{
+    PVM pVM = pUVM->pVM;
+    PVMCPU pVCpu = &pVM->aCpus[0];
+    BreakpointEntrie_t *pTempBreakpointEntrie = NULL;
+    for(uint8_t BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        //Check if Breakpoint is Activated and if it is a SoftWareBreakpoint
+        if(pTempBreakpointEntrie->breakpointActivated == true &&
+           pTempBreakpointEntrie->breakpointType == FDP_SOFTHBP &&
+           pTempBreakpointEntrie->breakpointOrigHCPhys != 0x0 &&
+           pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start != 0x0){
+            //Set Original Page as Read and Write
+            uint64_t GCPhys = pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start;
+            PGMShwSetHCPage(pVCpu, GCPhys, pTempBreakpointEntrie->breakpointOrigHCPhys);
+            if(bIsRead == true){
+                PGMShwPresent(pVCpu, GCPhys);
+            }else{
+                PGMShwNoPresent(pVCpu, GCPhys);
+            }
+            if(bIsWrite == true){
+                PGMShwWrite(pVCpu, GCPhys);
+            }else{
+                PGMShwNoWrite(pVCpu, GCPhys);
+            }
+            if(bIsExecute == true){
+                PGMShwExecute(pVCpu, GCPhys);
+            }else{
+                PGMShwNoExecute(pVCpu, GCPhys);
+            }
+            //Set page as breakable !
+            PGMShwSetBreakable(pVCpu, GCPhys, true);
+            //Invalidate the page !
+            PGMShwInvalidate(pVCpu, GCPhys);
+        }
+    }
+    return 0;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddMsrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress)
+{
+    PVM pVM = pUVM->pVM;
+    //Look for a free breakpoint
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            pTempBreakpointEntrie->breakpointActivated = true;
+            pTempBreakpointEntrie->breakpointGCPtr = BreakpointAddress;
+            pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+            pTempBreakpointEntrie->breakpointType = FDP_MSRHBP;
+            pTempBreakpointEntrie->breakpointLength = 1;
+            pTempBreakpointEntrie->breakpointAccessType = BreakpointAccessType;
+            pTempBreakpointEntrie->breakpointPageSize = 0x0;
+            pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+
+            return BreakpointId;
+        }
+    }
+    return -1;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddCrBreakpoint(PUVM pUVM, uint8_t BreakpointAccessType, uint64_t BreakpointAddress)
+{
+    PVM pVM = pUVM->pVM;
+    //Look for a free breakpoint
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            pTempBreakpointEntrie->breakpointActivated = true;
+            pTempBreakpointEntrie->breakpointGCPtr = BreakpointAddress;
+            pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+            pTempBreakpointEntrie->breakpointType = FDP_CRHBP;
+            pTempBreakpointEntrie->breakpointLength = 1;
+            pTempBreakpointEntrie->breakpointAccessType = BreakpointAccessType;
+            pTempBreakpointEntrie->breakpointPageSize = 0x0;
+            pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+
+            return BreakpointId;
+        }
+    }
+    return -1;
+}
+
+VMMR3_INT_DECL(int)    VMR3AddSoftBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointCr3)
+{ //TODO: Move it to VMMAll !
+
+    LogRel(("[WDEBUG] VMR3AddSoftBreakpoint in\n"));
+    VMR3RestoreAllOriginalPage(pUVM, true, true, false);
+
+    PVM pVM = pUVM->pVM;
+
+    //Convert GCPtr to GCPhys if needed
+    uint64_t GCPhys;
+    uint64_t GCPtr = 0;
+    if(BreakpointAddressType == 0x1){//Virtual
+        GCPtr = BreakpointAddress;
+        PGMPhysGCPtr2GCPhys(pVCpu, BreakpointAddress, &GCPhys);
+        //PGMGstGetPage(pVCpu, BreakpointAddress, NULL, &GCPhys);
+    }else{ //Physical
+        GCPhys = BreakpointAddress;
+    }
+
+    //Look for an already existing SoftHyperBreakpoint with same GCPhys
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true &&
+           pTempBreakpointEntrie->breakpointType == FDP_SOFTHBP &&
+           pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start == GCPhys){
+               //We found one !
+               return BreakpointId;
+        }
+    }
+
+    for(int BreakpointId=4*pUVM->pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+
+        //Find a free breakpoint
+        if(pTempBreakpointEntrie->breakpointActivated == false){
+            //Get Original HCPhys
+            uint64_t origHCPhys;
+            //It is the OriginalPage because we called VMR3RestoreAllOriginalPage(pUVM);
+            PGMShwGetHCPage(pVCpu, GCPhys, &origHCPhys);
+            //After restore EPTPTE are not initilized
+            if(origHCPhys < 0x100){
+		LogRel(("[WDEBUG] AddSoft %p %p\n", GCPhys, origHCPhys));
+                return -1;
+            }
+
+            //Get a HardwarePage
+            HardwarePage_t* pTempHardwarePage = VMR3GetAllocatedHardwarePage(pUVM, GCPhys);
+            if(pTempHardwarePage != NULL){
+                if(pTempHardwarePage->ReferenceCount == 1){
+                    //This is the first breakpoint using this hardware page
+                    //Copy original page content to new page only if the page is new
+                    LogRel(("[WDEBUG] Copy OrignalPage to ModificatedPage\n"));
+                    PGMPhysSimpleReadGCPhys(pUVM->pVM, (void*)pTempHardwarePage->R3Ptr, (RTGCPHYS)(GCPhys & ~(pTempHardwarePage->PageSize-1)), pTempHardwarePage->PageSize);
+                }
+
+                LogRel(("[WDEBUG] SoftHyperBreakpoint installation : \n"));
+                LogRel(("[WDEBUG] Original page HCPhys: 0x%p\n", origHCPhys));
+                LogRel(("[WDEBUG] GCPhys: 0x%p\n", GCPhys));
+                LogRel(("[WDEBUG] pTempHardwarePage: %p\n", pTempHardwarePage));
+                LogRel(("[WDEBUG] Modificated page HCPhys:  0x%p\n", pTempHardwarePage->HCPhys));
+                LogRel(("[WDEBUG] Modificated page R3Ptr:  0x%p\n", pTempHardwarePage->R3Ptr));
+                LogRel(("[WDEBUG] HardwarePage Reference Count: %d\n", pTempHardwarePage->ReferenceCount));
+                LogRel(("[WDEBUG] \n"));
+
+                pTempBreakpointEntrie->breakpointActivated = true;
+                pTempBreakpointEntrie->breakpointGCPtr = GCPtr;
+                pTempBreakpointEntrie->breakpointOrigHCPhys = origHCPhys;
+                pTempBreakpointEntrie->breakpointType = FDP_SOFTHBP;
+                pTempBreakpointEntrie->breakpointLength = 1;
+                pTempBreakpointEntrie->breakpointCr3 = BreakpointCr3;
+                pTempBreakpointEntrie->breakpointAccessType = FDP_EXECUTE_BP;
+                pTempBreakpointEntrie->breakpointPageSize = pTempHardwarePage->PageSize;
+                pTempBreakpointEntrie->breakpointHardwarePage = pTempHardwarePage;
+                //Save the original byte
+                pTempBreakpointEntrie->breakpointOriginalByte = pTempHardwarePage->R3Ptr[(GCPhys & (pTempHardwarePage->PageSize-1))]; //TODO change % to &
+                //Install a HLT in the new page
+                pTempHardwarePage->R3Ptr[(GCPhys & (pTempHardwarePage->PageSize-1))] = 0xCC;
+                pTempBreakpointEntrie->breakpointGCPhysAreaCount = 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(1 * sizeof(GCPhysArea_t));
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start = GCPhys;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].End = GCPhys+1;
+
+                //Set page as original and read/write
+                PGMShwSetHCPage(pVCpu, GCPhys, origHCPhys);
+                PGMShwPresent(pVCpu, GCPhys);
+                PGMShwWrite(pVCpu, GCPhys);
+                PGMShwNoExecute(pVCpu, GCPhys);
+                //Set page as breakable !
+                PGMShwSetBreakable(pVCpu, GCPhys, true);
+                //Invalidate the page !
+                PGMShwInvalidate(pVCpu, GCPhys);
+
+                return BreakpointId;
+            }else{
+		LogRel(("[WDEBUG] Failed to Allocate HardwarePage\n"));
+                return -1;
+            }
+        }
+    }
+    return -1;
+}
+
+void ApplyBreakpointOnPage(PVM pVM, PVMCPU pVCpu, uint64_t GCPhys, uint8_t BreakpointAccessType)
+{
+    //No access at all for FDP_READ_BP
+    if(BreakpointAccessType & FDP_READ_BP){
+        PGMShwNoPresent(pVCpu, GCPhys);
+        PGMShwNoWrite(pVCpu, GCPhys);
+        PGMShwNoExecute(pVCpu, GCPhys);
+    }
+    if(BreakpointAccessType & FDP_WRITE_BP)
+        PGMShwNoWrite(pVCpu, GCPhys);
+    if(BreakpointAccessType & FDP_EXECUTE_BP)
+        PGMShwNoExecute(pVCpu, GCPhys);
+
+    //Set the page as Breakable page
+    PGMShwSetBreakable(pVCpu, GCPhys, true);
+    //Save the final page rights
+    PGMShwSaveRights(pVCpu, GCPhys);
+    //Invalidate the page !
+    PGMShwInvalidate(pVCpu, GCPhys);
+}
+
+void DisableBreakpointOnPage(PVM pVM, PVMCPU pVCpu, uint64_t GCPhys)
+{
+    PGMShwPresent(pVCpu, GCPhys);
+    PGMShwWrite(pVCpu, GCPhys);
+    PGMShwExecute(pVCpu, GCPhys);
+
+    //Set the page as Standard page
+    PGMShwSetBreakable(pVCpu, GCPhys, false);
+    //Save the final page rights
+    PGMShwSaveRights(pVCpu, GCPhys);
+    //Invalidate the page !
+    PGMShwInvalidate(pVCpu, GCPhys);
+}
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+
+void AddGCPhysAreaInBreakpoint(BreakpointEntrie_t *pTempBreakpointEntrie, uint64_t Start, uint64_t End)
+{
+    if(pTempBreakpointEntrie){
+        int CurrentGCPhysAreaIndex = pTempBreakpointEntrie->breakpointGCPhysAreaCount;
+        //LogRel(("[WDEBUG] %d. %p->%p\n", CurrentGCPhysAreaIndex, Start, End));
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable[CurrentGCPhysAreaIndex].Start = Start;
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable[CurrentGCPhysAreaIndex].End = End;
+        pTempBreakpointEntrie->breakpointGCPhysAreaCount++;
+    }
+}
+
+void DisableAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+            }
+        }
+    }
+}
+
+void EnableAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            //Apply on pages
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                ApplyBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start, pTempBreakpointEntrie->breakpointAccessType);
+            }
+        }
+    }
+}
+
+void InstallAllPageBreakpoint(PVM pVM, PVMCPU pVCpu)
+{
+    //Restore all rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP
+        && pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+            }
+            if(pTempBreakpointEntrie->breakpointGCPhysAreaTable)
+                free(pTempBreakpointEntrie->breakpointGCPhysAreaTable);
+            pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+            pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+        }
+    }
+
+    //Remove rights for pages in breakpoint
+    for(int BreakpointId=0; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+        && pTempBreakpointEntrie->breakpointType == FDP_PAGEHBP){
+            uint64_t BreakpointLength = pTempBreakpointEntrie->breakpointLength;
+            if(pTempBreakpointEntrie->breakpointGCPtr > 0){ //VirtualAddress Breakpoint
+                uint64_t GCPhys;
+                uint64_t GCPtr = pTempBreakpointEntrie->breakpointGCPtr;
+                int MaxGCPhysAreaCount = (BreakpointLength/_4K) + 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(MaxGCPhysAreaCount * sizeof(GCPhysArea_t));
+
+                //First chunk Page
+                int rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr, &GCPhys);
+                uint64_t GCPhysPageEnd = (GCPhys & 0xFFFFFFFFFFFFF000) + _4K;
+                uint64_t AlreadyBreakpointSize = MIN(GCPhysPageEnd - GCPhys, BreakpointLength);
+                if(RT_SUCCESS(rc)){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+AlreadyBreakpointSize);
+                }
+                //Intermediate complete page
+                int64_t LeftToBreakpoint = BreakpointLength - AlreadyBreakpointSize;
+                while (LeftToBreakpoint >= _4K){ //More than 1 page to breakpoint !
+                    rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr + AlreadyBreakpointSize, &GCPhys);
+                    if(RT_SUCCESS(rc)){
+                        AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+_4K);
+                    }
+                    LeftToBreakpoint = LeftToBreakpoint - _4K;
+                    AlreadyBreakpointSize = AlreadyBreakpointSize + _4K;
+                }
+
+                //Last chunk page
+                if (LeftToBreakpoint > 0){ //Left breakpoint bytes
+                    rc = PGMPhysGCPtr2GCPhys(pVCpu, GCPtr + AlreadyBreakpointSize, &GCPhys);
+                    if(RT_SUCCESS(rc)){
+                        AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, GCPhys, GCPhys+LeftToBreakpoint);
+                    }
+                }
+            }else{ //PhysicalAddress Breakpoint
+                uint64_t LeftToBreakpoint = 0;
+                int MaxGCPhysAreaCount = (BreakpointLength/_4K) + 1;
+                pTempBreakpointEntrie->breakpointGCPhysAreaTable = (GCPhysArea_t*)malloc(MaxGCPhysAreaCount * sizeof(GCPhysArea_t));
+                uint64_t GCPhysPageEnd = (pTempBreakpointEntrie->breakpointGCPhys & ~(_4K-1)) + _4K;
+                uint64_t LastPageEnd = MIN(GCPhysPageEnd, pTempBreakpointEntrie->breakpointGCPhys+BreakpointLength);
+                LeftToBreakpoint = BreakpointLength - (LastPageEnd - pTempBreakpointEntrie->breakpointGCPhys);
+                AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, pTempBreakpointEntrie->breakpointGCPhys, LastPageEnd);
+                while(LeftToBreakpoint >= _4K){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, LastPageEnd, LastPageEnd+_4K);
+                    LeftToBreakpoint -= _4K;
+                    LastPageEnd += _4K;
+                }
+                if(LeftToBreakpoint > 0){
+                    AddGCPhysAreaInBreakpoint(pTempBreakpointEntrie, LastPageEnd, LastPageEnd+LeftToBreakpoint);
+                }
+            }
+
+
+            //Apply on pages
+            for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                ApplyBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start, pTempBreakpointEntrie->breakpointAccessType);
+            }
+        }
+    }
+
+    return;
+}
+
+
+bool IsOneCPURunning(PUVM pUVM)
+{
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        if(!(pUVM->pVM->aCpus[i].mystate.s.u8StateBitmap & FDP_STATE_PAUSED)){
+            return true;
+        }
+    }
+    return false;
+}
+
+
+
+
+VMMR3_INT_DECL(int)    VMR3AddPageBreakpoint(PUVM pUVM, PVMCPU pVCpu, uint8_t BreakpointId, uint8_t BreakpointAccessType, uint8_t BreakpointAddressType, uint64_t BreakpointAddress, uint64_t BreakpointLength)
+{ //TODO: Move it to VMMAll !
+    if(IsOneCPURunning(pUVM) == true){
+        //NO WAY !!!!!!
+        return -1;
+    }
+
+    PVM pVM = pUVM->pVM;
+
+    BreakpointEntrie_t *pTempBreakpointEntrie = NULL;
+    //If not a reserved to the guest breakpoint
+    if(BreakpointId < 0 || BreakpointId > 3){
+        bool BreakpointIdFound = false;
+        for(BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+            pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+            //Find a free breakpoint
+            if(pTempBreakpointEntrie->breakpointActivated == false){
+                break;
+            }
+        }
+    }else{
+        pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+    }
+
+    if(pTempBreakpointEntrie != NULL
+    && pTempBreakpointEntrie->breakpointActivated == false){
+        uint64_t GCPhys;
+        uint64_t GCPtr = 0;
+        if(BreakpointAddressType == FDP_VIRTUAL_ADDRESS){//Virtual
+            GCPtr = BreakpointAddress;
+            int rc = PGMPhysGCPtr2GCPhys(pVCpu, BreakpointAddress, &GCPhys);
+            if(RT_FAILURE(rc)){
+                //LogRel(("Fail to convert GCPtr(%p) -> GCphys\n", BreakpointAddress));
+                return -1;
+            }
+        }else{ //Physical
+            GCPhys = BreakpointAddress;
+        }
+
+        pVM->bp.l[BreakpointId].breakpointActivated = true;
+        pVM->bp.l[BreakpointId].breakpointGCPtr = GCPtr;
+        pVM->bp.l[BreakpointId].breakpointGCPhys = GCPhys;
+        pVM->bp.l[BreakpointId].breakpointType = FDP_PAGEHBP;
+        pVM->bp.l[BreakpointId].breakpointLength = BreakpointLength;
+        pVM->bp.l[BreakpointId].breakpointAccessType = BreakpointAccessType;
+        pVM->bp.l[BreakpointId].breakpointPageSize = _4K;
+
+        InstallAllPageBreakpoint(pVM, pVCpu);
+        return BreakpointId;
+    }
+    return -1;
+}
+
+//TODO: Move it to VMMAll !
+VMMR3_INT_DECL(bool) VMR3RemoveBreakpoint(PUVM pUVM, int BreakpointId)
+{
+
+    if(BreakpointId < 0 || BreakpointId > MAX_BREAKPOINT_ID){
+        return false;
+    }
+
+    //If one Cpu is running, we can't remove a breakpoint !
+    if(IsOneCPURunning(pUVM) == true){
+        return false;
+    }
+
+    PVM pVM = pUVM->pVM;
+    PVMCPU pVCpu = &pVM->aCpus[0];
+
+    //Restore OriginalPage for all SoftHyperBreakpoint
+    VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+
+    BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+
+    if(pTempBreakpointEntrie->breakpointActivated == true){
+        //Set the breakpoint as disabled
+        pTempBreakpointEntrie->breakpointActivated = false;
+
+        switch(pTempBreakpointEntrie->breakpointType)
+        {
+            case FDP_PAGEHBP:
+            {
+                //Enable all rights for page in this breakpoint
+                for(int j=0; j<pTempBreakpointEntrie->breakpointGCPhysAreaCount; j++){
+                    DisableBreakpointOnPage(pVM, pVCpu, pTempBreakpointEntrie->breakpointGCPhysAreaTable[j].Start);
+                }
+                //Enable all other page Breakpoint
+                InstallAllPageBreakpoint(pVM, pVCpu);
+                break;
+            }
+            case FDP_SOFTHBP:
+            {
+                pTempBreakpointEntrie->breakpointHardwarePage->ReferenceCount--;
+                if(pTempBreakpointEntrie->breakpointHardwarePage->ReferenceCount == 0){
+                    uint64_t GCPhys = pTempBreakpointEntrie->breakpointGCPhysAreaTable[0].Start;
+                    LogRelDebug(("[WDEBUG] HardwarePage->ReferenceCount == 0\n"));
+                    //No more breakpoint use this HardwarePage !
+                    //Restore Original page
+                    PGMShwSetHCPage(pVCpu, GCPhys, pTempBreakpointEntrie->breakpointOrigHCPhys);
+                    PGMShwPresent(pVCpu, GCPhys);
+                    PGMShwWrite(pVCpu, GCPhys);
+                    PGMShwExecute(pVCpu, GCPhys);
+
+                    PGMShwSetBreakable(pVCpu, GCPhys, false);
+
+                    PGMShwInvalidate(pVCpu, GCPhys);
+                }
+                break;
+            }
+            default:
+                break;
+        }
+
+        pTempBreakpointEntrie->breakpointTag = 0;
+        pTempBreakpointEntrie->breakpointGCPtr = 0;
+        pTempBreakpointEntrie->breakpointType = 0;
+        pTempBreakpointEntrie->breakpointLength = 0;
+        pTempBreakpointEntrie->breakpointAccessType = 0x0;
+        pTempBreakpointEntrie->breakpointOrigHCPhys = 0x0;
+        pTempBreakpointEntrie->breakpointOriginalByte = 0x0;
+        pTempBreakpointEntrie->breakpointHardwarePage = NULL;
+        pTempBreakpointEntrie->breakpointPageSize = 0x0;
+
+        if(pTempBreakpointEntrie->breakpointGCPhysAreaTable){
+            free(pTempBreakpointEntrie->breakpointGCPhysAreaTable);
+        }
+
+        pTempBreakpointEntrie->breakpointGCPhysAreaCount = 0;
+        pTempBreakpointEntrie->breakpointGCPhysAreaTable = NULL;
+        return true;
+    }
+    return false;
+}
+
+VMMDECL(int) VMR3PhysSimpleReadGCPhysU(PUVM pUVM, void *pvDst, RTGCPHYS GCPhysSrc, size_t cb)
+{
+    return PGMPhysSimpleReadGCPhys(pUVM->pVM, pvDst, GCPhysSrc, cb);
+}
+
+VMMDECL(int) VMR3PhysSimpleWriteGCPhysU(PUVM pUVM, const void *pvBuf, RTGCPHYS GCPhys, size_t cbWrite)
+{
+    return PGMPhysSimpleWriteGCPhys(pUVM->pVM, GCPhys, pvBuf, cbWrite);
+}
+
+VMMDECL(int) VMR3SingleStep(PUVM pUVM, PVMCPU pVCpu)
+{
+    //Dont try to single step on a running
+    if(pVCpu->mystate.s.u8StateBitmap & FDP_STATE_PAUSED){
+        pVCpu->mystate.s.bSingleStepRequired = true;
+        while(pVCpu->mystate.s.bSingleStepRequired){
+            //Yield
+            RTThreadSleep(0);
+        }
+        return 0;
+    }
+    return -1;
+}
+
+VMMDECL(int) VMR3BreakNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] BREAK !\n"));
+
+    //Wait for all cpu paused
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        pUVM->pVM->aCpus[i].mystate.s.bPauseRequired = true;
+
+        //Inject a IPI
+        SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0, pUVM->pVM->aCpus[i].idCpu, VMMR0_DO_GVMM_SCHED_WAKE_UP, 0, NULL);
+        SUPR3CallVMMR0Ex(pUVM->pVM->pVMR0, pUVM->pVM->aCpus[i].idCpu, VMMR0_DO_GVMM_SCHED_POKE, 0, NULL);
+
+        do{
+            //LogRel(("[WDEBUG] Waiting for CPU[%d] to pause state %02x\n", i, pUVM->pVM->aCpus[i].mystate.s.u8StateBitmap));
+            //RTThreadSleep(10);
+        }while(!(pUVM->pVM->aCpus[i].mystate.s.u8StateBitmap & FDP_STATE_PAUSED));
+        //LogRel(("[WDEBUG] CPU[%d] is paused !\n", i));
+    }
+
+    //LogRel(("[WDEBUG] All Cpus are PAUSED !\n"));
+    return 0;
+}
+
+VMMDECL(int) VMR3Break(PUVM pUVM)
+{
+    RTSpinlockAcquire(pUVM->pVM->mystate.s.CpuLock);
+
+    VMR3BreakNoLock(pUVM);
+
+    RTSpinlockRelease(pUVM->pVM->mystate.s.CpuLock);
+    return 0;
+}
+
+VMMDECL(int) VMR3ContinueNoWaitNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] VMR3ContinueNoWaitNoLock !\n"));
+
+    pUVM->pVM->mystate.s.u8StateBitmap &= ~FDP_STATE_DEBUGGER_ALERTED;
+
+    //Wait for all CPUs resumed
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = &pUVM->pVM->aCpus[i];
+        uint64_t oldu64TickCount = pVCpu->mystate.s.u64TickCount;
+        pVCpu->mystate.s.bPauseRequired = false;
+        VMCPU_FF_SET(pVCpu, VMCPU_FF_EXTERNAL_SUSPENDED_MASK);
+    }
+
+    return 0;
+}
+
+VMMDECL(int) VMR3ContinueWaitNoLock(PUVM pUVM)
+{
+    //LogRel(("[WDEBUG] VMR3ContinueWaitNoLock !\n"));
+
+    pUVM->pVM->mystate.s.u8StateBitmap &= ~FDP_STATE_DEBUGGER_ALERTED;
+
+    //Wait for all CPUs resumed
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        PVMCPU pVCpu = &pUVM->pVM->aCpus[i];
+        uint64_t oldu64TickCount = pVCpu->mystate.s.u64TickCount;
+        pVCpu->mystate.s.bPauseRequired = false;
+        VMCPU_FF_SET(pVCpu, VMCPU_FF_EXTERNAL_SUSPENDED_MASK);
+        while(oldu64TickCount == pVCpu->mystate.s.u64TickCount){
+            //Yield
+            RTThreadSleep(0);
+        }
+    }
+
+    return 0;
+}
+
+VMMDECL(int) VMR3Continue(PUVM pUVM)
+{
+    RTSpinlockAcquire(pUVM->pVM->mystate.s.CpuLock);
+
+    VMR3ContinueWaitNoLock(pUVM);
+
+    RTSpinlockRelease(pUVM->pVM->mystate.s.CpuLock);
+    return 0;
+}
+
+VMMDECL(uint8_t) VMR3GetFDPState(PUVM pUVM)
+{
+    uint8_t u8OldState = 0;
+    bool bIsPaused = true;
+    bool bIsBreakpointHitted = false;
+    for(uint32_t i=0; i<VMR3GetCPUCount(pUVM); i++){
+        //If one CPU is Running not in pause
+        if(!(pUVM->pVM->aCpus[i].mystate.s.u8StateBitmap & FDP_STATE_PAUSED)){
+            bIsPaused = false;
+        }
+        //If one CPU hit a breakpoint
+        if(pUVM->pVM->aCpus[i].mystate.s.u8StateBitmap & FDP_STATE_BREAKPOINT_HIT){
+            bIsBreakpointHitted = true;
+        }
+    }
+
+    if(bIsPaused){
+        u8OldState |= FDP_STATE_PAUSED;
+        if(bIsBreakpointHitted){
+            u8OldState |= FDP_STATE_BREAKPOINT_HIT;
+        }
+    }
+
+    if(pUVM->pVM->mystate.s.u8StateBitmap & FDP_STATE_DEBUGGER_ALERTED){
+        u8OldState |= FDP_STATE_DEBUGGER_ALERTED;
+    }
+    if(u8OldState & FDP_STATE_BREAKPOINT_HIT){
+        pUVM->pVM->mystate.s.u8StateBitmap |= FDP_STATE_DEBUGGER_ALERTED;
+    }
+    return u8OldState;
+}
+
+VMMDECL(bool) VMR3DisableAllMsrBreakpoint(PVM pVM)
+{
+    for(int BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointActivated == true
+            && pTempBreakpointEntrie->breakpointType == FDP_MSRHBP){
+                pTempBreakpointEntrie->breakpointActivated = false;
+        }
+    }
+    return 0;
+}
+
+VMMDECL(bool) VMR3EnableAllMsrBreakpoint(PVM pVM)
+{
+    for(int BreakpointId=4*pVM->cCpus; BreakpointId<MAX_BREAKPOINT_ID; BreakpointId++){
+        BreakpointEntrie_t *pTempBreakpointEntrie = &pVM->bp.l[BreakpointId];
+        if(pTempBreakpointEntrie->breakpointType == FDP_MSRHBP){
+                pTempBreakpointEntrie->breakpointActivated = true;
+        }
+    }
+    return 0;
+}
+
+VMMDECL(bool) VMR3HandleSingleStep(PVM pVM, PVMCPU pVCpu)
+{
+    //Check if Single step is required !
+    if(pVCpu->mystate.s.bSingleStepRequired){
+
+        TMR3NotifyResume(pVM, pVCpu);
+
+        LogRelDebug(("[WDEBUG] CPU[%d] bSingleStepRequired !\n", pVCpu->idCpu));
+
+        //Restore Original Page with Execute right, avoid Breakpoint in SingleStep
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, true);
+        //Disable All Msr Breakpoint, avoid Breakpoint in Breakpoint
+        VMR3DisableAllMsrBreakpoint(pVM);
+        //Disable PageHyperBreapoint
+        DisableAllPageBreakpoint(pVM, pVCpu);
+        //Disable Debug Register
+        uint64_t OldDr7 = CPUMGetGuestDR7(pVCpu);
+        CPUMSetGuestDR7(pVCpu, 0x400);
+
+        int rc = 0;
+        //First call is for instruction that jump on self "jmp -2 (ebfe)"
+        rc = VBOXSTRICTRC_VAL(EMR3HmSingleInstruction(pVM, pVCpu, 0));
+
+        LogRelDebug(("[WDEBUG] CPU[%d] Single Step => %d!\n", pVCpu->idCpu, rc));
+
+        if(VM_FF_IS_PENDING(pVM, VM_FF_ALL_REM_MASK)
+        || VMCPU_FF_IS_PENDING(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+            EMR3ProcessForcedAction(pVM, pVCpu, rc);
+        }
+
+        //If rc == 0 then it failed, we have to call SingleInstruction whith RIP_CHANGE
+        if(rc == 0){
+            rc = VBOXSTRICTRC_VAL(EMR3HmSingleInstruction(pVM, pVCpu, EM_ONE_INS_FLAGS_RIP_CHANGE));
+
+            LogRelDebug(("[WDEBUG] CPU[%d] Single Step => %d!\n", pVCpu->idCpu, rc));
+
+            if(VM_FF_IS_PENDING(pVM, VM_FF_ALL_REM_MASK)
+            || VMCPU_FF_IS_PENDING(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+                EMR3ProcessForcedAction(pVM, pVCpu, rc);
+            }
+        }
+
+        //Restore Original Page, avoid VirtualBox being crazy with unknown HCPhys on SoftHyperBreakpoint
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+        //Enable All Msr Breakpoint
+        VMR3EnableAllMsrBreakpoint(pVM);
+        //Enable All PageHyperBreakpoint
+        EnableAllPageBreakpoint(pVM, pVCpu);
+        //Enable Debug Register
+        CPUMSetGuestDR7(pVCpu, OldDr7);
+
+        TMR3NotifySuspend(pVM, pVCpu);
+
+        pVCpu->mystate.s.bSingleStepRequired = false; //Single step no more required !
+        return true;
+    }
+    return false;
+}
+
+VMMDECL(int) VMR3InjectInterrupt(PVM pVM, PVMCPU pVCpu, uint32_t enmXcpt, uint32_t uErr, uint64_t Cr2)
+{
+    return TRPMRaiseXcptErrCR2(pVCpu, NULL, (X86XCPT)enmXcpt, uErr, Cr2);
+}
+
+#include <VBox/vmm/pdmusb.h>
+
+VMMDECL(int) VMR3ClearInterrupt(PUVM pUVM, PVMCPU pVCpu)
+{
+    //return PDMR3UsbHasHub(pUVM);
+    PDMR3PowerOn(pUVM->pVM);
+    return 0;
+}
+
+VMMDECL(void) VMR3SetFDPShm(PUVM pUVM, void *pFdpShm)
+{
+    pUVM->pVM->mystate.s.pFdpShm = pFdpShm;
+}
+
+VMMDECL(bool) VMR3EnterPause(PVM pVM, PVMCPU pVCpu)
+{
+    if(pVCpu->idCpu == 0){
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+        TMR3NotifySuspend(pVM, pVCpu);
+
+        //Active wait
+        uint32_t u32WaitCount = 0;
+        while(pVCpu->mystate.s.bPauseRequired == true){
+            if(VMR3HandleSingleStep(pVM, pVCpu) == true){
+                //Update FDP_CPU_CTX
+                VMR3UpdateFdpCpuCtx(pVCpu);
+                u32WaitCount = 0;
+            }
+            //Powersaving :)
+            if((u32WaitCount & 0xFFFFFF) == 0xFFFFFF){
+                RTThreadSleep(5);
+            }else{
+                u32WaitCount++;
+            }
+        }
+
+        TMR3NotifyResume(pVM, pVCpu);
+
+        //ProcessForcedAction avoid freeze in CLI...BP...SAVE...STI
+        if(VM_FF_IS_PENDING(pVM, VM_FF_ALL_REM_MASK)
+            || VMCPU_FF_IS_PENDING(pVCpu, VMCPU_FF_ALL_REM_MASK)){
+            EMR3ProcessForcedAction(pVM, pVCpu, 0);
+        }
+
+
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+    }
+    return true;
+}
+
+#include "VMMInternal.h"
+
+
+#define DR0_ENABLED 0x3
+#define DR1_ENABLED 0xC
+#define DR2_ENABLED 0x30
+#define DR3_ENABLED 0xC0
+
+#define DR_READ 0x03
+#define DR_WRITE 0x01
+#define DR_EXECUTE 0x00
+
+/*
+* @brief Convert a Debug Register Breakpoint Type to FDP Breakpoint Type
+*
+*/
+int GetDrType(uint64_t DrType)
+{
+    switch(DrType){
+        case DR_READ:
+            return FDP_READ_BP;
+        case DR_WRITE:
+            return FDP_WRITE_BP;
+        case DR_EXECUTE:
+            return FDP_EXECUTE_BP;
+    }
+    return 0;
+}
+
+/*
+ * @brief Get the Breakpoint Lenght from Debug Register Breakpoint Lenght
+ */
+uint64_t GetDrLength(uint64_t DrLength)
+{
+    switch(DrLength){
+        case 0:
+            return 1;
+        case 1:
+            return 2;
+        case 2:
+            return 8;
+        case 3:
+            return 4;
+    }
+    return 1;
+}
+
+VMMR3DECL(uint32_t) VMR3GetCPUCount(PUVM pUVM)
+{
+    return pUVM->pVM->cCpus;
+}
+
 
 /**
  * Halted VM Wait.
@@ -1085,6 +2037,122 @@ VMMR3_INT_DECL(void) VMR3NotifyCpuFFU(PUVMCPU pUVCpu, uint32_t fFlags)
  */
 VMMR3_INT_DECL(int) VMR3WaitHalted(PVM pVM, PVMCPU pVCpu, bool fIgnoreInterrupts)
 {
+    /*MYCODE*/
+   LogRel(("[WDEBUG] VMR3WaitHalted\n")); 
+   if(pVCpu->mystate.s.bInstallDrBreakpointRequired){
+        LogRelDebug(("[WDEBUG] CPU[%d] Entering bInstallDrBreakpointRequired !!\n", pVCpu->idCpu));
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+
+        //Break all CPUs
+        VMR3Break(pVM->pUVM);
+
+        //Remove all breakpoint
+        int BreakpointId = 0;
+        for(int BreakpointId = (0+(pVCpu->idCpu*4)); BreakpointId<(int)(4+(pVCpu->idCpu*4)); BreakpointId++){
+            VMR3RemoveBreakpoint(pVM->pUVM, BreakpointId);
+        }
+
+        //Install all breakpoint
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[0] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[0]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[1] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[1]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[2] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[2]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[3] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[3]));
+        LogRelDebug(("[WDEBUG] CPU[%d] aGuestDr[7] %p\n", pVCpu->idCpu, pVCpu->mystate.s.aGuestDr[7]));
+
+        //Update Guest Breakpoint
+        for(uint8_t i=0; i<4; i++){
+            if(pVCpu->mystate.s.aGuestDr[7] & (0x3<< (i*2))){
+                uint8_t TEMP_DRX_LENGTH = (pVCpu->mystate.s.aGuestDr[7] & (0x3 << (18+i*4))) >> (18+i*4);
+                uint8_t DRX_LENGTH = GetDrLength(TEMP_DRX_LENGTH);
+                uint8_t TEMP_DRX_TYPE = (pVCpu->mystate.s.aGuestDr[7] & (0x3 << (16+i*4))) >> (16+i*4);
+                int DRX_TYPE = GetDrType(TEMP_DRX_TYPE);
+
+                int BreakpointId = -1;
+                if(DRX_TYPE > 0){
+                    BreakpointId = VMR3AddPageBreakpoint(pVM->pUVM, pVCpu, i+(pVCpu->idCpu*4), DRX_TYPE, FDP_VIRTUAL_ADDRESS, pVCpu->mystate.s.aGuestDr[i], DRX_LENGTH);
+                }
+                //LogRel(("INSTALL DR[%d] %d\n", i, BreakpointId));
+            }
+        }
+
+
+        pVCpu->mystate.s.u8StateBitmap &= ~FDP_STATE_PAUSED;
+        pVCpu->mystate.s.bPauseRequired = false;
+        pVCpu->mystate.s.bInstallDrBreakpointRequired = false;
+
+        //Continue all CPUs
+        VMR3ContinueNoWaitNoLock(pVM->pUVM);
+
+        LogRelDebug(("[WDEBUG] CPU[%d] Leaving bInstallDrBreakpointRequired !!\n", pVCpu->idCpu));
+        return VINF_EM_RESCHEDULE;
+    }
+
+    if(pVCpu->mystate.s.bHardHyperBreakPointHitted
+    || pVCpu->mystate.s.bPageHyperBreakPointHitted
+    || pVCpu->mystate.s.bSoftHyperBreakPointHitted
+    || pVCpu->mystate.s.bMsrHyperBreakPointHitted
+    || pVCpu->mystate.s.bCrHyperBreakPointHitted){
+
+        //Update FDP_CPU_CTX
+        VMR3UpdateFdpCpuCtx(pVCpu);
+
+        if(pVCpu->mystate.s.bPageHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bPageHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bSoftHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bSoftHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bHardHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bHardHyperBreakPointHitted !!\n", pVCpu->idCpu));
+            pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_HARD_BREAKPOINT_HIT;
+        }
+        if(pVCpu->mystate.s.bMsrHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bMsrHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+        if(pVCpu->mystate.s.bCrHyperBreakPointHitted){
+            LogRel(("[WDEBUG] CPU[%d] bCrHyperBreakPointHitted !!\n", pVCpu->idCpu));
+        }
+
+
+        //Restore OriginalPage for all SoftHyperBreakpoint
+        VMR3RestoreAllOriginalPage(pVM->pUVM, true, true, false);
+
+        //Set the CPU as PAUSED and BREAKPOINT_HITTED
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_BREAKPOINT_HIT;
+        pVCpu->mystate.s.u8StateBitmap |= FDP_STATE_PAUSED;
+
+        //Break all CPUs
+        VMR3Break(pVM->pUVM);
+
+        //TODO: Protect this !
+        FDP_SHM *pFdpShm = (FDP_SHM *)pVM->mystate.s.pFdpShm;
+        FDP_SetStateChanged(pFdpShm);
+
+        //Waiting for debugger resume !
+        VMR3EnterPause(pVM, pVCpu);
+
+        bool bMsrHyperBreakpointHitted = pVCpu->mystate.s.bMsrHyperBreakPointHitted;
+
+        //We are ready to go !
+        pVCpu->mystate.s.bHardHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bPageHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bSoftHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bMsrHyperBreakPointHitted = false;
+        pVCpu->mystate.s.bCrHyperBreakPointHitted = false;
+        pVCpu->mystate.s.u8StateBitmap = 0;
+
+        //Single step for MsrBreakpoint... Maybe this stuff should be done in Winbagility...
+        if(bMsrHyperBreakpointHitted == true){
+            pVCpu->mystate.s.bSingleStepRequired = true;
+            VMR3HandleSingleStep(pVM, pVCpu);
+            pVCpu->mystate.s.bSingleStepRequired = false;
+        }
+
+        LogRel(("[WDEBUG] CPU[%d] Leaving Breakpoint !\n", pVCpu->idCpu));
+        return VINF_EM_RESCHEDULE;
+    }
+    /*ENDMYCODE*/
+
     LogFlow(("VMR3WaitHalted: fIgnoreInterrupts=%d\n", fIgnoreInterrupts));
 
     /*
diff --git a/src/VBox/VMM/VMMR3/VMM.cpp b/src/VBox/VMM/VMMR3/VMM.cpp
index 96354825..bfaddbe1 100644
--- a/src/VBox/VMM/VMMR3/VMM.cpp
+++ b/src/VBox/VMM/VMMR3/VMM.cpp
@@ -1408,7 +1408,11 @@ VMMR3_INT_DECL(int) VMMR3HmRunGC(PVM pVM, PVMCPU pVCpu)
             if (RT_LIKELY(rc == VINF_SUCCESS))
                 rc = pVCpu->vmm.s.iLastGZRc;
 #endif
-        } while (rc == VINF_EM_RAW_INTERRUPT_HYPER);
+        /*MYCODE*/
+        if(pVCpu->mystate.s.bPauseRequired == true)
+            break;
+        /*ENDMYCODE*/
+       } while (rc == VINF_EM_RAW_INTERRUPT_HYPER);
 
 #if 0 /** @todo triggers too often */
         Assert(!VMCPU_FF_IS_SET(pVCpu, VMCPU_FF_TO_R3));
diff --git a/src/VBox/VMM/include/PGMInternal.h b/src/VBox/VMM/include/PGMInternal.h
index 0424c371..e410e5db 100644
--- a/src/VBox/VMM/include/PGMInternal.h
+++ b/src/VBox/VMM/include/PGMInternal.h
@@ -96,6 +96,9 @@
 #if (HC_ARCH_BITS == 64) && !defined(IN_RC)
 # define PGM_WITH_LARGE_PAGES
 #endif
+/*MYCODE*/
+#undef PGM_WITH_LARGE_PAGES
+/*ENDMYENCODE*/
 
 /**
  * Enables optimizations for MMIO handlers that exploits X86_TRAP_PF_RSVD and
diff --git a/src/VBox/VMM/testcase/tstAsmStructs.cpp b/src/VBox/VMM/testcase/tstAsmStructs.cpp
index f940e11d..df798514 100644
--- a/src/VBox/VMM/testcase/tstAsmStructs.cpp
+++ b/src/VBox/VMM/testcase/tstAsmStructs.cpp
@@ -53,5 +53,6 @@ int main()
         printf("tstAsmStructs: FAILURE - %d errors \n", rc);
     else
         printf("tstAsmStructs: SUCCESS\n");
+//    printf("tstAsmStructs: SKIPPING\n");
     return rc;
 }
